{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/CNAME","path":"CNAME","modified":0,"renderable":0},{"_id":"source/img/icon_wechat.png","path":"img/icon_wechat.png","modified":0,"renderable":0},{"_id":"source/img/01.jpg","path":"img/01.jpg","modified":0,"renderable":0},{"_id":"source/img/19.jpg","path":"img/19.jpg","modified":0,"renderable":0},{"_id":"source/img/17.jpg","path":"img/17.jpg","modified":0,"renderable":0},{"_id":"source/img/404-bg.jpg","path":"img/404-bg.jpg","modified":0,"renderable":0},{"_id":"source/img/header_img/allon.jpeg","path":"img/header_img/allon.jpeg","modified":0,"renderable":0},{"_id":"themes/beantech/source/css/archive.styl","path":"css/archive.styl","modified":0,"renderable":1},{"_id":"themes/beantech/source/css/beantech.css","path":"css/beantech.css","modified":0,"renderable":1},{"_id":"themes/beantech/source/css/beantech.min.css","path":"css/beantech.min.css","modified":0,"renderable":1},{"_id":"themes/beantech/source/css/highlight.styl","path":"css/highlight.styl","modified":0,"renderable":1},{"_id":"themes/beantech/source/css/hux-blog.css","path":"css/hux-blog.css","modified":0,"renderable":1},{"_id":"themes/beantech/source/css/hux-blog.min.css","path":"css/hux-blog.min.css","modified":0,"renderable":1},{"_id":"themes/beantech/source/css/rocket.styl","path":"css/rocket.styl","modified":0,"renderable":1},{"_id":"themes/beantech/source/css/signature.styl","path":"css/signature.styl","modified":0,"renderable":1},{"_id":"themes/beantech/source/css/syntax.css","path":"css/syntax.css","modified":0,"renderable":1},{"_id":"themes/beantech/source/css/toc.styl","path":"css/toc.styl","modified":0,"renderable":1},{"_id":"themes/beantech/source/css/widget.styl","path":"css/widget.styl","modified":0,"renderable":1},{"_id":"themes/beantech/source/fonts/glyphicons-halflings-regular.eot","path":"fonts/glyphicons-halflings-regular.eot","modified":0,"renderable":1},{"_id":"themes/beantech/source/fonts/glyphicons-halflings-regular.woff","path":"fonts/glyphicons-halflings-regular.woff","modified":0,"renderable":1},{"_id":"themes/beantech/source/fonts/glyphicons-halflings-regular.ttf","path":"fonts/glyphicons-halflings-regular.ttf","modified":0,"renderable":1},{"_id":"themes/beantech/source/fonts/glyphicons-halflings-regular.woff2","path":"fonts/glyphicons-halflings-regular.woff2","modified":0,"renderable":1},{"_id":"themes/beantech/source/js/hux-blog.js","path":"js/hux-blog.js","modified":0,"renderable":1},{"_id":"themes/beantech/source/js/bootstrap.min.js","path":"js/bootstrap.min.js","modified":0,"renderable":1},{"_id":"themes/beantech/source/js/hux-blog.min.js","path":"js/hux-blog.min.js","modified":0,"renderable":1},{"_id":"themes/beantech/source/js/jquery.nav.js","path":"js/jquery.nav.js","modified":0,"renderable":1},{"_id":"themes/beantech/source/js/jquery.tagcloud.js","path":"js/jquery.tagcloud.js","modified":0,"renderable":1},{"_id":"themes/beantech/source/js/toc.js","path":"js/toc.js","modified":0,"renderable":1},{"_id":"themes/beantech/source/js/totop.js","path":"js/totop.js","modified":0,"renderable":1},{"_id":"source/img/02.jpg","path":"img/02.jpg","modified":0,"renderable":0},{"_id":"source/img/header_img/Iron-Man-3.jpg","path":"img/header_img/Iron-Man-3.jpg","modified":0,"renderable":0},{"_id":"source/img/ironman-draw.png","path":"img/ironman-draw.png","modified":0,"renderable":0},{"_id":"themes/beantech/source/css/bootstrap.min.css","path":"css/bootstrap.min.css","modified":0,"renderable":1},{"_id":"themes/beantech/source/fonts/glyphicons-halflings-regular.svg","path":"fonts/glyphicons-halflings-regular.svg","modified":0,"renderable":1},{"_id":"themes/beantech/source/js/bootstrap.js","path":"js/bootstrap.js","modified":0,"renderable":1},{"_id":"themes/beantech/source/js/jquery.min.js","path":"js/jquery.min.js","modified":0,"renderable":1},{"_id":"source/img/13.jpg","path":"img/13.jpg","modified":0,"renderable":0},{"_id":"source/img/16.jpg","path":"img/16.jpg","modified":0,"renderable":0},{"_id":"source/img/18.jpg","path":"img/18.jpg","modified":0,"renderable":0},{"_id":"source/img/contact-bg.jpg","path":"img/contact-bg.jpg","modified":0,"renderable":0},{"_id":"source/img/signature/BeanTechSign-white.png","path":"img/signature/BeanTechSign-white.png","modified":0,"renderable":0},{"_id":"themes/beantech/source/css/bootstrap.css","path":"css/bootstrap.css","modified":0,"renderable":1},{"_id":"themes/beantech/source/css/images/ironman.png","path":"css/images/ironman.png","modified":0,"renderable":1},{"_id":"themes/beantech/source/css/images/rocket.png","path":"css/images/rocket.png","modified":0,"renderable":1},{"_id":"source/img/03.jpg","path":"img/03.jpg","modified":0,"renderable":0},{"_id":"source/img/signature/BeanTechSign-black.png","path":"img/signature/BeanTechSign-black.png","modified":0,"renderable":0},{"_id":"themes/beantech/source/js/jquery.js","path":"js/jquery.js","modified":0,"renderable":1},{"_id":"source/img/04.jpg","path":"img/04.jpg","modified":0,"renderable":0},{"_id":"source/img/05.jpg","path":"img/05.jpg","modified":0,"renderable":0},{"_id":"source/img/06.jpg","path":"img/06.jpg","modified":0,"renderable":0},{"_id":"source/img/header_img/tag-bg.png","path":"img/header_img/tag-bg.png","modified":0,"renderable":0},{"_id":"source/img/07.jpg","path":"img/07.jpg","modified":0,"renderable":0},{"_id":"source/img/08.jpg","path":"img/08.jpg","modified":0,"renderable":0},{"_id":"source/img/09.jpg","path":"img/09.jpg","modified":0,"renderable":0},{"_id":"source/img/header_img/archive-bg.png","path":"img/header_img/archive-bg.png","modified":0,"renderable":0},{"_id":"source/img/10.jpg","path":"img/10.jpg","modified":0,"renderable":0},{"_id":"source/img/header_img/home-bg-o.png","path":"img/header_img/home-bg-o.png","modified":0,"renderable":0},{"_id":"source/img/header_img/home-bg-2-dark.png","path":"img/header_img/home-bg-2-dark.png","modified":0,"renderable":0},{"_id":"source/img/11.jpg","path":"img/11.jpg","modified":0,"renderable":0},{"_id":"source/img/12.jpg","path":"img/12.jpg","modified":0,"renderable":0},{"_id":"source/img/14.jpg","path":"img/14.jpg","modified":0,"renderable":0},{"_id":"source/img/15.jpg","path":"img/15.jpg","modified":0,"renderable":0}],"Cache":[{"_id":"source/.DS_Store","hash":"ecb4a109a5825d37e56941c3537c2cb62284116c","modified":1511766947571},{"_id":"source/CNAME","hash":"5012ea393524373dadb8c166278dfe186d2c1160","modified":1511251291003},{"_id":"themes/beantech/.DS_Store","hash":"9940708165d3891b3b3990975deb8c14ae3009cb","modified":1511604624349},{"_id":"themes/beantech/LICENSE","hash":"2b209f06bebeb2a8c2b7e187e436f3e1e1fbc8a7","modified":1511232973874},{"_id":"themes/beantech/_config.yml","hash":"d6c50638eb54009037290a3c1999b6166d49c692","modified":1511331932967},{"_id":"source/archive/index.md","hash":"a508fa64c7a36bd17ba1ecabcd7ca0c37ebfc6d0","modified":1511595173809},{"_id":"source/about/index.md","hash":"c66fb09e627a1ef8a0a4a154e201425a71f23223","modified":1511595145353},{"_id":"source/html/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1511339527121},{"_id":"source/tags/index.md","hash":"1e3467d2fbac0c9b837306c336a98315d638b64c","modified":1511595205003},{"_id":"source/_posts/.DS_Store","hash":"2d0de7b50a2fd319402d9d1cdc929e2da03dd48a","modified":1511253466083},{"_id":"source/_posts/Chapter-02-control-structures-and-functions.md","hash":"27a073ad4d5796e1da21d340b4023fbbee50c2b3","modified":1511591330495},{"_id":"source/_posts/Chapter-01-the-basics.md","hash":"07633584e19502cda5ae0b7a5a763076de92f37a","modified":1511591330494},{"_id":"source/_posts/Chapter-03-working-with-arrays.md","hash":"7f9bc6806aa1544d8aeed4a0407395709f9a8013","modified":1511591330495},{"_id":"source/_posts/Chapter-04-Map和元组.md","hash":"4be09270a0ddc6335872fd27b8f44dae15c418e3","modified":1511591330495},{"_id":"source/_posts/Chapter-05-类.md","hash":"fc8b1304e6c634bb5b0f42f8b797d44260ed977e","modified":1511591330495},{"_id":"source/_posts/Chapter-06-对象.md","hash":"519a08738d2f34b9664f46d466bb4381d64f018c","modified":1511591330496},{"_id":"source/_posts/Chapter-07-包和引入.md","hash":"820a9b77411603d8b45cffab59abf59de3e8c5e0","modified":1511591330496},{"_id":"source/_posts/Chapter-08-继承.md","hash":"61a9cbacc8dd8c80a4f5c766a0edb04a3efcee20","modified":1511591330496},{"_id":"source/_posts/Chapter-09-文件和正则表达式.md","hash":"a9358900cddd9fb2fde67d561d35040a01888674","modified":1511591330496},{"_id":"source/_posts/Chapter-10-特质.md","hash":"e3b6f8b5c828779f7e8b435bd27ac6399638e351","modified":1511591330497},{"_id":"source/_posts/Chapter-11-operators.md","hash":"1d53781b1906d48887dfed1f2e74a9b4bacfa6d5","modified":1511591330497},{"_id":"source/_posts/chapter-02-sharing-and-multimedia.md","hash":"9caac83711d6aaa8d8131f7623a00d21888c32d3","modified":1511591901371},{"_id":"source/_posts/chapter-01-getting-started.md","hash":"8090daff9248c44d31e9c9070dbd123b72a1c3a0","modified":1511591901371},{"_id":"source/_posts/chapter-03-bitmap-and-background-threads.md","hash":"792043e86b37ae8cb924746c3d2fbae7c03dd68e","modified":1511591901371},{"_id":"source/_posts/chapter-04-best-practices-for-memory.md","hash":"c22b4eaec82ed45cb2d84d24394c213acab2187f","modified":1511591901372},{"_id":"source/_posts/书法基础理论.md","hash":"5da87debc503a46761f26fc94c138dd0b33ed5c6","modified":1511347214149},{"_id":"source/_posts/书法工具.md","hash":"ea3b779d5097872be3bb79f2ce16315a054d4892","modified":1511347227243},{"_id":"source/_posts/微积分.md","hash":"9da4d3e40ebf35da37be84c4d9f6c2e37a5613aa","modified":1511347240148},{"_id":"source/_posts/第01章 计算机系统漫游.md","hash":"e39350e79cdc57981fc483ce0b2c8064cd2cc04d","modified":1511600735751},{"_id":"source/_posts/第02章 程序结构和执行.md","hash":"c8604640dd6628f1d2aab578741cd3312b31fa1b","modified":1511600749098},{"_id":"source/_posts/第03章 程序的机器级表示.md","hash":"3102526aa19bf2d1f9fd18b4bb5209c4c6508549","modified":1511600763135},{"_id":"source/_posts/线性代数.md","hash":"883633b65851221a48a46f4c31b707dd59a84c4b","modified":1511434220475},{"_id":"source/_posts/資治通鑑總覽.md","hash":"79a01bf9e16f11d7ed00e2fb77e7578940f03cb3","modified":1511768405182},{"_id":"source/img/.DS_Store","hash":"fafa925f8f9fd02ea30171053dbc450a46b2d370","modified":1511605872836},{"_id":"source/img/icon_wechat.png","hash":"4188058026609de06c6cac88b349a2da831a1783","modified":1511232973868},{"_id":"themes/beantech/languages_to_be_added/de.yml","hash":"424a9c1e6ab69334d7873f6574da02ca960aa572","modified":1511232973874},{"_id":"themes/beantech/languages_to_be_added/default.yml","hash":"97326c9e6518d9f379778178b3b8f9a58434725d","modified":1511232973874},{"_id":"themes/beantech/languages_to_be_added/en.yml","hash":"0f4870d3248b91fdd799a27cc288b97d430c39d0","modified":1511592723705},{"_id":"themes/beantech/languages_to_be_added/es.yml","hash":"cb4eeca0ed3768a77e0cd216300f2b2549628b1b","modified":1511232973875},{"_id":"themes/beantech/languages_to_be_added/no.yml","hash":"8ca475a3b4f8efe6603030f0013aae39668230e1","modified":1511232973875},{"_id":"themes/beantech/languages_to_be_added/pl.yml","hash":"de7eb5850ae65ba7638e907c805fea90617a988c","modified":1511232973875},{"_id":"themes/beantech/languages_to_be_added/ru.yml","hash":"42df7afeb7a35dc46d272b7f4fb880a9d9ebcaa5","modified":1511232973875},{"_id":"themes/beantech/languages_to_be_added/zh-CN.yml","hash":"7bfcb0b8e97d7e5edcfca8ab26d55d9da2573c1c","modified":1511232973876},{"_id":"themes/beantech/languages_to_be_added/zh-TW.yml","hash":"9acac6cc4f8002c3fa53ff69fb8cf66c915bd016","modified":1511232973876},{"_id":"themes/beantech/layout/404.ejs","hash":"a4d73541a53e56b7dd46249c6d27cb59f4d97422","modified":1511232973876},{"_id":"themes/beantech/layout/about.ejs","hash":"edcf8fa3bf7093c974d418ffef42ac89c19af128","modified":1511232973879},{"_id":"themes/beantech/layout/archive.ejs","hash":"7c2ce1e1ae70f0c8c69ad7a5c97aaa40186cb94a","modified":1511599798756},{"_id":"themes/beantech/layout/index.ejs","hash":"3b9118830addb54f8eb8836ddd9ebd2a2924ab85","modified":1511592365961},{"_id":"themes/beantech/layout/keynote.ejs","hash":"fae2e777f13541e7d20e8cf2cf26c84ddbfc85ac","modified":1511346650282},{"_id":"themes/beantech/layout/layout.ejs","hash":"17bf87aea44fc4cc6002f41074d598e4ce5bceb1","modified":1511604030957},{"_id":"themes/beantech/layout/page.ejs","hash":"eb0ab2b3ac11710e966caa558609e109faf55e3a","modified":1511346593181},{"_id":"themes/beantech/layout/post.ejs","hash":"4bb37e8038ed5bc2a2195e552c5b8cdf9d8d4101","modified":1511612884643},{"_id":"themes/beantech/layout/tags.ejs","hash":"2c72eb2e89130658aa068d80d27b561b509c5dcd","modified":1511232973880},{"_id":"themes/beantech/source/.DS_Store","hash":"9c2ed83d7fc0585d268d3eabf9f4c24942386c2f","modified":1511604624346},{"_id":"source/img/01.jpg","hash":"c2f53433423932da7518525a792d2d3ced43a9aa","modified":1511289470000},{"_id":"source/img/19.jpg","hash":"4798e62aa0f996c9c38c794f2f8e635331d9cb4d","modified":1511605866085},{"_id":"source/img/17.jpg","hash":"a7882f3125e5655a89e3cc39976621a73e7e7dba","modified":1511605231269},{"_id":"source/img/header_img/.DS_Store","hash":"1093dca70a6baeecfebd9b7d770e580852142632","modified":1511604772289},{"_id":"source/img/404-bg.jpg","hash":"68f7d525269a94287e0ad18713ae232fb59dcf71","modified":1511232973838},{"_id":"source/img/header_img/allon.jpeg","hash":"b143ecf896f94ee88fc1b3c61beb895b1a742c22","modified":1511345204399},{"_id":"themes/beantech/layout/_partial/footer.ejs","hash":"64c0f212c4f42a0a97dae03ef6c71fe6e896bbd6","modified":1511603416164},{"_id":"themes/beantech/layout/_partial/head.ejs","hash":"edca3ad1d61e8b817b28dc322f3e94cb1b685fc6","modified":1511603930183},{"_id":"themes/beantech/layout/_partial/header.ejs","hash":"28e768ba924fdb758ba8d862a6e11600a08e0e22","modified":1511615135837},{"_id":"themes/beantech/layout/_partial/nav.ejs","hash":"242b3e23b3fcc185fd0194a48b088b57691a0c05","modified":1511595253911},{"_id":"themes/beantech/layout/_partial/pagination.ejs","hash":"557d6bb069a1d48af49ae912994653f44b32a570","modified":1511232973877},{"_id":"themes/beantech/layout/_partial/sidebar.ejs","hash":"2e4e528a555917b2a267da4db2440bcc4a7a65ab","modified":1511232973878},{"_id":"themes/beantech/layout/_partial/toc.ejs","hash":"837f01e8a20e5023b4b292d1b3141a399567da65","modified":1511620278700},{"_id":"themes/beantech/layout/_widget/archive.ejs","hash":"1dbf5a6c465ac7eadbd0643d3c55bbcca699e20a","modified":1511346885359},{"_id":"themes/beantech/layout/_widget/category.ejs","hash":"1cf485def07dc06e870dc9613767c6c614bcf428","modified":1511232973878},{"_id":"themes/beantech/layout/_widget/featured-tags.ejs","hash":"bf9809f20becab1ffe6194e2c5be74e501763a30","modified":1511346536507},{"_id":"themes/beantech/layout/_widget/friends-blog.ejs","hash":"eb2dc41f0b6c7a7751226a3ab591101182927008","modified":1511346842869},{"_id":"themes/beantech/layout/_widget/recent-posts.ejs","hash":"97983b186b5737e0d7b1fcde22f34d047e44d20e","modified":1511346762854},{"_id":"themes/beantech/layout/_widget/short-about.ejs","hash":"850b18e4b5aaa10ad5fb4b37dd96c4b7fd6e6740","modified":1511346698269},{"_id":"themes/beantech/source/css/.DS_Store","hash":"5835e1902f6b3adb63b685ad41524d81a3f6c047","modified":1511604624347},{"_id":"themes/beantech/source/css/archive.styl","hash":"715bcbd085eb95ec26c9805c11c374919cde971c","modified":1511232973881},{"_id":"themes/beantech/source/css/beantech.css","hash":"4c361354fd8e9851923fb21a620bc079380ebcd8","modified":1511232973881},{"_id":"themes/beantech/source/css/beantech.min.css","hash":"06a73fac70dc52adb9f7d1d0e9bbcad7da132541","modified":1511598875975},{"_id":"themes/beantech/source/css/highlight.styl","hash":"e842080e6d580f0f70a7df71fbde3c4e49463c19","modified":1511232973883},{"_id":"themes/beantech/source/css/hux-blog.css","hash":"2e8520c16e39dce6cc5c99ab3e267b2e2d6bc0c5","modified":1507959232000},{"_id":"themes/beantech/source/css/hux-blog.min.css","hash":"8ed9da2013cddd8bf119ff740342a5c2c8b1f3e7","modified":1511604466258},{"_id":"themes/beantech/source/css/rocket.styl","hash":"e15c51c8566ecd943112e57592888dd318b6fa6a","modified":1511232973885},{"_id":"themes/beantech/source/css/signature.styl","hash":"88159b31c59d59c01a0b534af57242662a2a3969","modified":1511232973885},{"_id":"themes/beantech/source/css/syntax.css","hash":"ddb061122db565f14b3018d07e31d12be0b5914b","modified":1507959232000},{"_id":"themes/beantech/source/css/toc.styl","hash":"6c9a2d5f6f981624e0c4b64323493e8614efea29","modified":1511232973885},{"_id":"themes/beantech/source/css/widget.styl","hash":"7a9f735f5ef323dc2950fbd9d76daa16c9a0f1a9","modified":1511232973885},{"_id":"themes/beantech/source/fonts/glyphicons-halflings-regular.eot","hash":"86b6f62b7853e67d3e635f6512a5a5efc58ea3c3","modified":1511232973886},{"_id":"themes/beantech/source/fonts/glyphicons-halflings-regular.woff","hash":"278e49a86e634da6f2a02f3b47dd9d2a8f26210f","modified":1511232973888},{"_id":"themes/beantech/source/fonts/glyphicons-halflings-regular.ttf","hash":"44bc1850f570972267b169ae18f1cb06b611ffa2","modified":1511232973888},{"_id":"themes/beantech/source/fonts/glyphicons-halflings-regular.woff2","hash":"ca35b697d99cae4d1b60f2d60fcd37771987eb07","modified":1511232973888},{"_id":"themes/beantech/source/js/hux-blog.js","hash":"4b4d3c557405d04c3087d36c13e2834fe05c0f73","modified":1511232973890},{"_id":"themes/beantech/source/js/bootstrap.min.js","hash":"b3f2ef9f985e7906c9360756b73cd64bf7733647","modified":1511232973889},{"_id":"themes/beantech/source/js/hux-blog.min.js","hash":"1563e7f70550ac6b30803d6f449719b853200e35","modified":1511232973890},{"_id":"themes/beantech/source/js/jquery.nav.js","hash":"ef2160a456176a4d09cc0b95d52b27dfbbadf2d8","modified":1511232973892},{"_id":"themes/beantech/source/js/jquery.tagcloud.js","hash":"4e5fd0b07f3bd935f2e603710447e039e3677211","modified":1511232973893},{"_id":"themes/beantech/source/js/toc.js","hash":"41e52551731854224c249d53010c1bae5aa92ffa","modified":1511232973893},{"_id":"themes/beantech/source/js/totop.js","hash":"c05360f6fc699ac12e794b1764b4a952713a3017","modified":1511232973893},{"_id":"source/img/02.jpg","hash":"dfe50b46afb7ed966e40119a301a66ee88f31df4","modified":1511319796493},{"_id":"source/img/header_img/Iron-Man-3.jpg","hash":"62a9a76854503c327990cc8d10de293ab6e9588f","modified":1511232973846},{"_id":"source/img/ironman-draw.png","hash":"7d6a06b4b544ab146c3b3e8474edc33f14ac6e4d","modified":1511232973870},{"_id":"themes/beantech/source/css/bootstrap.min.css","hash":"973e37a8502921d56bc02bb55321f45b072b6f71","modified":1507959232000},{"_id":"themes/beantech/source/fonts/glyphicons-halflings-regular.svg","hash":"de51a8494180a6db074af2dee2383f0a363c5b08","modified":1511232973887},{"_id":"themes/beantech/source/js/bootstrap.js","hash":"f8752e9ae24daec0a0baffd7819122f8c6fd9103","modified":1511232973889},{"_id":"themes/beantech/source/js/jquery.min.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1511232973892},{"_id":"source/_posts/media/15011539840051/15056181691411.jpg","hash":"f188cdffd41bf965f52e9d9d6761649da54cd986","modified":1505618169000},{"_id":"source/_posts/media/15011539840051/15056182644846.jpg","hash":"5d907ef51b9b10d0da9d425e8c1577a50aa0a191","modified":1505618264000},{"_id":"source/_posts/media/15011539840051/15056182806656.jpg","hash":"d8af9864bbd261309f12e42bd06754156fc20806","modified":1505618280000},{"_id":"source/_posts/media/15011539840051/15056182954486.jpg","hash":"280cf1b6ea30323e3834a43c978708be3bfcd56d","modified":1505618295000},{"_id":"source/_posts/media/15011539840051/15056183313856.jpg","hash":"ef9f6a61c222d0e31f5abd693df7a84cd90e5efb","modified":1505618331000},{"_id":"source/img/13.jpg","hash":"37b130047ad19e31a44c88a929b8c738b9010342","modified":1511573220000},{"_id":"source/img/16.jpg","hash":"fea570eb9e4a6e12090201ce3a9c1e11410b86a5","modified":1511605176591},{"_id":"source/img/18.jpg","hash":"f84495b6dcadc61ec84c2e1cc0dc72485729b459","modified":1511605514306},{"_id":"source/img/contact-bg.jpg","hash":"6af63305c923899017e727b5ca968a2703bc08cf","modified":1511232973845},{"_id":"source/img/signature/BeanTechSign-white.png","hash":"34289ed41cf9ddac2d56be46fbb1515b7d5913cd","modified":1511232973873},{"_id":"themes/beantech/source/css/bootstrap.css","hash":"41c54bf695145ae0b4d9020a1da308ceb05dcaf3","modified":1507959232000},{"_id":"themes/beantech/source/css/images/ironman.png","hash":"2f0db0ab15d466c4065d9f6102fdf829726d9e3f","modified":1511232973884},{"_id":"themes/beantech/source/css/images/rocket.png","hash":"6dee0406955aa9b7a261161d30f2538a671e806b","modified":1511232973884},{"_id":"source/img/03.jpg","hash":"0c5a71083cecfca277257b912f9243e39ce85094","modified":1511289470000},{"_id":"source/img/signature/BeanTechSign-black.png","hash":"94b7102e819fd6ee082d3fb0166f4de7458c22ff","modified":1511232973872},{"_id":"themes/beantech/source/js/jquery.js","hash":"1852661bd11a09ca9b9cb63d1aa6ff390fffaf4e","modified":1511232973892},{"_id":"source/img/04.jpg","hash":"695b52e10134f4eb5d4a9267aedc6cf9922fe5c6","modified":1511322575516},{"_id":"source/img/05.jpg","hash":"1265dc75b3f60a1dd666c687994189aed01c8de7","modified":1511321086510},{"_id":"source/img/06.jpg","hash":"149d868cac9081b99725117b5cb4ff67e9e8eff3","modified":1511322049535},{"_id":"source/img/header_img/tag-bg.png","hash":"94c3942bdcb1a6c4ac64bd6365e2066302380847","modified":1511316774000},{"_id":"source/img/07.jpg","hash":"9adcca2d2867c8248b684621f8619a5c42d6cfb1","modified":1511321613962},{"_id":"source/img/08.jpg","hash":"81e19c82746fcf2248e5d46cdf40849a5b59fe84","modified":1511324426499},{"_id":"source/img/09.jpg","hash":"1f218120eca78cbecf2bb25eab2cec0eb3d7471a","modified":1511320236730},{"_id":"source/img/header_img/archive-bg.png","hash":"f4345d8edd7167fe1500b122aec4922893630fd3","modified":1511316774000},{"_id":"source/img/10.jpg","hash":"2f9c052795706dd236dd7e224d0517425024bc17","modified":1511323176597},{"_id":"source/img/header_img/home-bg-o.png","hash":"e9ba54c513f0a37bbccddfdf7841570f86cdc6a5","modified":1511316774000},{"_id":"source/img/header_img/home-bg-2-dark.png","hash":"74d23c05e93a2e4bb469737f69d1714d1074bcf9","modified":1511316774000},{"_id":"source/img/11.jpg","hash":"7c28c0188909f209048bf952ad3812d14d846a65","modified":1511323894684},{"_id":"source/img/12.jpg","hash":"a767f6baecc43ba0b21cc76d281dafbfaa156c3d","modified":1511289472000},{"_id":"source/img/14.jpg","hash":"7bdf575736fd75247687f2e4de37c528a2fd7b69","modified":1511573220000},{"_id":"source/img/15.jpg","hash":"2e22c73b122f4e4a1140ad05035c5d7c6b30abec","modified":1511573220000},{"_id":"public/page-sitemap.xml","hash":"842fc9922b854815b212b97b11e24dee2808c199","modified":1511768413360},{"_id":"public/post-sitemap.xml","hash":"31d064a299510e62af50090ad43dcafa73d0e8e1","modified":1511768413539},{"_id":"public/tag-sitemap.xml","hash":"5402c90d4479d9335ba34b61f0bf01b7329290b1","modified":1511768413604},{"_id":"public/sitemap.xsl","hash":"4321fa69dc1b8811d32b7a1478e5603e038cea1a","modified":1511768413610},{"_id":"public/sitemap.xml","hash":"8ddd781f66a7e84a8a3419dc799c3c4a504de566","modified":1511768413610},{"_id":"public/tags/index.html","hash":"c2202eb37185464e6b581e07d4e6ddc465343500","modified":1511768413690},{"_id":"public/2017/11/27/資治通鑑總覽/index.html","hash":"5e8224bdfa8a9ab29ae75116950fc42da7581e0f","modified":1511768413690},{"_id":"public/2017/11/22/书法工具/index.html","hash":"8d05f3ffde9a1b174204889ee6d76e73faabac1a","modified":1511768413690},{"_id":"public/2017/11/22/书法基础理论/index.html","hash":"b6534dd1c03d57db1f06daecf742ed9a940c074c","modified":1511768413690},{"_id":"public/2017/11/22/微积分/index.html","hash":"9d26ff6679cb90d3afe5011ec6f61da8e590d3dc","modified":1511768413690},{"_id":"public/2017/11/21/线性代数/index.html","hash":"b0173c4ce3c9358e74d9e8fccd23359de9b737db","modified":1511768413690},{"_id":"public/2017/02/22/第03章 程序的机器级表示/index.html","hash":"168c50e5eab7d2a2c7201b5efcc279c4aeb7d1ad","modified":1511768413690},{"_id":"public/2017/02/22/第02章 程序结构和执行/index.html","hash":"b289c151bef02136b4495d54b1e1a5d87f8da553","modified":1511768413690},{"_id":"public/2017/02/22/第01章 计算机系统漫游/index.html","hash":"04e4736a1c49c3e48c05dd9a6f835f43ca7494df","modified":1511768413691},{"_id":"public/2016/02/22/chapter-02-sharing-and-multimedia/index.html","hash":"38d015726b801a68153b9e27a980f8c4632839db","modified":1511768413691},{"_id":"public/2016/02/22/chapter-04-best-practices-for-memory/index.html","hash":"07c9d4d64ee7039eb18d7f7bb89f2631b139b4ca","modified":1511768413691},{"_id":"public/2016/02/22/chapter-03-bitmap-and-background-threads/index.html","hash":"09c436369c19eb7c2248c0689048e49527869fe7","modified":1511768413691},{"_id":"public/2016/02/22/chapter-01-getting-started/index.html","hash":"8970257e726ba809ccc0b4245f066efe9f5c0cac","modified":1511768413691},{"_id":"public/2015/06/22/Chapter-07-包和引入/index.html","hash":"ac26fe9e72a697c24427affef9ec741907ec508b","modified":1511768413691},{"_id":"public/2015/06/22/Chapter-01-the-basics/index.html","hash":"c13217ba6c3b7c9d979b26842718ea597215fa40","modified":1511768413691},{"_id":"public/2015/06/22/Chapter-10-特质/index.html","hash":"396f8c60e858db0ded7cee0fbe94ade69145cc0e","modified":1511768413691},{"_id":"public/2015/06/22/Chapter-09-文件和正则表达式/index.html","hash":"07c47c81450bad417ec9eb455a8cd2eaa17702a0","modified":1511768413691},{"_id":"public/2015/06/22/Chapter-08-继承/index.html","hash":"2d1673e789385a612603757699731b3df8f0e06e","modified":1511768413691},{"_id":"public/2015/06/22/Chapter-11-operators/index.html","hash":"0e139ffb5a78ca3c1e5c75a1199c708fe2620cf7","modified":1511768413691},{"_id":"public/2015/06/22/Chapter-06-对象/index.html","hash":"d6b3729365e93b30f3a8f671f843a8c4d7af8e80","modified":1511768413691},{"_id":"public/2015/06/22/Chapter-05-类/index.html","hash":"dd7b562fed94405d8bc23b5cb3ec48ecbf776b12","modified":1511768413691},{"_id":"public/2015/06/22/Chapter-04-Map和元组/index.html","hash":"08d30a811a8b732d1c203fc3dd9ebd2ba69638fd","modified":1511768413691},{"_id":"public/2015/06/22/Chapter-03-working-with-arrays/index.html","hash":"4eb41c8fa92e70a374a025b805a0c3c6e5ec78ac","modified":1511768413691},{"_id":"public/2015/06/22/Chapter-02-control-structures-and-functions/index.html","hash":"18a357aa981db307e3f16a30cec2211a7427ccb2","modified":1511768413692},{"_id":"public/about/index.html","hash":"1c6ed15bb26f39aabeb702c1ca1723919c4196c0","modified":1511768413692},{"_id":"public/archive/index.html","hash":"cda972464c9805a244ccef5de8a350205b274540","modified":1511768413692},{"_id":"public/archives/index.html","hash":"51ee38500f13842619ae05bbad73a0b8ae276a95","modified":1511768413692},{"_id":"public/archives/archives/2/index.html","hash":"754702d8c403fe8d1ef6b86a9b797153b29336d5","modified":1511768413692},{"_id":"public/archives/archives/3/index.html","hash":"1678cd754fe1e25f3bec36793e4ac9b55684bbed","modified":1511768413692},{"_id":"public/archives/2015/index.html","hash":"4946d4f9903772ac3906be96b7aa013e0e8486d1","modified":1511768413692},{"_id":"public/archives/2015/archives/2/index.html","hash":"fbee5d2c278a4fae7edab640ff877858006d63b8","modified":1511768413692},{"_id":"public/archives/2015/06/index.html","hash":"e2a9a9e27feb25768ffbc55293a5cf62271bed5a","modified":1511768413692},{"_id":"public/archives/2015/06/archives/2/index.html","hash":"a0d4e7af9b78f5614734d713094fa696af90b39d","modified":1511768413692},{"_id":"public/archives/2016/index.html","hash":"b442e1f7a1566a4674f3369363026f3bb90306ef","modified":1511768413692},{"_id":"public/archives/2016/02/index.html","hash":"317d7acd6290933cba98ab2f7c76d2e50672f249","modified":1511768413692},{"_id":"public/archives/2017/index.html","hash":"835451c53da0405fd753428da6340f3f17314efe","modified":1511768413692},{"_id":"public/archives/2017/02/index.html","hash":"a455512b59d2d009256667e72c755df8080687c4","modified":1511768413693},{"_id":"public/archives/2017/11/index.html","hash":"10152475f97a7a5c44c5aa8fc61b7e47ac2dcfad","modified":1511768413693},{"_id":"public/index.html","hash":"70700b1285123c622bbd21e7297c68496dad25a5","modified":1511768413693},{"_id":"public/archives/2/index.html","hash":"40cbf85a3ef7628daedc2dbb5a7a889805f1c42f","modified":1511768413693},{"_id":"public/archives/3/index.html","hash":"a474ad76e80e25afa732ea7997f9e792b39e5114","modified":1511768413693},{"_id":"public/tags/scala/index.html","hash":"83c09b2df021c21130a7c56121e0cca235b85e60","modified":1511768413693},{"_id":"public/tags/scala/archives/2/index.html","hash":"a7183dc6d946b11fb8ffc42d8dda4cd64b815608","modified":1511768413693},{"_id":"public/tags/android/index.html","hash":"0bcc1bd0ed7fa788619f39fdcdd15e4772031e4a","modified":1511768413693},{"_id":"public/tags/书法/index.html","hash":"748bd74b9047bbb7a0c087f6c395f502f522473d","modified":1511768413693},{"_id":"public/tags/数学/index.html","hash":"cee27633896db8dabafbbfdddba1c33efcf30210","modified":1511768413694},{"_id":"public/tags/深入理解计算机系统/index.html","hash":"48ff0b36127c3a0e682ca8bf8a82300d58fb02fe","modified":1511768413694},{"_id":"public/tags/資治通鑑/index.html","hash":"eaadbcfbc46ab29b9e2b2a9c981e7c6fcab85447","modified":1511768413694},{"_id":"public/CNAME","hash":"5012ea393524373dadb8c166278dfe186d2c1160","modified":1511768413703},{"_id":"public/img/icon_wechat.png","hash":"4188058026609de06c6cac88b349a2da831a1783","modified":1511768413703},{"_id":"public/img/header_img/allon.jpeg","hash":"b143ecf896f94ee88fc1b3c61beb895b1a742c22","modified":1511768413703},{"_id":"public/fonts/glyphicons-halflings-regular.eot","hash":"86b6f62b7853e67d3e635f6512a5a5efc58ea3c3","modified":1511768413703},{"_id":"public/fonts/glyphicons-halflings-regular.woff","hash":"278e49a86e634da6f2a02f3b47dd9d2a8f26210f","modified":1511768413703},{"_id":"public/fonts/glyphicons-halflings-regular.ttf","hash":"44bc1850f570972267b169ae18f1cb06b611ffa2","modified":1511768413703},{"_id":"public/fonts/glyphicons-halflings-regular.woff2","hash":"ca35b697d99cae4d1b60f2d60fcd37771987eb07","modified":1511768413703},{"_id":"public/css/images/ironman.png","hash":"2f0db0ab15d466c4065d9f6102fdf829726d9e3f","modified":1511768413703},{"_id":"public/css/images/rocket.png","hash":"6dee0406955aa9b7a261161d30f2538a671e806b","modified":1511768413703},{"_id":"public/img/01.jpg","hash":"c2f53433423932da7518525a792d2d3ced43a9aa","modified":1511768413890},{"_id":"public/img/19.jpg","hash":"4798e62aa0f996c9c38c794f2f8e635331d9cb4d","modified":1511768413890},{"_id":"public/img/header_img/Iron-Man-3.jpg","hash":"62a9a76854503c327990cc8d10de293ab6e9588f","modified":1511768413894},{"_id":"public/fonts/glyphicons-halflings-regular.svg","hash":"de51a8494180a6db074af2dee2383f0a363c5b08","modified":1511768413894},{"_id":"public/css/archive.css","hash":"8db895ebaeff19ac145c961abcfd5d4a8d67a8ea","modified":1511768413902},{"_id":"public/css/highlight.css","hash":"03d1f0a648e9bdf7b1f57d217313cbac5d0c7eb1","modified":1511768413902},{"_id":"public/css/rocket.css","hash":"9456fd92f729e09d6de8cda70f95d78e0d789c70","modified":1511768413902},{"_id":"public/css/signature.css","hash":"820fa4743cea34a61808cd8f7de528605c32d7e3","modified":1511768413902},{"_id":"public/css/syntax.css","hash":"ddb061122db565f14b3018d07e31d12be0b5914b","modified":1511768413902},{"_id":"public/css/toc.css","hash":"2062bf4e5b219654e0d4bf470f5eef1be213da95","modified":1511768413902},{"_id":"public/css/widget.css","hash":"da95ad3f1938f24d20f1fa77d7a38f0c392b5ec8","modified":1511768413902},{"_id":"public/js/hux-blog.js","hash":"4b4d3c557405d04c3087d36c13e2834fe05c0f73","modified":1511768413902},{"_id":"public/js/jquery.nav.js","hash":"ef2160a456176a4d09cc0b95d52b27dfbbadf2d8","modified":1511768413902},{"_id":"public/js/hux-blog.min.js","hash":"1563e7f70550ac6b30803d6f449719b853200e35","modified":1511768413902},{"_id":"public/js/toc.js","hash":"41e52551731854224c249d53010c1bae5aa92ffa","modified":1511768413902},{"_id":"public/js/jquery.tagcloud.js","hash":"4e5fd0b07f3bd935f2e603710447e039e3677211","modified":1511768413902},{"_id":"public/js/totop.js","hash":"c05360f6fc699ac12e794b1764b4a952713a3017","modified":1511768413902},{"_id":"public/css/beantech.css","hash":"4c361354fd8e9851923fb21a620bc079380ebcd8","modified":1511768413902},{"_id":"public/css/beantech.min.css","hash":"06a73fac70dc52adb9f7d1d0e9bbcad7da132541","modified":1511768413902},{"_id":"public/css/hux-blog.min.css","hash":"8ed9da2013cddd8bf119ff740342a5c2c8b1f3e7","modified":1511768413902},{"_id":"public/css/hux-blog.css","hash":"2e8520c16e39dce6cc5c99ab3e267b2e2d6bc0c5","modified":1511768413903},{"_id":"public/js/bootstrap.min.js","hash":"b3f2ef9f985e7906c9360756b73cd64bf7733647","modified":1511768413903},{"_id":"public/css/bootstrap.min.css","hash":"973e37a8502921d56bc02bb55321f45b072b6f71","modified":1511768413903},{"_id":"public/js/bootstrap.js","hash":"f8752e9ae24daec0a0baffd7819122f8c6fd9103","modified":1511768413903},{"_id":"public/js/jquery.min.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1511768413903},{"_id":"public/css/bootstrap.css","hash":"41c54bf695145ae0b4d9020a1da308ceb05dcaf3","modified":1511768413903},{"_id":"public/js/jquery.js","hash":"1852661bd11a09ca9b9cb63d1aa6ff390fffaf4e","modified":1511768413903},{"_id":"public/img/17.jpg","hash":"a7882f3125e5655a89e3cc39976621a73e7e7dba","modified":1511768413903},{"_id":"public/img/404-bg.jpg","hash":"68f7d525269a94287e0ad18713ae232fb59dcf71","modified":1511768413903},{"_id":"public/img/signature/BeanTechSign-white.png","hash":"34289ed41cf9ddac2d56be46fbb1515b7d5913cd","modified":1511768413903},{"_id":"public/img/02.jpg","hash":"dfe50b46afb7ed966e40119a301a66ee88f31df4","modified":1511768413906},{"_id":"public/img/ironman-draw.png","hash":"7d6a06b4b544ab146c3b3e8474edc33f14ac6e4d","modified":1511768413906},{"_id":"public/img/signature/BeanTechSign-black.png","hash":"94b7102e819fd6ee082d3fb0166f4de7458c22ff","modified":1511768413906},{"_id":"public/img/13.jpg","hash":"37b130047ad19e31a44c88a929b8c738b9010342","modified":1511768413913},{"_id":"public/img/16.jpg","hash":"fea570eb9e4a6e12090201ce3a9c1e11410b86a5","modified":1511768413913},{"_id":"public/img/18.jpg","hash":"f84495b6dcadc61ec84c2e1cc0dc72485729b459","modified":1511768413914},{"_id":"public/img/contact-bg.jpg","hash":"6af63305c923899017e727b5ca968a2703bc08cf","modified":1511768413914},{"_id":"public/img/03.jpg","hash":"0c5a71083cecfca277257b912f9243e39ce85094","modified":1511768413919},{"_id":"public/img/header_img/tag-bg.png","hash":"94c3942bdcb1a6c4ac64bd6365e2066302380847","modified":1511768413919},{"_id":"public/img/04.jpg","hash":"695b52e10134f4eb5d4a9267aedc6cf9922fe5c6","modified":1511768413927},{"_id":"public/img/05.jpg","hash":"1265dc75b3f60a1dd666c687994189aed01c8de7","modified":1511768413927},{"_id":"public/img/06.jpg","hash":"149d868cac9081b99725117b5cb4ff67e9e8eff3","modified":1511768413933},{"_id":"public/img/07.jpg","hash":"9adcca2d2867c8248b684621f8619a5c42d6cfb1","modified":1511768413947},{"_id":"public/img/header_img/archive-bg.png","hash":"f4345d8edd7167fe1500b122aec4922893630fd3","modified":1511768413948},{"_id":"public/img/09.jpg","hash":"1f218120eca78cbecf2bb25eab2cec0eb3d7471a","modified":1511768413952},{"_id":"public/img/08.jpg","hash":"81e19c82746fcf2248e5d46cdf40849a5b59fe84","modified":1511768413952},{"_id":"public/img/header_img/home-bg-o.png","hash":"e9ba54c513f0a37bbccddfdf7841570f86cdc6a5","modified":1511768413953},{"_id":"public/img/header_img/home-bg-2-dark.png","hash":"74d23c05e93a2e4bb469737f69d1714d1074bcf9","modified":1511768413957},{"_id":"public/img/10.jpg","hash":"2f9c052795706dd236dd7e224d0517425024bc17","modified":1511768413960},{"_id":"public/img/11.jpg","hash":"7c28c0188909f209048bf952ad3812d14d846a65","modified":1511768413966},{"_id":"public/img/14.jpg","hash":"7bdf575736fd75247687f2e4de37c528a2fd7b69","modified":1511768413967},{"_id":"public/img/12.jpg","hash":"a767f6baecc43ba0b21cc76d281dafbfaa156c3d","modified":1511768413967},{"_id":"public/img/15.jpg","hash":"2e22c73b122f4e4a1140ad05035c5d7c6b30abec","modified":1511768413971}],"Category":[],"Data":[],"Page":[{"layout":"about","title":"关于","date":"2016-04-20T20:48:33.000Z","description":"Wish for the Best, Prepare for the Worst","header-img":"img/header_img/Iron-Man-3.jpg","comments":1,"_content":"\n> 光有好奇心而不去實踐，等於自願放棄成功機會\n> 別為自己畫地自限，Just Do It！！\n","source":"about/index.md","raw":"---\nlayout: \"about\"\ntitle: \"关于\"\ndate: 2016-04-21 04:48:33\ndescription: \"Wish for the Best, Prepare for the Worst\"\nheader-img: \"img/header_img/Iron-Man-3.jpg\"\ncomments: true\n---\n\n> 光有好奇心而不去實踐，等於自願放棄成功機會\n> 別為自己畫地自限，Just Do It！！\n","updated":"2017-11-25T07:32:25.353Z","path":"about/index.html","_id":"cjahvvnwu0000pv4ndsgktc8t","content":"<blockquote>\n<p>光有好奇心而不去實踐，等於自願放棄成功機會<br>\n別為自己畫地自限，Just Do It！！</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>光有好奇心而不去實踐，等於自願放棄成功機會<br>\n別為自己畫地自限，Just Do It！！</p>\n</blockquote>\n"},{"layout":"archive","title":"文章","header-img":"img/header_img/archive-bg.png","comments":0,"date":"2017-03-20T12:49:56.000Z","description":"Hey, this is archives","_content":"","source":"archive/index.md","raw":"---\nlayout: \"archive\"\ntitle: \"文章\"\nheader-img: \"img/header_img/archive-bg.png\"\ncomments: false\ndate: 2017-03-20 20:49:56\ndescription: \"Hey, this is archives\"\n---\n","updated":"2017-11-25T07:32:53.809Z","path":"archive/index.html","_id":"cjahvvnwz0002pv4nhh5yqc37","content":"","site":{"data":{}},"excerpt":"","more":""},{"layout":"tags","title":"分类","description":"Hey, this is Tags.","header-img":"img/header_img/tag-bg.png","_content":"","source":"tags/index.md","raw":"---\nlayout: \"tags\"\ntitle: \"分类\"\ndescription: \"Hey, this is Tags.\"\nheader-img: \"img/header_img/tag-bg.png\"\n---\n","date":"2017-11-25T07:33:25.005Z","updated":"2017-11-25T07:33:25.003Z","path":"tags/index.html","comments":1,"_id":"cjahvvnx20005pv4nj0xbbbvd","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"Chapter-02-control-structures-and-functions","catalog":true,"date":"2015-06-22T09:21:29.000Z","header-img":"/img/04.jpg","_content":"\n## Chapter-02-control-structures-and-functions\n\n函数 控制结构 异常\n\n---\n\n### 条件表达式\n\nscala里的if/else是有值的，返回的值就是那个表达式的值。如果if语句的条件为false没有进入语句块，那么该if表达式的值为Unit(含义接近void，和void的区别是：void是空的钱包，Unit是钱包里一张写着“没钱”的纸币)，写做()。\n\nscala中没有switch语句，代之以强大的模式匹配来解决问题。\n\n### 块表达式和赋值\n\n在scala中一切都是表达式，{}语句块是一组表达式的集合，这个集合的值取决于最后一个表达式的值。\n在scala中，赋值表达式是值为Unit的。比如下面的语句块的值即为Unit因为：\n\n```scala\n{ r = r * n; n -=1 }\n```\n下面语句的想给x赋值和java中会完全不同，y = 1的值为Unit，x最终就会被赋值成Unit。所以不要这么用。\n\n```scala\nx = y = 1 \n```\n\n### 输入和输出\n\n如果要打印一个值，可以用print和println函数。像这样：\n\n```scala\nprint(\"Answer: \")\nprintln(42)\n```\n另外还有一个C风格的printf函数：\n\n```scala\nprintf(\"Hello, %s! you are %d years old.\\n\",\" Fred\", 42)\n```\nreadLine函数可以从控制台读取一行输入。读取Int可以用readInt其他类型以此类推。\n\n```scala\nval name = readLine(\"请输入您的名字并回车：\")\nprintln(\"您的名称是：\"  + name)\n```\n\n### 循环\nscala中的while/do语句和java、C++使用完全相同。\nscala中的for循环比java更加直观方便。\n\n```scala\nfor (i <- (1 to 10)) println(i)\nfor (i <- 1 to 10) println(i) //可以省略1 to 10外面的括号\n```\n    for循环的语法结构为： for (i <- 表达式)\n    表达式一般可以为一个集合\n\n在使用for循环的时候，也可以使用从0到n-1的区间，这时可以用until而不是to。如\n\n\n```scala\nfor (i <- 1 until 10) println(i) //会自1输出至9\n```\n\n跳跃式循环\n\n```scala\nfor(i <- 0 until (10,2)) println(i)\n//输出\n0\n2\n4\n6\n8\n```\n \nscala并没有提供break，continue。如果想使用类似功能可以：\n\n    1. 使用Boolean和return\n    2. 使用Breaks对象中的break方法实现，如下：\n\n```scala\nimport util.control.Breaks._\nfor (...) {\n    if(...) break //退出代码块，它是通过try/catch实现的，效率不高\n}\n```\n\n### 高级for循环和for推导式\n\n在java中实现双层嵌套for循环代码的可读性不如scala。在scala里，你只需要这样：\n\n```scala\nfor (i <- i to 3; j <- 5 to 6) print((10 * i + j) + \" \")\n//将输出 15 16 25 26 35 36\n```\n从左到右就是双层for的从外到内。另外还可以在上面的基础上为每层循环加if条件判断：\n\n```scala\nfor (i <- 1 to 3 if i < 3; j <- 5 to 6 if j > 5) print((10 * i + j) + \" \")\n//输出 16 26\n```\n可以定义不限个数的临时变量：\n\n```scala\nfor (i <- 1 to 3; from = 6;j <- from to 6) print((10 * i + j) + \" \")\n//将输出 16 26 36\n```\n可以将for循环过程中的任意值收集到一个集合中，这类循环叫for推导式。\n\n```scala\nfor (i <- 1 to 10) yield i % 3\n//将返回 Vector(1, 2, 0, 1, 2, 0, 1, 2, 0, 1)\nfor (c <- \"Hello\") yield (c + 1).toChar\n// 输出 Ifmmp\n```\n\n### 函数默认参数\n\n\n```scala\ndef decorate(str:String, left:String = \"[\", right:String = \"]\") = left + str + right\n//left和rigth带有默认值，如果不传会按顺序自动传递。如果手工传递了值，则依然按顺序对号入座。\ndecorate(\"Hello\",\"<\")\n//返回 <Hello]\n\n//也可以像下面这样指定参数名，如此一来便不用按顺序传递了\ndecorate(\"Hello\",right = \">\")\n//返回 [Hello>\n```\n\n### 可变参数列表\n\n\n```scala\ndef sum(args:Int*) = {\n    //args实际上是一个Seq类型的参数\n    for(arg <- args) println(arg)\n}\nsum(1,2,3,4)\n//输出\n1\n2\n3\n4\n```\n既然可变参数列表可以传多个Int，那么可以这样吗？\n\n```scala\nsum(1 to 5) //这样写会报错，原因是1 to 5只是一个Range对象，并不是多个Int的参数，不过可以通过以下方式来把它变成一个参数序列。\nsum(1 to 5:_*) //这转成了一组参数序列\n```\n当调用可变参数列表的函数且参数类型为Object的java方法，要手工对基本类型进行转换。\n\n\n```scala\nval str = MessageFormat.format(\"The answer to {0} is [1]\", \"everything\", 42.asInstanceOf[AnyRef])\n```\n\n    42.asInstanceOf[AnyRef])\n\n### 过程\n如果函数体为花括号，但是没有“=”的函数，返回类型为Unit。也叫过程(procedure)\n\n```scala\ndef box(s: String) {//没有=号\n...\n}\n\n//以下三种情况效果相同\ndef box(s:String){}\n//box: (s: String)Unit\n\ndef box2(s:String)={}\n//box2: (s: String)Unit\n\ndef box3(s:String):Unit={}\n//box3: (s: String)Unit\n```\n\n如果使用过程，有可能产生java程序员意想不到的后果，因为它的值为Unit。实际使用时和期望有可能不一致。导致：Unit在那里不能接受 的异常。\n\n### lazy\n以下代码它会不会立刻初始化，只有当words被使用的时候才会去打开文件。\n\n```scala\nlazy val words = scala.io.Source.fromFile(\"/usr/share/dict/words\").mkString\n//第一次被使用时执行\nval words = scala.io.Source.fromFile(\"/usr/share/dict/words\").mkString\n//一被定义就执行\ndef words = scala.io.Source.fromFile(\"/usr/share/dict/words\").mkString\n//每次调用执行都会执行\n```\n### 异常\nscala没有非运行时异常。IOException不需要声明和强制catch。throw一个异常的值为Nothing。\n\n```scala\nthrow new IllegalArgumentException(\"this e exception\")//它的值为Nothing\n```\nscala中也同样使用try/catch来捕获异常，语法形式是scala中的模式匹配方式。\n\n```scala\ntry {\n    ...\n} catch {\n    case _: SomeException... //不需要使用异常变量，直接用“_”表示即可\n} finally {\n    in.close() // 和java/c++中的含义相同，不管怎样，in都将被close\n}\n```\n\n---\n\n## 习题\n* 一个数字如果为正数，则它的signum为1;如果是负数,则signum为-1;如果为0,则signum为0.编写一个函数来计算这个值。\n\n\n```scala\ndef signum(num: Int):Int = {\n   if(num > 0) 1 else if(num == 0) 0 else -1\n}\n```\n\n*  一个{}的值是什么？类型是什么？\n\n```scala\nval t = {}\n// t: Unit = ()\n```\n   可以看出，它的值是()类型是Unit     \n    \n*  指出在Scala中何种情况下赋值语句x=y=1是合法的。(提示：给x找个合适的类型定义)\n    \n    所以只要x为Unit类型就可以了。\n\n*  针对下列Java循环编写一个Scala版本:for(int i=10;i>=0;i--)System.out.println(i);\n\n```scala\nfor(i <- 0 to 10 reverse) println(i)\n```\n\n*  编写一个过程countdown(n:Int)，打印从n到0的数字。\n\n```scala\ndef countdown(n:Int){\n    0 to n reverse foreach print\n}\n```\n\n*  编写一个for循环,计算字符串中所有字母的Unicode代码的乘积。举例来说，\"Hello\"中所有字符串的乘积为9415087488L。\n\n```scala\nvar t:Long = 1\nfor(i <- \"Hello\") t = t * i.toLong\nt\n//res57: Long = 9415087488\n```\n\n*  同样是解决前一个练习的问题，但这次不使用循环。（提示：在Scaladoc中查看StringOps）\n\n```scala\n\"Hello\".foldLeft(1L)((a, b) => a * b)\n```\n\n*  编写一个函数product(s:String)，计算前面练习中提到的乘积。\n\n```scala\ndef product(s:String):BigInt = {\n    s.foldLeft(1L)((a, b) => a * b)\n}\n```\n\n*  把前一个练习中的函数改成递归函数。\n\n```scala\ndef productRec(s: String):Long = {\n\tif(s.length == 0) 1\n\telse s(0) * productRec(s drop 1)\n}                                         \n```\n\n*  编写函数计算x^n^,其中n是整数，使用如下的递归定义：\nx^n^=y^2^,如果n是正偶数的话，这里的y=x^(n/2)^\nx^n^ = x*x^(n-1)^,如果n是正奇数的话\nx^0^ = 1\nx^n^ = 1/x^(-n)^,如果n是负数的话\n\n```scala\ndef xpown(x: BigInt, n: Int): BigInt = {\n\tif(n > 0 && n % 2 == 0) xpown(x, n / 2) * xpown(x, n / 2)\n\telse if(n > 0) x * xpown(x, n - 1)\n\telse if(n == 0) 1\n\telse 1 / xpown(x, -n)\n} \n```\n\n\n","source":"_posts/Chapter-02-control-structures-and-functions.md","raw":"---\ntitle: 'Chapter-02-control-structures-and-functions'\ncatalog: true\ndate: 2015-06-22 17:21:29\nheader-img: \"/img/04.jpg\"\ntags: \"scala\"\n---\n\n## Chapter-02-control-structures-and-functions\n\n函数 控制结构 异常\n\n---\n\n### 条件表达式\n\nscala里的if/else是有值的，返回的值就是那个表达式的值。如果if语句的条件为false没有进入语句块，那么该if表达式的值为Unit(含义接近void，和void的区别是：void是空的钱包，Unit是钱包里一张写着“没钱”的纸币)，写做()。\n\nscala中没有switch语句，代之以强大的模式匹配来解决问题。\n\n### 块表达式和赋值\n\n在scala中一切都是表达式，{}语句块是一组表达式的集合，这个集合的值取决于最后一个表达式的值。\n在scala中，赋值表达式是值为Unit的。比如下面的语句块的值即为Unit因为：\n\n```scala\n{ r = r * n; n -=1 }\n```\n下面语句的想给x赋值和java中会完全不同，y = 1的值为Unit，x最终就会被赋值成Unit。所以不要这么用。\n\n```scala\nx = y = 1 \n```\n\n### 输入和输出\n\n如果要打印一个值，可以用print和println函数。像这样：\n\n```scala\nprint(\"Answer: \")\nprintln(42)\n```\n另外还有一个C风格的printf函数：\n\n```scala\nprintf(\"Hello, %s! you are %d years old.\\n\",\" Fred\", 42)\n```\nreadLine函数可以从控制台读取一行输入。读取Int可以用readInt其他类型以此类推。\n\n```scala\nval name = readLine(\"请输入您的名字并回车：\")\nprintln(\"您的名称是：\"  + name)\n```\n\n### 循环\nscala中的while/do语句和java、C++使用完全相同。\nscala中的for循环比java更加直观方便。\n\n```scala\nfor (i <- (1 to 10)) println(i)\nfor (i <- 1 to 10) println(i) //可以省略1 to 10外面的括号\n```\n    for循环的语法结构为： for (i <- 表达式)\n    表达式一般可以为一个集合\n\n在使用for循环的时候，也可以使用从0到n-1的区间，这时可以用until而不是to。如\n\n\n```scala\nfor (i <- 1 until 10) println(i) //会自1输出至9\n```\n\n跳跃式循环\n\n```scala\nfor(i <- 0 until (10,2)) println(i)\n//输出\n0\n2\n4\n6\n8\n```\n \nscala并没有提供break，continue。如果想使用类似功能可以：\n\n    1. 使用Boolean和return\n    2. 使用Breaks对象中的break方法实现，如下：\n\n```scala\nimport util.control.Breaks._\nfor (...) {\n    if(...) break //退出代码块，它是通过try/catch实现的，效率不高\n}\n```\n\n### 高级for循环和for推导式\n\n在java中实现双层嵌套for循环代码的可读性不如scala。在scala里，你只需要这样：\n\n```scala\nfor (i <- i to 3; j <- 5 to 6) print((10 * i + j) + \" \")\n//将输出 15 16 25 26 35 36\n```\n从左到右就是双层for的从外到内。另外还可以在上面的基础上为每层循环加if条件判断：\n\n```scala\nfor (i <- 1 to 3 if i < 3; j <- 5 to 6 if j > 5) print((10 * i + j) + \" \")\n//输出 16 26\n```\n可以定义不限个数的临时变量：\n\n```scala\nfor (i <- 1 to 3; from = 6;j <- from to 6) print((10 * i + j) + \" \")\n//将输出 16 26 36\n```\n可以将for循环过程中的任意值收集到一个集合中，这类循环叫for推导式。\n\n```scala\nfor (i <- 1 to 10) yield i % 3\n//将返回 Vector(1, 2, 0, 1, 2, 0, 1, 2, 0, 1)\nfor (c <- \"Hello\") yield (c + 1).toChar\n// 输出 Ifmmp\n```\n\n### 函数默认参数\n\n\n```scala\ndef decorate(str:String, left:String = \"[\", right:String = \"]\") = left + str + right\n//left和rigth带有默认值，如果不传会按顺序自动传递。如果手工传递了值，则依然按顺序对号入座。\ndecorate(\"Hello\",\"<\")\n//返回 <Hello]\n\n//也可以像下面这样指定参数名，如此一来便不用按顺序传递了\ndecorate(\"Hello\",right = \">\")\n//返回 [Hello>\n```\n\n### 可变参数列表\n\n\n```scala\ndef sum(args:Int*) = {\n    //args实际上是一个Seq类型的参数\n    for(arg <- args) println(arg)\n}\nsum(1,2,3,4)\n//输出\n1\n2\n3\n4\n```\n既然可变参数列表可以传多个Int，那么可以这样吗？\n\n```scala\nsum(1 to 5) //这样写会报错，原因是1 to 5只是一个Range对象，并不是多个Int的参数，不过可以通过以下方式来把它变成一个参数序列。\nsum(1 to 5:_*) //这转成了一组参数序列\n```\n当调用可变参数列表的函数且参数类型为Object的java方法，要手工对基本类型进行转换。\n\n\n```scala\nval str = MessageFormat.format(\"The answer to {0} is [1]\", \"everything\", 42.asInstanceOf[AnyRef])\n```\n\n    42.asInstanceOf[AnyRef])\n\n### 过程\n如果函数体为花括号，但是没有“=”的函数，返回类型为Unit。也叫过程(procedure)\n\n```scala\ndef box(s: String) {//没有=号\n...\n}\n\n//以下三种情况效果相同\ndef box(s:String){}\n//box: (s: String)Unit\n\ndef box2(s:String)={}\n//box2: (s: String)Unit\n\ndef box3(s:String):Unit={}\n//box3: (s: String)Unit\n```\n\n如果使用过程，有可能产生java程序员意想不到的后果，因为它的值为Unit。实际使用时和期望有可能不一致。导致：Unit在那里不能接受 的异常。\n\n### lazy\n以下代码它会不会立刻初始化，只有当words被使用的时候才会去打开文件。\n\n```scala\nlazy val words = scala.io.Source.fromFile(\"/usr/share/dict/words\").mkString\n//第一次被使用时执行\nval words = scala.io.Source.fromFile(\"/usr/share/dict/words\").mkString\n//一被定义就执行\ndef words = scala.io.Source.fromFile(\"/usr/share/dict/words\").mkString\n//每次调用执行都会执行\n```\n### 异常\nscala没有非运行时异常。IOException不需要声明和强制catch。throw一个异常的值为Nothing。\n\n```scala\nthrow new IllegalArgumentException(\"this e exception\")//它的值为Nothing\n```\nscala中也同样使用try/catch来捕获异常，语法形式是scala中的模式匹配方式。\n\n```scala\ntry {\n    ...\n} catch {\n    case _: SomeException... //不需要使用异常变量，直接用“_”表示即可\n} finally {\n    in.close() // 和java/c++中的含义相同，不管怎样，in都将被close\n}\n```\n\n---\n\n## 习题\n* 一个数字如果为正数，则它的signum为1;如果是负数,则signum为-1;如果为0,则signum为0.编写一个函数来计算这个值。\n\n\n```scala\ndef signum(num: Int):Int = {\n   if(num > 0) 1 else if(num == 0) 0 else -1\n}\n```\n\n*  一个{}的值是什么？类型是什么？\n\n```scala\nval t = {}\n// t: Unit = ()\n```\n   可以看出，它的值是()类型是Unit     \n    \n*  指出在Scala中何种情况下赋值语句x=y=1是合法的。(提示：给x找个合适的类型定义)\n    \n    所以只要x为Unit类型就可以了。\n\n*  针对下列Java循环编写一个Scala版本:for(int i=10;i>=0;i--)System.out.println(i);\n\n```scala\nfor(i <- 0 to 10 reverse) println(i)\n```\n\n*  编写一个过程countdown(n:Int)，打印从n到0的数字。\n\n```scala\ndef countdown(n:Int){\n    0 to n reverse foreach print\n}\n```\n\n*  编写一个for循环,计算字符串中所有字母的Unicode代码的乘积。举例来说，\"Hello\"中所有字符串的乘积为9415087488L。\n\n```scala\nvar t:Long = 1\nfor(i <- \"Hello\") t = t * i.toLong\nt\n//res57: Long = 9415087488\n```\n\n*  同样是解决前一个练习的问题，但这次不使用循环。（提示：在Scaladoc中查看StringOps）\n\n```scala\n\"Hello\".foldLeft(1L)((a, b) => a * b)\n```\n\n*  编写一个函数product(s:String)，计算前面练习中提到的乘积。\n\n```scala\ndef product(s:String):BigInt = {\n    s.foldLeft(1L)((a, b) => a * b)\n}\n```\n\n*  把前一个练习中的函数改成递归函数。\n\n```scala\ndef productRec(s: String):Long = {\n\tif(s.length == 0) 1\n\telse s(0) * productRec(s drop 1)\n}                                         \n```\n\n*  编写函数计算x^n^,其中n是整数，使用如下的递归定义：\nx^n^=y^2^,如果n是正偶数的话，这里的y=x^(n/2)^\nx^n^ = x*x^(n-1)^,如果n是正奇数的话\nx^0^ = 1\nx^n^ = 1/x^(-n)^,如果n是负数的话\n\n```scala\ndef xpown(x: BigInt, n: Int): BigInt = {\n\tif(n > 0 && n % 2 == 0) xpown(x, n / 2) * xpown(x, n / 2)\n\telse if(n > 0) x * xpown(x, n - 1)\n\telse if(n == 0) 1\n\telse 1 / xpown(x, -n)\n} \n```\n\n\n","slug":"Chapter-02-control-structures-and-functions","published":1,"updated":"2017-11-25T06:28:50.495Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjahvvnwv0001pv4nzwazr5hd","content":"<h2><span id=\"chapter-02-control-structures-and-functions\"> Chapter-02-control-structures-and-functions</span></h2>\n<p>函数 控制结构 异常</p>\n<hr>\n<h3><span id=\"条件表达式\"> 条件表达式</span></h3>\n<p>scala里的if/else是有值的，返回的值就是那个表达式的值。如果if语句的条件为false没有进入语句块，那么该if表达式的值为Unit(含义接近void，和void的区别是：void是空的钱包，Unit是钱包里一张写着“没钱”的纸币)，写做()。</p>\n<p>scala中没有switch语句，代之以强大的模式匹配来解决问题。</p>\n<h3><span id=\"块表达式和赋值\"> 块表达式和赋值</span></h3>\n<p>在scala中一切都是表达式，{}语句块是一组表达式的集合，这个集合的值取决于最后一个表达式的值。<br>\n在scala中，赋值表达式是值为Unit的。比如下面的语句块的值即为Unit因为：</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123; r = r * n; n -=<span class=\"number\">1</span> &#125;</span><br></pre></td></tr></table></figure>\n<p>下面语句的想给x赋值和java中会完全不同，y = 1的值为Unit，x最终就会被赋值成Unit。所以不要这么用。</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">x = y = <span class=\"number\">1</span></span><br></pre></td></tr></table></figure>\n<h3><span id=\"输入和输出\"> 输入和输出</span></h3>\n<p>如果要打印一个值，可以用print和println函数。像这样：</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">print(<span class=\"string\">\"Answer: \"</span>)</span><br><span class=\"line\">println(<span class=\"number\">42</span>)</span><br></pre></td></tr></table></figure>\n<p>另外还有一个C风格的printf函数：</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">printf(<span class=\"string\">\"Hello, %s! you are %d years old.\\n\"</span>,<span class=\"string\">\" Fred\"</span>, <span class=\"number\">42</span>)</span><br></pre></td></tr></table></figure>\n<p>readLine函数可以从控制台读取一行输入。读取Int可以用readInt其他类型以此类推。</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> name = readLine(<span class=\"string\">\"请输入您的名字并回车：\"</span>)</span><br><span class=\"line\">println(<span class=\"string\">\"您的名称是：\"</span>  + name)</span><br></pre></td></tr></table></figure>\n<h3><span id=\"循环\"> 循环</span></h3>\n<p>scala中的while/do语句和java、C++使用完全相同。<br>\nscala中的for循环比java更加直观方便。</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (i &lt;- (<span class=\"number\">1</span> to <span class=\"number\">10</span>)) println(i)</span><br><span class=\"line\"><span class=\"keyword\">for</span> (i &lt;- <span class=\"number\">1</span> to <span class=\"number\">10</span>) println(i) <span class=\"comment\">//可以省略1 to 10外面的括号</span></span><br></pre></td></tr></table></figure>\n<pre><code>for循环的语法结构为： for (i &lt;- 表达式)\n表达式一般可以为一个集合\n</code></pre>\n<p>在使用for循环的时候，也可以使用从0到n-1的区间，这时可以用until而不是to。如</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (i &lt;- <span class=\"number\">1</span> until <span class=\"number\">10</span>) println(i) <span class=\"comment\">//会自1输出至9</span></span><br></pre></td></tr></table></figure>\n<p>跳跃式循环</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span>(i &lt;- <span class=\"number\">0</span> until (<span class=\"number\">10</span>,<span class=\"number\">2</span>)) println(i)</span><br><span class=\"line\"><span class=\"comment\">//输出</span></span><br><span class=\"line\"><span class=\"number\">0</span></span><br><span class=\"line\"><span class=\"number\">2</span></span><br><span class=\"line\"><span class=\"number\">4</span></span><br><span class=\"line\"><span class=\"number\">6</span></span><br><span class=\"line\"><span class=\"number\">8</span></span><br></pre></td></tr></table></figure>\n<p>scala并没有提供break，continue。如果想使用类似功能可以：</p>\n<pre><code>1. 使用Boolean和return\n2. 使用Breaks对象中的break方法实现，如下：\n</code></pre>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> util.control.<span class=\"type\">Breaks</span>._</span><br><span class=\"line\"><span class=\"keyword\">for</span> (...) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(...) <span class=\"keyword\">break</span> <span class=\"comment\">//退出代码块，它是通过try/catch实现的，效率不高</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3><span id=\"高级for循环和for推导式\"> 高级for循环和for推导式</span></h3>\n<p>在java中实现双层嵌套for循环代码的可读性不如scala。在scala里，你只需要这样：</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (i &lt;- i to <span class=\"number\">3</span>; j &lt;- <span class=\"number\">5</span> to <span class=\"number\">6</span>) print((<span class=\"number\">10</span> * i + j) + <span class=\"string\">\" \"</span>)</span><br><span class=\"line\"><span class=\"comment\">//将输出 15 16 25 26 35 36</span></span><br></pre></td></tr></table></figure>\n<p>从左到右就是双层for的从外到内。另外还可以在上面的基础上为每层循环加if条件判断：</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (i &lt;- <span class=\"number\">1</span> to <span class=\"number\">3</span> <span class=\"keyword\">if</span> i &lt; <span class=\"number\">3</span>; j &lt;- <span class=\"number\">5</span> to <span class=\"number\">6</span> <span class=\"keyword\">if</span> j &gt; <span class=\"number\">5</span>) print((<span class=\"number\">10</span> * i + j) + <span class=\"string\">\" \"</span>)</span><br><span class=\"line\"><span class=\"comment\">//输出 16 26</span></span><br></pre></td></tr></table></figure>\n<p>可以定义不限个数的临时变量：</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (i &lt;- <span class=\"number\">1</span> to <span class=\"number\">3</span>; from = <span class=\"number\">6</span>;j &lt;- from to <span class=\"number\">6</span>) print((<span class=\"number\">10</span> * i + j) + <span class=\"string\">\" \"</span>)</span><br><span class=\"line\"><span class=\"comment\">//将输出 16 26 36</span></span><br></pre></td></tr></table></figure>\n<p>可以将for循环过程中的任意值收集到一个集合中，这类循环叫for推导式。</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (i &lt;- <span class=\"number\">1</span> to <span class=\"number\">10</span>) <span class=\"keyword\">yield</span> i % <span class=\"number\">3</span></span><br><span class=\"line\"><span class=\"comment\">//将返回 Vector(1, 2, 0, 1, 2, 0, 1, 2, 0, 1)</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> (c &lt;- <span class=\"string\">\"Hello\"</span>) <span class=\"keyword\">yield</span> (c + <span class=\"number\">1</span>).toChar</span><br><span class=\"line\"><span class=\"comment\">// 输出 Ifmmp</span></span><br></pre></td></tr></table></figure>\n<h3><span id=\"函数默认参数\"> 函数默认参数</span></h3>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">decorate</span></span>(str:<span class=\"type\">String</span>, left:<span class=\"type\">String</span> = <span class=\"string\">\"[\"</span>, right:<span class=\"type\">String</span> = <span class=\"string\">\"]\"</span>) = left + str + right</span><br><span class=\"line\"><span class=\"comment\">//left和rigth带有默认值，如果不传会按顺序自动传递。如果手工传递了值，则依然按顺序对号入座。</span></span><br><span class=\"line\">decorate(<span class=\"string\">\"Hello\"</span>,<span class=\"string\">\"&lt;\"</span>)</span><br><span class=\"line\"><span class=\"comment\">//返回 &lt;Hello]</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//也可以像下面这样指定参数名，如此一来便不用按顺序传递了</span></span><br><span class=\"line\">decorate(<span class=\"string\">\"Hello\"</span>,right = <span class=\"string\">\"&gt;\"</span>)</span><br><span class=\"line\"><span class=\"comment\">//返回 [Hello&gt;</span></span><br></pre></td></tr></table></figure>\n<h3><span id=\"可变参数列表\"> 可变参数列表</span></h3>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">sum</span></span>(args:<span class=\"type\">Int</span>*) = &#123;</span><br><span class=\"line\">    <span class=\"comment\">//args实际上是一个Seq类型的参数</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(arg &lt;- args) println(arg)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">sum(<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>)</span><br><span class=\"line\"><span class=\"comment\">//输出</span></span><br><span class=\"line\"><span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"number\">2</span></span><br><span class=\"line\"><span class=\"number\">3</span></span><br><span class=\"line\"><span class=\"number\">4</span></span><br></pre></td></tr></table></figure>\n<p>既然可变参数列表可以传多个Int，那么可以这样吗？</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sum(<span class=\"number\">1</span> to <span class=\"number\">5</span>) <span class=\"comment\">//这样写会报错，原因是1 to 5只是一个Range对象，并不是多个Int的参数，不过可以通过以下方式来把它变成一个参数序列。</span></span><br><span class=\"line\">sum(<span class=\"number\">1</span> to <span class=\"number\">5</span>:_*) <span class=\"comment\">//这转成了一组参数序列</span></span><br></pre></td></tr></table></figure>\n<p>当调用可变参数列表的函数且参数类型为Object的java方法，要手工对基本类型进行转换。</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> str = <span class=\"type\">MessageFormat</span>.format(<span class=\"string\">\"The answer to &#123;0&#125; is [1]\"</span>, <span class=\"string\">\"everything\"</span>, <span class=\"number\">42.</span>asInstanceOf[<span class=\"type\">AnyRef</span>])</span><br></pre></td></tr></table></figure>\n<pre><code>42.asInstanceOf[AnyRef])\n</code></pre>\n<h3><span id=\"过程\"> 过程</span></h3>\n<p>如果函数体为花括号，但是没有“=”的函数，返回类型为Unit。也叫过程(procedure)</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">box</span></span>(s: <span class=\"type\">String</span>) &#123;<span class=\"comment\">//没有=号</span></span><br><span class=\"line\">...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//以下三种情况效果相同</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">box</span></span>(s:<span class=\"type\">String</span>)&#123;&#125;</span><br><span class=\"line\"><span class=\"comment\">//box: (s: String)Unit</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">box2</span></span>(s:<span class=\"type\">String</span>)=&#123;&#125;</span><br><span class=\"line\"><span class=\"comment\">//box2: (s: String)Unit</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">box3</span></span>(s:<span class=\"type\">String</span>):<span class=\"type\">Unit</span>=&#123;&#125;</span><br><span class=\"line\"><span class=\"comment\">//box3: (s: String)Unit</span></span><br></pre></td></tr></table></figure>\n<p>如果使用过程，有可能产生java程序员意想不到的后果，因为它的值为Unit。实际使用时和期望有可能不一致。导致：Unit在那里不能接受 的异常。</p>\n<h3><span id=\"lazy\"> lazy</span></h3>\n<p>以下代码它会不会立刻初始化，只有当words被使用的时候才会去打开文件。</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">lazy</span> <span class=\"keyword\">val</span> words = scala.io.<span class=\"type\">Source</span>.fromFile(<span class=\"string\">\"/usr/share/dict/words\"</span>).mkString</span><br><span class=\"line\"><span class=\"comment\">//第一次被使用时执行</span></span><br><span class=\"line\"><span class=\"keyword\">val</span> words = scala.io.<span class=\"type\">Source</span>.fromFile(<span class=\"string\">\"/usr/share/dict/words\"</span>).mkString</span><br><span class=\"line\"><span class=\"comment\">//一被定义就执行</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">words</span> </span>= scala.io.<span class=\"type\">Source</span>.fromFile(<span class=\"string\">\"/usr/share/dict/words\"</span>).mkString</span><br><span class=\"line\"><span class=\"comment\">//每次调用执行都会执行</span></span><br></pre></td></tr></table></figure>\n<h3><span id=\"异常\"> 异常</span></h3>\n<p>scala没有非运行时异常。IOException不需要声明和强制catch。throw一个异常的值为Nothing。</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"type\">IllegalArgumentException</span>(<span class=\"string\">\"this e exception\"</span>)<span class=\"comment\">//它的值为Nothing</span></span><br></pre></td></tr></table></figure>\n<p>scala中也同样使用try/catch来捕获异常，语法形式是scala中的模式匹配方式。</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> _: <span class=\"type\">SomeException</span>... <span class=\"comment\">//不需要使用异常变量，直接用“_”表示即可</span></span><br><span class=\"line\">&#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">    in.close() <span class=\"comment\">// 和java/c++中的含义相同，不管怎样，in都将被close</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<hr>\n<h2><span id=\"习题\"> 习题</span></h2>\n<ul>\n<li>一个数字如果为正数，则它的signum为1;如果是负数,则signum为-1;如果为0,则signum为0.编写一个函数来计算这个值。</li>\n</ul>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">signum</span></span>(num: <span class=\"type\">Int</span>):<span class=\"type\">Int</span> = &#123;</span><br><span class=\"line\">   <span class=\"keyword\">if</span>(num &gt; <span class=\"number\">0</span>) <span class=\"number\">1</span> <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(num == <span class=\"number\">0</span>) <span class=\"number\">0</span> <span class=\"keyword\">else</span> <span class=\"number\">-1</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>一个{}的值是什么？类型是什么？</li>\n</ul>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> t = &#123;&#125;</span><br><span class=\"line\"><span class=\"comment\">// t: Unit = ()</span></span><br></pre></td></tr></table></figure>\n<p>可以看出，它的值是()类型是Unit</p>\n<ul>\n<li>\n<p>指出在Scala中何种情况下赋值语句x=y=1是合法的。(提示：给x找个合适的类型定义)</p>\n<p>所以只要x为Unit类型就可以了。</p>\n</li>\n<li>\n<p>针对下列Java循环编写一个Scala版本:for(int i=10;i&gt;=0;i–)System.out.println(i);</p>\n</li>\n</ul>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span>(i &lt;- <span class=\"number\">0</span> to <span class=\"number\">10</span> reverse) println(i)</span><br></pre></td></tr></table></figure>\n<ul>\n<li>编写一个过程countdown(n:Int)，打印从n到0的数字。</li>\n</ul>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">countdown</span></span>(n:<span class=\"type\">Int</span>)&#123;</span><br><span class=\"line\">    <span class=\"number\">0</span> to n reverse foreach print</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>编写一个for循环,计算字符串中所有字母的Unicode代码的乘积。举例来说，&quot;Hello&quot;中所有字符串的乘积为9415087488L。</li>\n</ul>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> t:<span class=\"type\">Long</span> = <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"keyword\">for</span>(i &lt;- <span class=\"string\">\"Hello\"</span>) t = t * i.toLong</span><br><span class=\"line\">t</span><br><span class=\"line\"><span class=\"comment\">//res57: Long = 9415087488</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>同样是解决前一个练习的问题，但这次不使用循环。（提示：在Scaladoc中查看StringOps）</li>\n</ul>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">\"Hello\"</span>.foldLeft(<span class=\"number\">1</span>L)((a, b) =&gt; a * b)</span><br></pre></td></tr></table></figure>\n<ul>\n<li>编写一个函数product(s:String)，计算前面练习中提到的乘积。</li>\n</ul>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">product</span></span>(s:<span class=\"type\">String</span>):<span class=\"type\">BigInt</span> = &#123;</span><br><span class=\"line\">    s.foldLeft(<span class=\"number\">1</span>L)((a, b) =&gt; a * b)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>把前一个练习中的函数改成递归函数。</li>\n</ul>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">productRec</span></span>(s: <span class=\"type\">String</span>):<span class=\"type\">Long</span> = &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(s.length == <span class=\"number\">0</span>) <span class=\"number\">1</span></span><br><span class=\"line\">\t<span class=\"keyword\">else</span> s(<span class=\"number\">0</span>) * productRec(s drop <span class=\"number\">1</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>编写函数计算x<sup>n</sup>,其中n是整数，使用如下的递归定义：<br>\nx<sup>n</sup>=y<sup>2</sup>,如果n是正偶数的话，这里的y=x<sup>(n/2)</sup><br>\nx<sup>n</sup> = x*x<sup>(n-1)</sup>,如果n是正奇数的话<br>\nx<sup>0</sup> = 1<br>\nx<sup>n</sup> = 1/x<sup>(-n)</sup>,如果n是负数的话</li>\n</ul>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">xpown</span></span>(x: <span class=\"type\">BigInt</span>, n: <span class=\"type\">Int</span>): <span class=\"type\">BigInt</span> = &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(n &gt; <span class=\"number\">0</span> &amp;&amp; n % <span class=\"number\">2</span> == <span class=\"number\">0</span>) xpown(x, n / <span class=\"number\">2</span>) * xpown(x, n / <span class=\"number\">2</span>)</span><br><span class=\"line\">\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(n &gt; <span class=\"number\">0</span>) x * xpown(x, n - <span class=\"number\">1</span>)</span><br><span class=\"line\">\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(n == <span class=\"number\">0</span>) <span class=\"number\">1</span></span><br><span class=\"line\">\t<span class=\"keyword\">else</span> <span class=\"number\">1</span> / xpown(x, -n)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"chapter-02-control-structures-and-functions\"><a class=\"markdownIt-Anchor\" href=\"#chapter-02-control-structures-and-functions\"></a> Chapter-02-control-structures-and-functions</h2>\n<p>函数 控制结构 异常</p>\n<hr>\n<h3 id=\"条件表达式\"><a class=\"markdownIt-Anchor\" href=\"#条件表达式\"></a> 条件表达式</h3>\n<p>scala里的if/else是有值的，返回的值就是那个表达式的值。如果if语句的条件为false没有进入语句块，那么该if表达式的值为Unit(含义接近void，和void的区别是：void是空的钱包，Unit是钱包里一张写着“没钱”的纸币)，写做()。</p>\n<p>scala中没有switch语句，代之以强大的模式匹配来解决问题。</p>\n<h3 id=\"块表达式和赋值\"><a class=\"markdownIt-Anchor\" href=\"#块表达式和赋值\"></a> 块表达式和赋值</h3>\n<p>在scala中一切都是表达式，{}语句块是一组表达式的集合，这个集合的值取决于最后一个表达式的值。<br>\n在scala中，赋值表达式是值为Unit的。比如下面的语句块的值即为Unit因为：</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123; r = r * n; n -=<span class=\"number\">1</span> &#125;</span><br></pre></td></tr></table></figure>\n<p>下面语句的想给x赋值和java中会完全不同，y = 1的值为Unit，x最终就会被赋值成Unit。所以不要这么用。</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">x = y = <span class=\"number\">1</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"输入和输出\"><a class=\"markdownIt-Anchor\" href=\"#输入和输出\"></a> 输入和输出</h3>\n<p>如果要打印一个值，可以用print和println函数。像这样：</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">print(<span class=\"string\">\"Answer: \"</span>)</span><br><span class=\"line\">println(<span class=\"number\">42</span>)</span><br></pre></td></tr></table></figure>\n<p>另外还有一个C风格的printf函数：</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">printf(<span class=\"string\">\"Hello, %s! you are %d years old.\\n\"</span>,<span class=\"string\">\" Fred\"</span>, <span class=\"number\">42</span>)</span><br></pre></td></tr></table></figure>\n<p>readLine函数可以从控制台读取一行输入。读取Int可以用readInt其他类型以此类推。</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> name = readLine(<span class=\"string\">\"请输入您的名字并回车：\"</span>)</span><br><span class=\"line\">println(<span class=\"string\">\"您的名称是：\"</span>  + name)</span><br></pre></td></tr></table></figure>\n<h3 id=\"循环\"><a class=\"markdownIt-Anchor\" href=\"#循环\"></a> 循环</h3>\n<p>scala中的while/do语句和java、C++使用完全相同。<br>\nscala中的for循环比java更加直观方便。</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (i &lt;- (<span class=\"number\">1</span> to <span class=\"number\">10</span>)) println(i)</span><br><span class=\"line\"><span class=\"keyword\">for</span> (i &lt;- <span class=\"number\">1</span> to <span class=\"number\">10</span>) println(i) <span class=\"comment\">//可以省略1 to 10外面的括号</span></span><br></pre></td></tr></table></figure>\n<pre><code>for循环的语法结构为： for (i &lt;- 表达式)\n表达式一般可以为一个集合\n</code></pre>\n<p>在使用for循环的时候，也可以使用从0到n-1的区间，这时可以用until而不是to。如</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (i &lt;- <span class=\"number\">1</span> until <span class=\"number\">10</span>) println(i) <span class=\"comment\">//会自1输出至9</span></span><br></pre></td></tr></table></figure>\n<p>跳跃式循环</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span>(i &lt;- <span class=\"number\">0</span> until (<span class=\"number\">10</span>,<span class=\"number\">2</span>)) println(i)</span><br><span class=\"line\"><span class=\"comment\">//输出</span></span><br><span class=\"line\"><span class=\"number\">0</span></span><br><span class=\"line\"><span class=\"number\">2</span></span><br><span class=\"line\"><span class=\"number\">4</span></span><br><span class=\"line\"><span class=\"number\">6</span></span><br><span class=\"line\"><span class=\"number\">8</span></span><br></pre></td></tr></table></figure>\n<p>scala并没有提供break，continue。如果想使用类似功能可以：</p>\n<pre><code>1. 使用Boolean和return\n2. 使用Breaks对象中的break方法实现，如下：\n</code></pre>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> util.control.<span class=\"type\">Breaks</span>._</span><br><span class=\"line\"><span class=\"keyword\">for</span> (...) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(...) <span class=\"keyword\">break</span> <span class=\"comment\">//退出代码块，它是通过try/catch实现的，效率不高</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"高级for循环和for推导式\"><a class=\"markdownIt-Anchor\" href=\"#高级for循环和for推导式\"></a> 高级for循环和for推导式</h3>\n<p>在java中实现双层嵌套for循环代码的可读性不如scala。在scala里，你只需要这样：</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (i &lt;- i to <span class=\"number\">3</span>; j &lt;- <span class=\"number\">5</span> to <span class=\"number\">6</span>) print((<span class=\"number\">10</span> * i + j) + <span class=\"string\">\" \"</span>)</span><br><span class=\"line\"><span class=\"comment\">//将输出 15 16 25 26 35 36</span></span><br></pre></td></tr></table></figure>\n<p>从左到右就是双层for的从外到内。另外还可以在上面的基础上为每层循环加if条件判断：</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (i &lt;- <span class=\"number\">1</span> to <span class=\"number\">3</span> <span class=\"keyword\">if</span> i &lt; <span class=\"number\">3</span>; j &lt;- <span class=\"number\">5</span> to <span class=\"number\">6</span> <span class=\"keyword\">if</span> j &gt; <span class=\"number\">5</span>) print((<span class=\"number\">10</span> * i + j) + <span class=\"string\">\" \"</span>)</span><br><span class=\"line\"><span class=\"comment\">//输出 16 26</span></span><br></pre></td></tr></table></figure>\n<p>可以定义不限个数的临时变量：</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (i &lt;- <span class=\"number\">1</span> to <span class=\"number\">3</span>; from = <span class=\"number\">6</span>;j &lt;- from to <span class=\"number\">6</span>) print((<span class=\"number\">10</span> * i + j) + <span class=\"string\">\" \"</span>)</span><br><span class=\"line\"><span class=\"comment\">//将输出 16 26 36</span></span><br></pre></td></tr></table></figure>\n<p>可以将for循环过程中的任意值收集到一个集合中，这类循环叫for推导式。</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (i &lt;- <span class=\"number\">1</span> to <span class=\"number\">10</span>) <span class=\"keyword\">yield</span> i % <span class=\"number\">3</span></span><br><span class=\"line\"><span class=\"comment\">//将返回 Vector(1, 2, 0, 1, 2, 0, 1, 2, 0, 1)</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> (c &lt;- <span class=\"string\">\"Hello\"</span>) <span class=\"keyword\">yield</span> (c + <span class=\"number\">1</span>).toChar</span><br><span class=\"line\"><span class=\"comment\">// 输出 Ifmmp</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"函数默认参数\"><a class=\"markdownIt-Anchor\" href=\"#函数默认参数\"></a> 函数默认参数</h3>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">decorate</span></span>(str:<span class=\"type\">String</span>, left:<span class=\"type\">String</span> = <span class=\"string\">\"[\"</span>, right:<span class=\"type\">String</span> = <span class=\"string\">\"]\"</span>) = left + str + right</span><br><span class=\"line\"><span class=\"comment\">//left和rigth带有默认值，如果不传会按顺序自动传递。如果手工传递了值，则依然按顺序对号入座。</span></span><br><span class=\"line\">decorate(<span class=\"string\">\"Hello\"</span>,<span class=\"string\">\"&lt;\"</span>)</span><br><span class=\"line\"><span class=\"comment\">//返回 &lt;Hello]</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//也可以像下面这样指定参数名，如此一来便不用按顺序传递了</span></span><br><span class=\"line\">decorate(<span class=\"string\">\"Hello\"</span>,right = <span class=\"string\">\"&gt;\"</span>)</span><br><span class=\"line\"><span class=\"comment\">//返回 [Hello&gt;</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"可变参数列表\"><a class=\"markdownIt-Anchor\" href=\"#可变参数列表\"></a> 可变参数列表</h3>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">sum</span></span>(args:<span class=\"type\">Int</span>*) = &#123;</span><br><span class=\"line\">    <span class=\"comment\">//args实际上是一个Seq类型的参数</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(arg &lt;- args) println(arg)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">sum(<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>)</span><br><span class=\"line\"><span class=\"comment\">//输出</span></span><br><span class=\"line\"><span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"number\">2</span></span><br><span class=\"line\"><span class=\"number\">3</span></span><br><span class=\"line\"><span class=\"number\">4</span></span><br></pre></td></tr></table></figure>\n<p>既然可变参数列表可以传多个Int，那么可以这样吗？</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sum(<span class=\"number\">1</span> to <span class=\"number\">5</span>) <span class=\"comment\">//这样写会报错，原因是1 to 5只是一个Range对象，并不是多个Int的参数，不过可以通过以下方式来把它变成一个参数序列。</span></span><br><span class=\"line\">sum(<span class=\"number\">1</span> to <span class=\"number\">5</span>:_*) <span class=\"comment\">//这转成了一组参数序列</span></span><br></pre></td></tr></table></figure>\n<p>当调用可变参数列表的函数且参数类型为Object的java方法，要手工对基本类型进行转换。</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> str = <span class=\"type\">MessageFormat</span>.format(<span class=\"string\">\"The answer to &#123;0&#125; is [1]\"</span>, <span class=\"string\">\"everything\"</span>, <span class=\"number\">42.</span>asInstanceOf[<span class=\"type\">AnyRef</span>])</span><br></pre></td></tr></table></figure>\n<pre><code>42.asInstanceOf[AnyRef])\n</code></pre>\n<h3 id=\"过程\"><a class=\"markdownIt-Anchor\" href=\"#过程\"></a> 过程</h3>\n<p>如果函数体为花括号，但是没有“=”的函数，返回类型为Unit。也叫过程(procedure)</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">box</span></span>(s: <span class=\"type\">String</span>) &#123;<span class=\"comment\">//没有=号</span></span><br><span class=\"line\">...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//以下三种情况效果相同</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">box</span></span>(s:<span class=\"type\">String</span>)&#123;&#125;</span><br><span class=\"line\"><span class=\"comment\">//box: (s: String)Unit</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">box2</span></span>(s:<span class=\"type\">String</span>)=&#123;&#125;</span><br><span class=\"line\"><span class=\"comment\">//box2: (s: String)Unit</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">box3</span></span>(s:<span class=\"type\">String</span>):<span class=\"type\">Unit</span>=&#123;&#125;</span><br><span class=\"line\"><span class=\"comment\">//box3: (s: String)Unit</span></span><br></pre></td></tr></table></figure>\n<p>如果使用过程，有可能产生java程序员意想不到的后果，因为它的值为Unit。实际使用时和期望有可能不一致。导致：Unit在那里不能接受 的异常。</p>\n<h3 id=\"lazy\"><a class=\"markdownIt-Anchor\" href=\"#lazy\"></a> lazy</h3>\n<p>以下代码它会不会立刻初始化，只有当words被使用的时候才会去打开文件。</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">lazy</span> <span class=\"keyword\">val</span> words = scala.io.<span class=\"type\">Source</span>.fromFile(<span class=\"string\">\"/usr/share/dict/words\"</span>).mkString</span><br><span class=\"line\"><span class=\"comment\">//第一次被使用时执行</span></span><br><span class=\"line\"><span class=\"keyword\">val</span> words = scala.io.<span class=\"type\">Source</span>.fromFile(<span class=\"string\">\"/usr/share/dict/words\"</span>).mkString</span><br><span class=\"line\"><span class=\"comment\">//一被定义就执行</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">words</span> </span>= scala.io.<span class=\"type\">Source</span>.fromFile(<span class=\"string\">\"/usr/share/dict/words\"</span>).mkString</span><br><span class=\"line\"><span class=\"comment\">//每次调用执行都会执行</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"异常\"><a class=\"markdownIt-Anchor\" href=\"#异常\"></a> 异常</h3>\n<p>scala没有非运行时异常。IOException不需要声明和强制catch。throw一个异常的值为Nothing。</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"type\">IllegalArgumentException</span>(<span class=\"string\">\"this e exception\"</span>)<span class=\"comment\">//它的值为Nothing</span></span><br></pre></td></tr></table></figure>\n<p>scala中也同样使用try/catch来捕获异常，语法形式是scala中的模式匹配方式。</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> _: <span class=\"type\">SomeException</span>... <span class=\"comment\">//不需要使用异常变量，直接用“_”表示即可</span></span><br><span class=\"line\">&#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">    in.close() <span class=\"comment\">// 和java/c++中的含义相同，不管怎样，in都将被close</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<hr>\n<h2 id=\"习题\"><a class=\"markdownIt-Anchor\" href=\"#习题\"></a> 习题</h2>\n<ul>\n<li>一个数字如果为正数，则它的signum为1;如果是负数,则signum为-1;如果为0,则signum为0.编写一个函数来计算这个值。</li>\n</ul>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">signum</span></span>(num: <span class=\"type\">Int</span>):<span class=\"type\">Int</span> = &#123;</span><br><span class=\"line\">   <span class=\"keyword\">if</span>(num &gt; <span class=\"number\">0</span>) <span class=\"number\">1</span> <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(num == <span class=\"number\">0</span>) <span class=\"number\">0</span> <span class=\"keyword\">else</span> <span class=\"number\">-1</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>一个{}的值是什么？类型是什么？</li>\n</ul>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> t = &#123;&#125;</span><br><span class=\"line\"><span class=\"comment\">// t: Unit = ()</span></span><br></pre></td></tr></table></figure>\n<p>可以看出，它的值是()类型是Unit</p>\n<ul>\n<li>\n<p>指出在Scala中何种情况下赋值语句x=y=1是合法的。(提示：给x找个合适的类型定义)</p>\n<p>所以只要x为Unit类型就可以了。</p>\n</li>\n<li>\n<p>针对下列Java循环编写一个Scala版本:for(int i=10;i&gt;=0;i–)System.out.println(i);</p>\n</li>\n</ul>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span>(i &lt;- <span class=\"number\">0</span> to <span class=\"number\">10</span> reverse) println(i)</span><br></pre></td></tr></table></figure>\n<ul>\n<li>编写一个过程countdown(n:Int)，打印从n到0的数字。</li>\n</ul>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">countdown</span></span>(n:<span class=\"type\">Int</span>)&#123;</span><br><span class=\"line\">    <span class=\"number\">0</span> to n reverse foreach print</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>编写一个for循环,计算字符串中所有字母的Unicode代码的乘积。举例来说，&quot;Hello&quot;中所有字符串的乘积为9415087488L。</li>\n</ul>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> t:<span class=\"type\">Long</span> = <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"keyword\">for</span>(i &lt;- <span class=\"string\">\"Hello\"</span>) t = t * i.toLong</span><br><span class=\"line\">t</span><br><span class=\"line\"><span class=\"comment\">//res57: Long = 9415087488</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>同样是解决前一个练习的问题，但这次不使用循环。（提示：在Scaladoc中查看StringOps）</li>\n</ul>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">\"Hello\"</span>.foldLeft(<span class=\"number\">1</span>L)((a, b) =&gt; a * b)</span><br></pre></td></tr></table></figure>\n<ul>\n<li>编写一个函数product(s:String)，计算前面练习中提到的乘积。</li>\n</ul>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">product</span></span>(s:<span class=\"type\">String</span>):<span class=\"type\">BigInt</span> = &#123;</span><br><span class=\"line\">    s.foldLeft(<span class=\"number\">1</span>L)((a, b) =&gt; a * b)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>把前一个练习中的函数改成递归函数。</li>\n</ul>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">productRec</span></span>(s: <span class=\"type\">String</span>):<span class=\"type\">Long</span> = &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(s.length == <span class=\"number\">0</span>) <span class=\"number\">1</span></span><br><span class=\"line\">\t<span class=\"keyword\">else</span> s(<span class=\"number\">0</span>) * productRec(s drop <span class=\"number\">1</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>编写函数计算x<sup>n</sup>,其中n是整数，使用如下的递归定义：<br>\nx<sup>n</sup>=y<sup>2</sup>,如果n是正偶数的话，这里的y=x<sup>(n/2)</sup><br>\nx<sup>n</sup> = x*x<sup>(n-1)</sup>,如果n是正奇数的话<br>\nx<sup>0</sup> = 1<br>\nx<sup>n</sup> = 1/x<sup>(-n)</sup>,如果n是负数的话</li>\n</ul>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">xpown</span></span>(x: <span class=\"type\">BigInt</span>, n: <span class=\"type\">Int</span>): <span class=\"type\">BigInt</span> = &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(n &gt; <span class=\"number\">0</span> &amp;&amp; n % <span class=\"number\">2</span> == <span class=\"number\">0</span>) xpown(x, n / <span class=\"number\">2</span>) * xpown(x, n / <span class=\"number\">2</span>)</span><br><span class=\"line\">\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(n &gt; <span class=\"number\">0</span>) x * xpown(x, n - <span class=\"number\">1</span>)</span><br><span class=\"line\">\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(n == <span class=\"number\">0</span>) <span class=\"number\">1</span></span><br><span class=\"line\">\t<span class=\"keyword\">else</span> <span class=\"number\">1</span> / xpown(x, -n)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"Chapter-01-the-basics","catalog":true,"date":"2015-06-22T09:21:29.000Z","header-img":"/img/04.jpg","_content":"\n## Chapter-01-the-basics\n\nscala 基础\n\n---\n\n### 命令行环境\n在学习scala时可以用两种方式结合学习，一种是命令行模式，这适合执行一些简单的代码。以便快速得到结果。另一种是使用IDE开发，IDE这里使用的是IntelliJ IDEA。以下介绍了简单的几个步骤。\n#### EPFL命令行\n\n    1.安装scala\n    2.将scala/bin加到PATH中\n    3.执行scala命令\n#### IntelliJ IDEA\n    1.安装IDEA\n    2.安装scala插件\n    3.创建scala工程\n\n### 声明常量\n\n```scala\nval answer = 8 * 5 + 2 //不可变常量,不用使用分号\nanswer = 1 //错误！\n//以上代码等价于以下代码\nval answer : Int = 8 * 5 + 2 //不用写‘Int’的原因是scala已经有了类型推断\nvar name,company : String = null //name和company都是初始值为null的字符串\n```\n\n### 声明变量\n\n```scala\nvar answer = 8 * 5 + 2\n```\n\n### 常用类型\nscala中也存在七种类型用来对应java的基本类型：Byte、Char、Short、Int、Long、Float、Double、Boolean。scala中不存在基本类型的概念，都视为引用类型。\n下面的\"Hello\"和1分别被“偷偷”转换（隐式转换，如果想了解可以移步隐式转换那一章）成了StringOps和RichInt\n\n```scala\n\"Hello\".intersect(\"World\") //输出\"lo\" String被转换成了StringOps\n1.to(10) //Int被转换成RichInt\n```\n\n### 算术和操作符\nscala中的操作符实际上是方法。1 + 1 实际上等价于1.+(1),加号就是方法名。（java/c++程序员会感觉有些不一样）。并且这些方法同样可以重载，这样一来，你就可以定义属于自己的符号（方法名）定义了。\n\n### 调用函数和方法\n方法被引用来调用，而scala也支持函数，这些函数不需要从某个类来调用。直接使用便是。\n\n```scala\nsqrt(2) //平方根\npow(2, 4) //4的平方\nmin(3, Pi) //最小值\n/*\n不过在使用上述函数之前,\n你需要import scala.math._相当于java的import scala.math.*\n使用以scala开头的包时，可以省略scala前缀。如：import math._\n*/\n```\nscala没有静态方法，要使用类似的特性，可以使用companion object(伴生对象)。```BigInt.probablePrime(100, scala.util.Random)```这个生成随机数的方法，实际上BigInt是一个对象。\n\n不带参数的方法，scala中通常不使用圆括号调用。如```\"Hello\".distinct```\n\nscala中函数和方法的区别：\n>* Scala中的方法跟Java的方法一样，方法是组成类的一部分。\n>* Scala中的函数是一个完整的对象。\n\n任何一个函数对象都是一个继承了Function开头的特质（trait，可以暂时当做java中的接口）。\n\n```scala\nFunction1[+T1] extends AnyRef\n//A function of 1 parameter.\nFunction2[+T1, +T2] extends AnyRef\n//A function of 2 parameters.\nFunction3[+T1, +T2, +T3] extends AnyRef\n//A function of 3 parameters.\n//最多有Function22\n```\n\njava中有22个函数特质（trait）。任何一个函数都将是这22个trait的具体实现。\n\n```scala\n//以下两种方式结果相同\nval adder = (x:Int,y:Int) => x+y\n//返回 adder: (Int, Int) => Int = <function2>\nval adder = new Function2[Int,Int,Int](){\n    def apply(x:Int,y:Int):Int = x + y\n}\n//同样返回 adder: (Int, Int) => Int = <function2>\n```\n\n### apply方法\n\n```scala\n\n\n```scala\n\"Hello\"(4) //等价于\"Hello\".apply(4),相当于java里的\"Hello\".charAt(i),这是scala为了便利提供的一种语法糖。\n//\"Hello\"会被隐式转成StringOps，而在伴生对象StringOps中存在着apply方法。\n```\n\n### 使用scala doc\nhttp://www.scala-lang.org/api\n#### 使用技巧:\n1. 左上解可以搜索类名，每条结果左侧的C和O是可以点的。分别进到该类和companion object(伴生对象)。点“display all entities”可以看到所有的包。\n2. 数值类型，多看看RichInt、RichDouble等。字符串看StringOps。\n3. 数学函数位于scala.math包中，不在某个类里。\n4. 如果看到unary_-不要感到奇怪，这是前置的负操作符-x的方式。在操作符那章，你会豁然开朗。\n\n\n## 习题\n\n* 在Scala REPL中键入“3.” 然后按Tab。有哪些方法可以被应用？\n    \n        %   *   -   >    >>    ^  ...\n* 在Scala REPL计算3的平方根，再求值平方。现在，这个结果与3相关多少？（提示：res变量是你的朋友。）\n\n\n```scala\nimport math._\nsqrt(3)\n// res85: Double = 1.7320508075688772\n\nres85*res85\n// res86: Double = 2.9999999999999996\n\n3 - res86\n// res87: Double = 4.440892098500626E-16\n```\n\n* res变量是val还是var?\n\n\n\n```scala\nres89 = 3\n//<console>:8: error: reassignment to val\n//res9 = 3\n//   ^\n```\n* Scala允许你用数字去乘字符串---去REPL中试一下\"crazy\"*3。这个操作做什么？在Scaladoc中如何找到这个操作?\n\n\n```scala\n\"crazy\" * 3\n// res90: String = crazycrazycrazy\n```\n*    *是它的方法\"crazy\".*(3)。直接到StringOps类看*方法即可。\n5. 10 max 2的含义是什么？max方法在哪个类中？\n    \n    此方法返回两个数字中较大的那个。在RichInt中。\n\n6. 用BigInt计算2的1024次方。\n\n\n```scala\nBigInt(2).pow(1024)\n```\n\n* 为了在使用probablePrime(100,Random)获取随机素数时不在probablePrime和Random之前使用任何限定符，你需要引入什么？\n\n    要引入对应的包，Random在util下。而probablePrime在对象BigInt里。\n\n\n```scala\nimport util.Random\nimport import math.BigInt.probablePrime\nprobablePrime(3,Random)\n//res1: scala.math.BigInt = 5\n```\n\n* 创建随机文件的方式之一是生成一个随机的BigInt，然后将它转换成三十六进制，输出类似\"qsnvbevtomcj38o06kul\"这样的字符串。查阅Scaladoc，找到在Scala中实现该逻辑的办法。\n\n    在BigInt里找到toString方法\n\n\n```scala\nprobablePrime(100,Random)\n//res2: scala.math.BigInt = 680624836022523911868209171401\n\nres2.toString(36)\n//res3: String = 1tzk0mgequl6l6t2c24p\n```\n\n* 在Scala中如何获取字符串的首字符和尾字符？\n\n    到StringOps中查找\n\n\n```scala\nscala> res3.head\n//res4: Char = 1\nscala> res3.last\n//res6: Char = p\n\n//另外两种方式：\n\nres3(0)\nres3.take(1)\n//获取首字符\nres3.reverse(0)\nres3.takeRight(1)\n//获取尾字符\n```\n\n* take,drop,takeRight和dropRight这些字符串函数是做什么用的？和substring相比，他们的优点和缺点都是哪些？\n\n        查询API即可take是从字符串首开始获取字符串,drop是从字符串首开始去除字符串。takeRight和dropRight是从字符串尾开始操作。这四个方法都是单方向的。如果我想要字符串中间的子字符串，那么需要同时调用drop和dropRight，或者使用substring\n\n\n","source":"_posts/Chapter-01-the-basics.md","raw":"---\ntitle: 'Chapter-01-the-basics'\ncatalog: true\ndate: 2015-06-22 17:21:29\nheader-img: \"/img/04.jpg\"\ntags: \"scala\"\n---\n\n## Chapter-01-the-basics\n\nscala 基础\n\n---\n\n### 命令行环境\n在学习scala时可以用两种方式结合学习，一种是命令行模式，这适合执行一些简单的代码。以便快速得到结果。另一种是使用IDE开发，IDE这里使用的是IntelliJ IDEA。以下介绍了简单的几个步骤。\n#### EPFL命令行\n\n    1.安装scala\n    2.将scala/bin加到PATH中\n    3.执行scala命令\n#### IntelliJ IDEA\n    1.安装IDEA\n    2.安装scala插件\n    3.创建scala工程\n\n### 声明常量\n\n```scala\nval answer = 8 * 5 + 2 //不可变常量,不用使用分号\nanswer = 1 //错误！\n//以上代码等价于以下代码\nval answer : Int = 8 * 5 + 2 //不用写‘Int’的原因是scala已经有了类型推断\nvar name,company : String = null //name和company都是初始值为null的字符串\n```\n\n### 声明变量\n\n```scala\nvar answer = 8 * 5 + 2\n```\n\n### 常用类型\nscala中也存在七种类型用来对应java的基本类型：Byte、Char、Short、Int、Long、Float、Double、Boolean。scala中不存在基本类型的概念，都视为引用类型。\n下面的\"Hello\"和1分别被“偷偷”转换（隐式转换，如果想了解可以移步隐式转换那一章）成了StringOps和RichInt\n\n```scala\n\"Hello\".intersect(\"World\") //输出\"lo\" String被转换成了StringOps\n1.to(10) //Int被转换成RichInt\n```\n\n### 算术和操作符\nscala中的操作符实际上是方法。1 + 1 实际上等价于1.+(1),加号就是方法名。（java/c++程序员会感觉有些不一样）。并且这些方法同样可以重载，这样一来，你就可以定义属于自己的符号（方法名）定义了。\n\n### 调用函数和方法\n方法被引用来调用，而scala也支持函数，这些函数不需要从某个类来调用。直接使用便是。\n\n```scala\nsqrt(2) //平方根\npow(2, 4) //4的平方\nmin(3, Pi) //最小值\n/*\n不过在使用上述函数之前,\n你需要import scala.math._相当于java的import scala.math.*\n使用以scala开头的包时，可以省略scala前缀。如：import math._\n*/\n```\nscala没有静态方法，要使用类似的特性，可以使用companion object(伴生对象)。```BigInt.probablePrime(100, scala.util.Random)```这个生成随机数的方法，实际上BigInt是一个对象。\n\n不带参数的方法，scala中通常不使用圆括号调用。如```\"Hello\".distinct```\n\nscala中函数和方法的区别：\n>* Scala中的方法跟Java的方法一样，方法是组成类的一部分。\n>* Scala中的函数是一个完整的对象。\n\n任何一个函数对象都是一个继承了Function开头的特质（trait，可以暂时当做java中的接口）。\n\n```scala\nFunction1[+T1] extends AnyRef\n//A function of 1 parameter.\nFunction2[+T1, +T2] extends AnyRef\n//A function of 2 parameters.\nFunction3[+T1, +T2, +T3] extends AnyRef\n//A function of 3 parameters.\n//最多有Function22\n```\n\njava中有22个函数特质（trait）。任何一个函数都将是这22个trait的具体实现。\n\n```scala\n//以下两种方式结果相同\nval adder = (x:Int,y:Int) => x+y\n//返回 adder: (Int, Int) => Int = <function2>\nval adder = new Function2[Int,Int,Int](){\n    def apply(x:Int,y:Int):Int = x + y\n}\n//同样返回 adder: (Int, Int) => Int = <function2>\n```\n\n### apply方法\n\n```scala\n\n\n```scala\n\"Hello\"(4) //等价于\"Hello\".apply(4),相当于java里的\"Hello\".charAt(i),这是scala为了便利提供的一种语法糖。\n//\"Hello\"会被隐式转成StringOps，而在伴生对象StringOps中存在着apply方法。\n```\n\n### 使用scala doc\nhttp://www.scala-lang.org/api\n#### 使用技巧:\n1. 左上解可以搜索类名，每条结果左侧的C和O是可以点的。分别进到该类和companion object(伴生对象)。点“display all entities”可以看到所有的包。\n2. 数值类型，多看看RichInt、RichDouble等。字符串看StringOps。\n3. 数学函数位于scala.math包中，不在某个类里。\n4. 如果看到unary_-不要感到奇怪，这是前置的负操作符-x的方式。在操作符那章，你会豁然开朗。\n\n\n## 习题\n\n* 在Scala REPL中键入“3.” 然后按Tab。有哪些方法可以被应用？\n    \n        %   *   -   >    >>    ^  ...\n* 在Scala REPL计算3的平方根，再求值平方。现在，这个结果与3相关多少？（提示：res变量是你的朋友。）\n\n\n```scala\nimport math._\nsqrt(3)\n// res85: Double = 1.7320508075688772\n\nres85*res85\n// res86: Double = 2.9999999999999996\n\n3 - res86\n// res87: Double = 4.440892098500626E-16\n```\n\n* res变量是val还是var?\n\n\n\n```scala\nres89 = 3\n//<console>:8: error: reassignment to val\n//res9 = 3\n//   ^\n```\n* Scala允许你用数字去乘字符串---去REPL中试一下\"crazy\"*3。这个操作做什么？在Scaladoc中如何找到这个操作?\n\n\n```scala\n\"crazy\" * 3\n// res90: String = crazycrazycrazy\n```\n*    *是它的方法\"crazy\".*(3)。直接到StringOps类看*方法即可。\n5. 10 max 2的含义是什么？max方法在哪个类中？\n    \n    此方法返回两个数字中较大的那个。在RichInt中。\n\n6. 用BigInt计算2的1024次方。\n\n\n```scala\nBigInt(2).pow(1024)\n```\n\n* 为了在使用probablePrime(100,Random)获取随机素数时不在probablePrime和Random之前使用任何限定符，你需要引入什么？\n\n    要引入对应的包，Random在util下。而probablePrime在对象BigInt里。\n\n\n```scala\nimport util.Random\nimport import math.BigInt.probablePrime\nprobablePrime(3,Random)\n//res1: scala.math.BigInt = 5\n```\n\n* 创建随机文件的方式之一是生成一个随机的BigInt，然后将它转换成三十六进制，输出类似\"qsnvbevtomcj38o06kul\"这样的字符串。查阅Scaladoc，找到在Scala中实现该逻辑的办法。\n\n    在BigInt里找到toString方法\n\n\n```scala\nprobablePrime(100,Random)\n//res2: scala.math.BigInt = 680624836022523911868209171401\n\nres2.toString(36)\n//res3: String = 1tzk0mgequl6l6t2c24p\n```\n\n* 在Scala中如何获取字符串的首字符和尾字符？\n\n    到StringOps中查找\n\n\n```scala\nscala> res3.head\n//res4: Char = 1\nscala> res3.last\n//res6: Char = p\n\n//另外两种方式：\n\nres3(0)\nres3.take(1)\n//获取首字符\nres3.reverse(0)\nres3.takeRight(1)\n//获取尾字符\n```\n\n* take,drop,takeRight和dropRight这些字符串函数是做什么用的？和substring相比，他们的优点和缺点都是哪些？\n\n        查询API即可take是从字符串首开始获取字符串,drop是从字符串首开始去除字符串。takeRight和dropRight是从字符串尾开始操作。这四个方法都是单方向的。如果我想要字符串中间的子字符串，那么需要同时调用drop和dropRight，或者使用substring\n\n\n","slug":"Chapter-01-the-basics","published":1,"updated":"2017-11-25T06:28:50.494Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjahvvnwz0003pv4nfkrvjatd","content":"<h2><span id=\"chapter-01-the-basics\"> Chapter-01-the-basics</span></h2>\n<p>scala 基础</p>\n<hr>\n<h3><span id=\"命令行环境\"> 命令行环境</span></h3>\n<p>在学习scala时可以用两种方式结合学习，一种是命令行模式，这适合执行一些简单的代码。以便快速得到结果。另一种是使用IDE开发，IDE这里使用的是IntelliJ IDEA。以下介绍了简单的几个步骤。</p>\n<h4><span id=\"epfl命令行\"> EPFL命令行</span></h4>\n<pre><code>1.安装scala\n2.将scala/bin加到PATH中\n3.执行scala命令\n</code></pre>\n<h4><span id=\"intellij-idea\"> IntelliJ IDEA</span></h4>\n<pre><code>1.安装IDEA\n2.安装scala插件\n3.创建scala工程\n</code></pre>\n<h3><span id=\"声明常量\"> 声明常量</span></h3>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> answer = <span class=\"number\">8</span> * <span class=\"number\">5</span> + <span class=\"number\">2</span> <span class=\"comment\">//不可变常量,不用使用分号</span></span><br><span class=\"line\">answer = <span class=\"number\">1</span> <span class=\"comment\">//错误！</span></span><br><span class=\"line\"><span class=\"comment\">//以上代码等价于以下代码</span></span><br><span class=\"line\"><span class=\"keyword\">val</span> answer : <span class=\"type\">Int</span> = <span class=\"number\">8</span> * <span class=\"number\">5</span> + <span class=\"number\">2</span> <span class=\"comment\">//不用写‘Int’的原因是scala已经有了类型推断</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> name,company : <span class=\"type\">String</span> = <span class=\"literal\">null</span> <span class=\"comment\">//name和company都是初始值为null的字符串</span></span><br></pre></td></tr></table></figure>\n<h3><span id=\"声明变量\"> 声明变量</span></h3>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> answer = <span class=\"number\">8</span> * <span class=\"number\">5</span> + <span class=\"number\">2</span></span><br></pre></td></tr></table></figure>\n<h3><span id=\"常用类型\"> 常用类型</span></h3>\n<p>scala中也存在七种类型用来对应java的基本类型：Byte、Char、Short、Int、Long、Float、Double、Boolean。scala中不存在基本类型的概念，都视为引用类型。<br>\n下面的&quot;Hello&quot;和1分别被“偷偷”转换（隐式转换，如果想了解可以移步隐式转换那一章）成了StringOps和RichInt</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">\"Hello\"</span>.intersect(<span class=\"string\">\"World\"</span>) <span class=\"comment\">//输出\"lo\" String被转换成了StringOps</span></span><br><span class=\"line\"><span class=\"number\">1.</span>to(<span class=\"number\">10</span>) <span class=\"comment\">//Int被转换成RichInt</span></span><br></pre></td></tr></table></figure>\n<h3><span id=\"算术和操作符\"> 算术和操作符</span></h3>\n<p>scala中的操作符实际上是方法。1 + 1 实际上等价于1.+(1),加号就是方法名。（java/c++程序员会感觉有些不一样）。并且这些方法同样可以重载，这样一来，你就可以定义属于自己的符号（方法名）定义了。</p>\n<h3><span id=\"调用函数和方法\"> 调用函数和方法</span></h3>\n<p>方法被引用来调用，而scala也支持函数，这些函数不需要从某个类来调用。直接使用便是。</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sqrt(<span class=\"number\">2</span>) <span class=\"comment\">//平方根</span></span><br><span class=\"line\">pow(<span class=\"number\">2</span>, <span class=\"number\">4</span>) <span class=\"comment\">//4的平方</span></span><br><span class=\"line\">min(<span class=\"number\">3</span>, <span class=\"type\">Pi</span>) <span class=\"comment\">//最小值</span></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">不过在使用上述函数之前,</span></span><br><span class=\"line\"><span class=\"comment\">你需要import scala.math._相当于java的import scala.math.*</span></span><br><span class=\"line\"><span class=\"comment\">使用以scala开头的包时，可以省略scala前缀。如：import math._</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br></pre></td></tr></table></figure>\n<p>scala没有静态方法，要使用类似的特性，可以使用companion object(伴生对象)。<figure class=\"highlight plain\"><figcaption><span>scala.util.Random)```这个生成随机数的方法，实际上BigInt是一个对象。</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">不带参数的方法，scala中通常不使用圆括号调用。如```&quot;Hello&quot;.distinct</span><br></pre></td></tr></table></figure></p>\n<p>scala中函数和方法的区别：</p>\n<blockquote>\n<ul>\n<li>Scala中的方法跟Java的方法一样，方法是组成类的一部分。</li>\n<li>Scala中的函数是一个完整的对象。</li>\n</ul>\n</blockquote>\n<p>任何一个函数对象都是一个继承了Function开头的特质（trait，可以暂时当做java中的接口）。</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">Function1</span>[+<span class=\"type\">T1</span>] <span class=\"keyword\">extends</span> <span class=\"type\">AnyRef</span></span><br><span class=\"line\"><span class=\"comment\">//A function of 1 parameter.</span></span><br><span class=\"line\"><span class=\"type\">Function2</span>[+<span class=\"type\">T1</span>, +<span class=\"type\">T2</span>] <span class=\"keyword\">extends</span> <span class=\"type\">AnyRef</span></span><br><span class=\"line\"><span class=\"comment\">//A function of 2 parameters.</span></span><br><span class=\"line\"><span class=\"type\">Function3</span>[+<span class=\"type\">T1</span>, +<span class=\"type\">T2</span>, +<span class=\"type\">T3</span>] <span class=\"keyword\">extends</span> <span class=\"type\">AnyRef</span></span><br><span class=\"line\"><span class=\"comment\">//A function of 3 parameters.</span></span><br><span class=\"line\"><span class=\"comment\">//最多有Function22</span></span><br></pre></td></tr></table></figure>\n<p>java中有22个函数特质（trait）。任何一个函数都将是这22个trait的具体实现。</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//以下两种方式结果相同</span></span><br><span class=\"line\"><span class=\"keyword\">val</span> adder = (x:<span class=\"type\">Int</span>,y:<span class=\"type\">Int</span>) =&gt; x+y</span><br><span class=\"line\"><span class=\"comment\">//返回 adder: (Int, Int) =&gt; Int = &lt;function2&gt;</span></span><br><span class=\"line\"><span class=\"keyword\">val</span> adder = <span class=\"keyword\">new</span> <span class=\"type\">Function2</span>[<span class=\"type\">Int</span>,<span class=\"type\">Int</span>,<span class=\"type\">Int</span>]()&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">apply</span></span>(x:<span class=\"type\">Int</span>,y:<span class=\"type\">Int</span>):<span class=\"type\">Int</span> = x + y</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//同样返回 adder: (Int, Int) =&gt; Int = &lt;function2&gt;</span></span><br></pre></td></tr></table></figure>\n<h3><span id=\"apply方法\"> apply方法</span></h3>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">```scala</span><br><span class=\"line\"><span class=\"string\">\"Hello\"</span>(<span class=\"number\">4</span>) <span class=\"comment\">//等价于\"Hello\".apply(4),相当于java里的\"Hello\".charAt(i),这是scala为了便利提供的一种语法糖。</span></span><br><span class=\"line\"><span class=\"comment\">//\"Hello\"会被隐式转成StringOps，而在伴生对象StringOps中存在着apply方法。</span></span><br></pre></td></tr></table></figure>\n<h3><span id=\"使用scala-doc\"> 使用scala doc</span></h3>\n<p><a href=\"http://www.scala-lang.org/api\" target=\"_blank\" rel=\"noopener\">http://www.scala-lang.org/api</a></p>\n<h4><span id=\"使用技巧\"> 使用技巧:</span></h4>\n<ol>\n<li>左上解可以搜索类名，每条结果左侧的C和O是可以点的。分别进到该类和companion object(伴生对象)。点“display all entities”可以看到所有的包。</li>\n<li>数值类型，多看看RichInt、RichDouble等。字符串看StringOps。</li>\n<li>数学函数位于scala.math包中，不在某个类里。</li>\n<li>如果看到unary_-不要感到奇怪，这是前置的负操作符-x的方式。在操作符那章，你会豁然开朗。</li>\n</ol>\n<h2><span id=\"习题\"> 习题</span></h2>\n<ul>\n<li>\n<p>在Scala REPL中键入“3.” 然后按Tab。有哪些方法可以被应用？</p>\n<pre><code>  %   *   -   &gt;    &gt;&gt;    ^  ...\n</code></pre>\n</li>\n<li>\n<p>在Scala REPL计算3的平方根，再求值平方。现在，这个结果与3相关多少？（提示：res变量是你的朋友。）</p>\n</li>\n</ul>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> math._</span><br><span class=\"line\">sqrt(<span class=\"number\">3</span>)</span><br><span class=\"line\"><span class=\"comment\">// res85: Double = 1.7320508075688772</span></span><br><span class=\"line\"></span><br><span class=\"line\">res85*res85</span><br><span class=\"line\"><span class=\"comment\">// res86: Double = 2.9999999999999996</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">3</span> - res86</span><br><span class=\"line\"><span class=\"comment\">// res87: Double = 4.440892098500626E-16</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>res变量是val还是var?</li>\n</ul>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">res89 = <span class=\"number\">3</span></span><br><span class=\"line\"><span class=\"comment\">//&lt;console&gt;:8: error: reassignment to val</span></span><br><span class=\"line\"><span class=\"comment\">//res9 = 3</span></span><br><span class=\"line\"><span class=\"comment\">//   ^</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>Scala允许你用数字去乘字符串—去REPL中试一下&quot;crazy&quot;*3。这个操作做什么？在Scaladoc中如何找到这个操作?</li>\n</ul>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">\"crazy\"</span> * <span class=\"number\">3</span></span><br><span class=\"line\"><span class=\"comment\">// res90: String = crazycrazycrazy</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li><em>是它的方法&quot;crazy&quot;.</em>(3)。直接到StringOps类看*方法即可。</li>\n</ul>\n<ol start=\"5\">\n<li>\n<p>10 max 2的含义是什么？max方法在哪个类中？</p>\n<p>此方法返回两个数字中较大的那个。在RichInt中。</p>\n</li>\n<li>\n<p>用BigInt计算2的1024次方。</p>\n</li>\n</ol>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">BigInt</span>(<span class=\"number\">2</span>).pow(<span class=\"number\">1024</span>)</span><br></pre></td></tr></table></figure>\n<ul>\n<li>\n<p>为了在使用probablePrime(100,Random)获取随机素数时不在probablePrime和Random之前使用任何限定符，你需要引入什么？</p>\n<p>要引入对应的包，Random在util下。而probablePrime在对象BigInt里。</p>\n</li>\n</ul>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> util.<span class=\"type\">Random</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"keyword\">import</span> math.<span class=\"type\">BigInt</span>.probablePrime</span><br><span class=\"line\">probablePrime(<span class=\"number\">3</span>,<span class=\"type\">Random</span>)</span><br><span class=\"line\"><span class=\"comment\">//res1: scala.math.BigInt = 5</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>\n<p>创建随机文件的方式之一是生成一个随机的BigInt，然后将它转换成三十六进制，输出类似&quot;qsnvbevtomcj38o06kul&quot;这样的字符串。查阅Scaladoc，找到在Scala中实现该逻辑的办法。</p>\n<p>在BigInt里找到toString方法</p>\n</li>\n</ul>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">probablePrime(<span class=\"number\">100</span>,<span class=\"type\">Random</span>)</span><br><span class=\"line\"><span class=\"comment\">//res2: scala.math.BigInt = 680624836022523911868209171401</span></span><br><span class=\"line\"></span><br><span class=\"line\">res2.toString(<span class=\"number\">36</span>)</span><br><span class=\"line\"><span class=\"comment\">//res3: String = 1tzk0mgequl6l6t2c24p</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>\n<p>在Scala中如何获取字符串的首字符和尾字符？</p>\n<p>到StringOps中查找</p>\n</li>\n</ul>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">scala&gt; res3.head</span><br><span class=\"line\"><span class=\"comment\">//res4: Char = 1</span></span><br><span class=\"line\">scala&gt; res3.last</span><br><span class=\"line\"><span class=\"comment\">//res6: Char = p</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//另外两种方式：</span></span><br><span class=\"line\"></span><br><span class=\"line\">res3(<span class=\"number\">0</span>)</span><br><span class=\"line\">res3.take(<span class=\"number\">1</span>)</span><br><span class=\"line\"><span class=\"comment\">//获取首字符</span></span><br><span class=\"line\">res3.reverse(<span class=\"number\">0</span>)</span><br><span class=\"line\">res3.takeRight(<span class=\"number\">1</span>)</span><br><span class=\"line\"><span class=\"comment\">//获取尾字符</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>\n<p>take,drop,takeRight和dropRight这些字符串函数是做什么用的？和substring相比，他们的优点和缺点都是哪些？</p>\n<pre><code>  查询API即可take是从字符串首开始获取字符串,drop是从字符串首开始去除字符串。takeRight和dropRight是从字符串尾开始操作。这四个方法都是单方向的。如果我想要字符串中间的子字符串，那么需要同时调用drop和dropRight，或者使用substring\n</code></pre>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"chapter-01-the-basics\"><a class=\"markdownIt-Anchor\" href=\"#chapter-01-the-basics\"></a> Chapter-01-the-basics</h2>\n<p>scala 基础</p>\n<hr>\n<h3 id=\"命令行环境\"><a class=\"markdownIt-Anchor\" href=\"#命令行环境\"></a> 命令行环境</h3>\n<p>在学习scala时可以用两种方式结合学习，一种是命令行模式，这适合执行一些简单的代码。以便快速得到结果。另一种是使用IDE开发，IDE这里使用的是IntelliJ IDEA。以下介绍了简单的几个步骤。</p>\n<h4 id=\"epfl命令行\"><a class=\"markdownIt-Anchor\" href=\"#epfl命令行\"></a> EPFL命令行</h4>\n<pre><code>1.安装scala\n2.将scala/bin加到PATH中\n3.执行scala命令\n</code></pre>\n<h4 id=\"intellij-idea\"><a class=\"markdownIt-Anchor\" href=\"#intellij-idea\"></a> IntelliJ IDEA</h4>\n<pre><code>1.安装IDEA\n2.安装scala插件\n3.创建scala工程\n</code></pre>\n<h3 id=\"声明常量\"><a class=\"markdownIt-Anchor\" href=\"#声明常量\"></a> 声明常量</h3>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> answer = <span class=\"number\">8</span> * <span class=\"number\">5</span> + <span class=\"number\">2</span> <span class=\"comment\">//不可变常量,不用使用分号</span></span><br><span class=\"line\">answer = <span class=\"number\">1</span> <span class=\"comment\">//错误！</span></span><br><span class=\"line\"><span class=\"comment\">//以上代码等价于以下代码</span></span><br><span class=\"line\"><span class=\"keyword\">val</span> answer : <span class=\"type\">Int</span> = <span class=\"number\">8</span> * <span class=\"number\">5</span> + <span class=\"number\">2</span> <span class=\"comment\">//不用写‘Int’的原因是scala已经有了类型推断</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> name,company : <span class=\"type\">String</span> = <span class=\"literal\">null</span> <span class=\"comment\">//name和company都是初始值为null的字符串</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"声明变量\"><a class=\"markdownIt-Anchor\" href=\"#声明变量\"></a> 声明变量</h3>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> answer = <span class=\"number\">8</span> * <span class=\"number\">5</span> + <span class=\"number\">2</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"常用类型\"><a class=\"markdownIt-Anchor\" href=\"#常用类型\"></a> 常用类型</h3>\n<p>scala中也存在七种类型用来对应java的基本类型：Byte、Char、Short、Int、Long、Float、Double、Boolean。scala中不存在基本类型的概念，都视为引用类型。<br>\n下面的&quot;Hello&quot;和1分别被“偷偷”转换（隐式转换，如果想了解可以移步隐式转换那一章）成了StringOps和RichInt</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">\"Hello\"</span>.intersect(<span class=\"string\">\"World\"</span>) <span class=\"comment\">//输出\"lo\" String被转换成了StringOps</span></span><br><span class=\"line\"><span class=\"number\">1.</span>to(<span class=\"number\">10</span>) <span class=\"comment\">//Int被转换成RichInt</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"算术和操作符\"><a class=\"markdownIt-Anchor\" href=\"#算术和操作符\"></a> 算术和操作符</h3>\n<p>scala中的操作符实际上是方法。1 + 1 实际上等价于1.+(1),加号就是方法名。（java/c++程序员会感觉有些不一样）。并且这些方法同样可以重载，这样一来，你就可以定义属于自己的符号（方法名）定义了。</p>\n<h3 id=\"调用函数和方法\"><a class=\"markdownIt-Anchor\" href=\"#调用函数和方法\"></a> 调用函数和方法</h3>\n<p>方法被引用来调用，而scala也支持函数，这些函数不需要从某个类来调用。直接使用便是。</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sqrt(<span class=\"number\">2</span>) <span class=\"comment\">//平方根</span></span><br><span class=\"line\">pow(<span class=\"number\">2</span>, <span class=\"number\">4</span>) <span class=\"comment\">//4的平方</span></span><br><span class=\"line\">min(<span class=\"number\">3</span>, <span class=\"type\">Pi</span>) <span class=\"comment\">//最小值</span></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">不过在使用上述函数之前,</span></span><br><span class=\"line\"><span class=\"comment\">你需要import scala.math._相当于java的import scala.math.*</span></span><br><span class=\"line\"><span class=\"comment\">使用以scala开头的包时，可以省略scala前缀。如：import math._</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br></pre></td></tr></table></figure>\n<p>scala没有静态方法，要使用类似的特性，可以使用companion object(伴生对象)。<figure class=\"highlight plain\"><figcaption><span>scala.util.Random)```这个生成随机数的方法，实际上BigInt是一个对象。</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">不带参数的方法，scala中通常不使用圆括号调用。如```&quot;Hello&quot;.distinct</span><br></pre></td></tr></table></figure></p>\n<p>scala中函数和方法的区别：</p>\n<blockquote>\n<ul>\n<li>Scala中的方法跟Java的方法一样，方法是组成类的一部分。</li>\n<li>Scala中的函数是一个完整的对象。</li>\n</ul>\n</blockquote>\n<p>任何一个函数对象都是一个继承了Function开头的特质（trait，可以暂时当做java中的接口）。</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">Function1</span>[+<span class=\"type\">T1</span>] <span class=\"keyword\">extends</span> <span class=\"type\">AnyRef</span></span><br><span class=\"line\"><span class=\"comment\">//A function of 1 parameter.</span></span><br><span class=\"line\"><span class=\"type\">Function2</span>[+<span class=\"type\">T1</span>, +<span class=\"type\">T2</span>] <span class=\"keyword\">extends</span> <span class=\"type\">AnyRef</span></span><br><span class=\"line\"><span class=\"comment\">//A function of 2 parameters.</span></span><br><span class=\"line\"><span class=\"type\">Function3</span>[+<span class=\"type\">T1</span>, +<span class=\"type\">T2</span>, +<span class=\"type\">T3</span>] <span class=\"keyword\">extends</span> <span class=\"type\">AnyRef</span></span><br><span class=\"line\"><span class=\"comment\">//A function of 3 parameters.</span></span><br><span class=\"line\"><span class=\"comment\">//最多有Function22</span></span><br></pre></td></tr></table></figure>\n<p>java中有22个函数特质（trait）。任何一个函数都将是这22个trait的具体实现。</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//以下两种方式结果相同</span></span><br><span class=\"line\"><span class=\"keyword\">val</span> adder = (x:<span class=\"type\">Int</span>,y:<span class=\"type\">Int</span>) =&gt; x+y</span><br><span class=\"line\"><span class=\"comment\">//返回 adder: (Int, Int) =&gt; Int = &lt;function2&gt;</span></span><br><span class=\"line\"><span class=\"keyword\">val</span> adder = <span class=\"keyword\">new</span> <span class=\"type\">Function2</span>[<span class=\"type\">Int</span>,<span class=\"type\">Int</span>,<span class=\"type\">Int</span>]()&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">apply</span></span>(x:<span class=\"type\">Int</span>,y:<span class=\"type\">Int</span>):<span class=\"type\">Int</span> = x + y</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//同样返回 adder: (Int, Int) =&gt; Int = &lt;function2&gt;</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"apply方法\"><a class=\"markdownIt-Anchor\" href=\"#apply方法\"></a> apply方法</h3>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">```scala</span><br><span class=\"line\"><span class=\"string\">\"Hello\"</span>(<span class=\"number\">4</span>) <span class=\"comment\">//等价于\"Hello\".apply(4),相当于java里的\"Hello\".charAt(i),这是scala为了便利提供的一种语法糖。</span></span><br><span class=\"line\"><span class=\"comment\">//\"Hello\"会被隐式转成StringOps，而在伴生对象StringOps中存在着apply方法。</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"使用scala-doc\"><a class=\"markdownIt-Anchor\" href=\"#使用scala-doc\"></a> 使用scala doc</h3>\n<p><a href=\"http://www.scala-lang.org/api\" target=\"_blank\" rel=\"noopener\">http://www.scala-lang.org/api</a></p>\n<h4 id=\"使用技巧\"><a class=\"markdownIt-Anchor\" href=\"#使用技巧\"></a> 使用技巧:</h4>\n<ol>\n<li>左上解可以搜索类名，每条结果左侧的C和O是可以点的。分别进到该类和companion object(伴生对象)。点“display all entities”可以看到所有的包。</li>\n<li>数值类型，多看看RichInt、RichDouble等。字符串看StringOps。</li>\n<li>数学函数位于scala.math包中，不在某个类里。</li>\n<li>如果看到unary_-不要感到奇怪，这是前置的负操作符-x的方式。在操作符那章，你会豁然开朗。</li>\n</ol>\n<h2 id=\"习题\"><a class=\"markdownIt-Anchor\" href=\"#习题\"></a> 习题</h2>\n<ul>\n<li>\n<p>在Scala REPL中键入“3.” 然后按Tab。有哪些方法可以被应用？</p>\n<pre><code>  %   *   -   &gt;    &gt;&gt;    ^  ...\n</code></pre>\n</li>\n<li>\n<p>在Scala REPL计算3的平方根，再求值平方。现在，这个结果与3相关多少？（提示：res变量是你的朋友。）</p>\n</li>\n</ul>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> math._</span><br><span class=\"line\">sqrt(<span class=\"number\">3</span>)</span><br><span class=\"line\"><span class=\"comment\">// res85: Double = 1.7320508075688772</span></span><br><span class=\"line\"></span><br><span class=\"line\">res85*res85</span><br><span class=\"line\"><span class=\"comment\">// res86: Double = 2.9999999999999996</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">3</span> - res86</span><br><span class=\"line\"><span class=\"comment\">// res87: Double = 4.440892098500626E-16</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>res变量是val还是var?</li>\n</ul>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">res89 = <span class=\"number\">3</span></span><br><span class=\"line\"><span class=\"comment\">//&lt;console&gt;:8: error: reassignment to val</span></span><br><span class=\"line\"><span class=\"comment\">//res9 = 3</span></span><br><span class=\"line\"><span class=\"comment\">//   ^</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>Scala允许你用数字去乘字符串—去REPL中试一下&quot;crazy&quot;*3。这个操作做什么？在Scaladoc中如何找到这个操作?</li>\n</ul>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">\"crazy\"</span> * <span class=\"number\">3</span></span><br><span class=\"line\"><span class=\"comment\">// res90: String = crazycrazycrazy</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li><em>是它的方法&quot;crazy&quot;.</em>(3)。直接到StringOps类看*方法即可。</li>\n</ul>\n<ol start=\"5\">\n<li>\n<p>10 max 2的含义是什么？max方法在哪个类中？</p>\n<p>此方法返回两个数字中较大的那个。在RichInt中。</p>\n</li>\n<li>\n<p>用BigInt计算2的1024次方。</p>\n</li>\n</ol>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">BigInt</span>(<span class=\"number\">2</span>).pow(<span class=\"number\">1024</span>)</span><br></pre></td></tr></table></figure>\n<ul>\n<li>\n<p>为了在使用probablePrime(100,Random)获取随机素数时不在probablePrime和Random之前使用任何限定符，你需要引入什么？</p>\n<p>要引入对应的包，Random在util下。而probablePrime在对象BigInt里。</p>\n</li>\n</ul>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> util.<span class=\"type\">Random</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"keyword\">import</span> math.<span class=\"type\">BigInt</span>.probablePrime</span><br><span class=\"line\">probablePrime(<span class=\"number\">3</span>,<span class=\"type\">Random</span>)</span><br><span class=\"line\"><span class=\"comment\">//res1: scala.math.BigInt = 5</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>\n<p>创建随机文件的方式之一是生成一个随机的BigInt，然后将它转换成三十六进制，输出类似&quot;qsnvbevtomcj38o06kul&quot;这样的字符串。查阅Scaladoc，找到在Scala中实现该逻辑的办法。</p>\n<p>在BigInt里找到toString方法</p>\n</li>\n</ul>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">probablePrime(<span class=\"number\">100</span>,<span class=\"type\">Random</span>)</span><br><span class=\"line\"><span class=\"comment\">//res2: scala.math.BigInt = 680624836022523911868209171401</span></span><br><span class=\"line\"></span><br><span class=\"line\">res2.toString(<span class=\"number\">36</span>)</span><br><span class=\"line\"><span class=\"comment\">//res3: String = 1tzk0mgequl6l6t2c24p</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>\n<p>在Scala中如何获取字符串的首字符和尾字符？</p>\n<p>到StringOps中查找</p>\n</li>\n</ul>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">scala&gt; res3.head</span><br><span class=\"line\"><span class=\"comment\">//res4: Char = 1</span></span><br><span class=\"line\">scala&gt; res3.last</span><br><span class=\"line\"><span class=\"comment\">//res6: Char = p</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//另外两种方式：</span></span><br><span class=\"line\"></span><br><span class=\"line\">res3(<span class=\"number\">0</span>)</span><br><span class=\"line\">res3.take(<span class=\"number\">1</span>)</span><br><span class=\"line\"><span class=\"comment\">//获取首字符</span></span><br><span class=\"line\">res3.reverse(<span class=\"number\">0</span>)</span><br><span class=\"line\">res3.takeRight(<span class=\"number\">1</span>)</span><br><span class=\"line\"><span class=\"comment\">//获取尾字符</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>\n<p>take,drop,takeRight和dropRight这些字符串函数是做什么用的？和substring相比，他们的优点和缺点都是哪些？</p>\n<pre><code>  查询API即可take是从字符串首开始获取字符串,drop是从字符串首开始去除字符串。takeRight和dropRight是从字符串尾开始操作。这四个方法都是单方向的。如果我想要字符串中间的子字符串，那么需要同时调用drop和dropRight，或者使用substring\n</code></pre>\n</li>\n</ul>\n"},{"title":"Chapter-03-working-with-arrays","catalog":true,"date":"2015-06-22T09:21:29.000Z","header-img":"/img/04.jpg","_content":"\n## Chapter-03-working-with-arrays\n\n数组\n\n---\n\n### 定长数组\n\n```scala\nval nums = new Array[Int](10)\n//初始化10整数的数组，所有元素初始化为0\nval strs = new Array[String](10)\n//10个值为null\nval s = Array(\"Hello\", \"Allon\")\n//Array对象的apply方法\ns(0) = \"Goodbye\"\n//用圆括号\n```\n\n### 变长数组\n\n```scala\nimport scala.collection.mutable.ArrayBuffer\nval b = ArrayBuffer[Int]()\n//一个空buffer\nb += 1 \n//相当于b.+=(ArrayBuffer(1))\n//在结尾加一个元素\nb += (1,2,3)\n//在结尾加一坨元素，ArrayBuffer(1,2,3)\nb ++= Array(4,5,6)\n//在结尾加任何集合\nb.trimEnd(3)\n//移除最后3个元素，\n```\n在数组缓冲结尾追加和移除是高效的。也可以insert一些元素，后面的元素会顺移。\n\n```scala\nb.insert(2,13)\n//输出(1, 1, 13, 2, 3)\nb.insert(2,31,32,33)\n//输出(1, 1, 31, 32, 33, 13, 2, 3)\nb.remove(2)\n//输出(1, 1, 32, 33, 13, 2, 3)\nb.remove(2,3)\n//输出(1, 1, 2, 3)，移除下标为2的起点共3个元素\n```\n一般来讲，可以先构建一个ArrayBuffer然后在buffer伸缩完成后再toArray。\n\n```scala\nb.toArray\n//Array(1, 1, 2, 3)\n```\n### 遍历Array和ArrayBuffer\n常规遍历\n\n```scala\nfor(i <- 0 until (b.length, 2)) println(b(i))\n//隔一个搞一下\n//输出\n1\n2\n```\n如果不使用下标，可以更简单的遍历，有点像java中的增强for循环。\n\n```scala\nfor(elem <- b){\n    println(elem)\n}\n```\n### 数组转换\n\n```scala\nfor (elem <- b) yield elem\n//b是一个ArrayBuffer，yield出来的结果也将会是一个ArrayBuffer\n//如果b是一个Array，结果就会产生一个Array\nfor(i <- 0 until 10) yield i\n//这样它会产生一个Vector(0, 1, 2, 3, 4, 5, 6, 7, 8, 9)\n```\n以上代码都会生成一个新的集合，原集合不变。其实在scala中，也可以这样来实现：\n\n```scala\nb.filter(_ % 2 == 0).map(2 * _)\n//或\nb filter {_ % 2 == 0} map {2 * _}\n```\n### 常用算法\n\n```scala\nArray(1, 2, 3, 4, 5, 6).sum\nArray(1, 2, 3, 4, 5, 6).max\n```\n排序\n\n```scala\nval b = ArrayBuffer(1, 7, 2, 9)\nb.sorted\n//返回一个ArrayBuffer(1, 2, 7, 9)\n```\n也可以传入一个比较函数\n\n```scala\nb.sortWith(_ < _)\n//返回一个ArrayBuffer(9, 7, 2, 1)\n```\n对一个数组自身排序，（虽然b为val，但是它内部的元素是可以修改的）\n\n```scala\nval b = Array(1, 7, 2, 9)\nutil.Sorting.quickSort(b)\n//b变成了Array(1, 2, 7, 9)\n```\n打印数组可以像python中的join方法一样（用分隔符输出），同时可以加前后缀\n\n```scala\nb.mkString(\",\")\n//加分隔符返回 String = 1,2,7,9\n\nb.mkString(\"<\",\",\",\">\")\n//返回 String = <1,2,7,9>\n```\nArrayBuffer（不是Array）的toString方法默认不会像java一样打些没用的东西，而是带有类似mkString的输出，打印出如下效果。\n\n```scala\nval c = ArrayBuffer(1, 7, 2, 9)\nc.toString\n//输出ArrayBuffer(1, 7, 2, 9)\n```\n### 多维数组\n要构建一个Array[Array[Double]]，在scala中可以使用ofDim方法：\n\n```scala\nval b = Array.ofDim[Double](3,4)//三行，四列\n//输出b: Array[Array[Double]] = Array(Array(0.0, 0.0, 0.0, 0.0),Array(0.0, 0.0, 0.0, 0.0), Array(0.0, 0.0, 0.0, 0.0))\nb(2)(1) = 1.111//下标为横2纵1（第3个数组中的第2个值）。\n```\n* 其实多维数组就是：数组的数组。所以每行长度都是可以自由定义来决定。\n\n### 和java相互转换\nscala数组可以和java数组之间来回转换。请关注隐式转换那一章。\n\n## 习题\n* 编写一段代码，将a设置为一个n个随机整数的数组，要求随机数介于0（包含）和n(不包含)之间。\n\n```scala\ndef randomArray(n: Int): Array[Int] = {\n    val vector = for (i <- 0 until n) yield scala.util.Random.nextInt(n)\n    vector.toArray\n}\n```\n\n* 编写一个循环，将整数数组中的相信元素对换，\n\n```scala\ndef switchNear(arr: Array[Int]): Array[Int] = {\n  val t = arr.toBuffer\n  for (i <- 1 until(t.length, 2); tmp = t(i)) {\n    t(i) = t(i - 1)\n    t(i - 1) = tmp\n  }\n  t.toArray\n}\n```\n* 重复前一个练习，不过这一次生成一个新的值交换过的数组。用for/yield。\n\n```scala\ndef switchNear(arr: Array[Int]): Array[Int] = {\n  val vector =\n    for (i <- 0 until arr.length; tmp = arr(i)) yield if (i % 2 == 0) arr(i + 1) else arr(i - 1)\n  vector.toArray\n}\n```\n\n* 给定一个整数数组，产生一个新的数组，包含元数组中的所有正值，以原有顺序排列，之后的元素是所有零或负值，以原有顺序排列。\n\n```scala\ndef branchArray(arr: Array[Int]): Array[Int] = {\n  val pre = ArrayBuffer[Int]()\n  val last = ArrayBuffer[Int]()\n  arr foreach (item => if (item >= 0) pre += item else last += item)\n  pre ++= last.toArray\n  pre.toArray\n}\n//另一个方法\ndef branchArray2(arr: Array[Int]): Array[Int] = {\n  val all = ArrayBuffer[Int]()\n  all ++= arr.filter(_ >= 0)\n  all ++= arr.filter(_ < 0)\n  all.toArray\n}\n```\n\n* 如何计算Aarray[Double]的平均值？\n\n```scala\ndef avgArr(arr: Array[Double]): Double = {\n  arr.sum / arr.length\n}\n```\n\n* 如何将Array[Int]反序排列？对于ArrayBuffer[Int]你又会怎么做？\n\n```scala\narr reverse\narr.toBuffer reverse\n```\n\n* 写一段代码，打印数组中的所有的值，并去掉重复项。（提示：查看Scaladoc）\n\n```scala\n//arr: Array[Int] = Array(-2, -1, 0, 1, 2, 1, 2, 3, 4, -1)\narr distinct\n//res116: Array[Int] = Array(-2, -1, 0, 1, 2, 3, 4)\n```\n\n* 收集一个数组的负值下标到一个数组，反序这个数组，再去掉它最后一个元素。然后对每个下标调用remove(i)。比较和之前做法的效率。\n\n```scala\nfor(i <- 0 until arr.length if arr(i)<0) yield i\nc.reverse.trimStart(1)\nval d = arr.toBuffer\nc.foreach(d.remove)\n```\n\n","source":"_posts/Chapter-03-working-with-arrays.md","raw":"---\ntitle: 'Chapter-03-working-with-arrays'\ncatalog: true\ndate: 2015-06-22 17:21:29\nheader-img: \"/img/04.jpg\"\ntags: \"scala\"\n---\n\n## Chapter-03-working-with-arrays\n\n数组\n\n---\n\n### 定长数组\n\n```scala\nval nums = new Array[Int](10)\n//初始化10整数的数组，所有元素初始化为0\nval strs = new Array[String](10)\n//10个值为null\nval s = Array(\"Hello\", \"Allon\")\n//Array对象的apply方法\ns(0) = \"Goodbye\"\n//用圆括号\n```\n\n### 变长数组\n\n```scala\nimport scala.collection.mutable.ArrayBuffer\nval b = ArrayBuffer[Int]()\n//一个空buffer\nb += 1 \n//相当于b.+=(ArrayBuffer(1))\n//在结尾加一个元素\nb += (1,2,3)\n//在结尾加一坨元素，ArrayBuffer(1,2,3)\nb ++= Array(4,5,6)\n//在结尾加任何集合\nb.trimEnd(3)\n//移除最后3个元素，\n```\n在数组缓冲结尾追加和移除是高效的。也可以insert一些元素，后面的元素会顺移。\n\n```scala\nb.insert(2,13)\n//输出(1, 1, 13, 2, 3)\nb.insert(2,31,32,33)\n//输出(1, 1, 31, 32, 33, 13, 2, 3)\nb.remove(2)\n//输出(1, 1, 32, 33, 13, 2, 3)\nb.remove(2,3)\n//输出(1, 1, 2, 3)，移除下标为2的起点共3个元素\n```\n一般来讲，可以先构建一个ArrayBuffer然后在buffer伸缩完成后再toArray。\n\n```scala\nb.toArray\n//Array(1, 1, 2, 3)\n```\n### 遍历Array和ArrayBuffer\n常规遍历\n\n```scala\nfor(i <- 0 until (b.length, 2)) println(b(i))\n//隔一个搞一下\n//输出\n1\n2\n```\n如果不使用下标，可以更简单的遍历，有点像java中的增强for循环。\n\n```scala\nfor(elem <- b){\n    println(elem)\n}\n```\n### 数组转换\n\n```scala\nfor (elem <- b) yield elem\n//b是一个ArrayBuffer，yield出来的结果也将会是一个ArrayBuffer\n//如果b是一个Array，结果就会产生一个Array\nfor(i <- 0 until 10) yield i\n//这样它会产生一个Vector(0, 1, 2, 3, 4, 5, 6, 7, 8, 9)\n```\n以上代码都会生成一个新的集合，原集合不变。其实在scala中，也可以这样来实现：\n\n```scala\nb.filter(_ % 2 == 0).map(2 * _)\n//或\nb filter {_ % 2 == 0} map {2 * _}\n```\n### 常用算法\n\n```scala\nArray(1, 2, 3, 4, 5, 6).sum\nArray(1, 2, 3, 4, 5, 6).max\n```\n排序\n\n```scala\nval b = ArrayBuffer(1, 7, 2, 9)\nb.sorted\n//返回一个ArrayBuffer(1, 2, 7, 9)\n```\n也可以传入一个比较函数\n\n```scala\nb.sortWith(_ < _)\n//返回一个ArrayBuffer(9, 7, 2, 1)\n```\n对一个数组自身排序，（虽然b为val，但是它内部的元素是可以修改的）\n\n```scala\nval b = Array(1, 7, 2, 9)\nutil.Sorting.quickSort(b)\n//b变成了Array(1, 2, 7, 9)\n```\n打印数组可以像python中的join方法一样（用分隔符输出），同时可以加前后缀\n\n```scala\nb.mkString(\",\")\n//加分隔符返回 String = 1,2,7,9\n\nb.mkString(\"<\",\",\",\">\")\n//返回 String = <1,2,7,9>\n```\nArrayBuffer（不是Array）的toString方法默认不会像java一样打些没用的东西，而是带有类似mkString的输出，打印出如下效果。\n\n```scala\nval c = ArrayBuffer(1, 7, 2, 9)\nc.toString\n//输出ArrayBuffer(1, 7, 2, 9)\n```\n### 多维数组\n要构建一个Array[Array[Double]]，在scala中可以使用ofDim方法：\n\n```scala\nval b = Array.ofDim[Double](3,4)//三行，四列\n//输出b: Array[Array[Double]] = Array(Array(0.0, 0.0, 0.0, 0.0),Array(0.0, 0.0, 0.0, 0.0), Array(0.0, 0.0, 0.0, 0.0))\nb(2)(1) = 1.111//下标为横2纵1（第3个数组中的第2个值）。\n```\n* 其实多维数组就是：数组的数组。所以每行长度都是可以自由定义来决定。\n\n### 和java相互转换\nscala数组可以和java数组之间来回转换。请关注隐式转换那一章。\n\n## 习题\n* 编写一段代码，将a设置为一个n个随机整数的数组，要求随机数介于0（包含）和n(不包含)之间。\n\n```scala\ndef randomArray(n: Int): Array[Int] = {\n    val vector = for (i <- 0 until n) yield scala.util.Random.nextInt(n)\n    vector.toArray\n}\n```\n\n* 编写一个循环，将整数数组中的相信元素对换，\n\n```scala\ndef switchNear(arr: Array[Int]): Array[Int] = {\n  val t = arr.toBuffer\n  for (i <- 1 until(t.length, 2); tmp = t(i)) {\n    t(i) = t(i - 1)\n    t(i - 1) = tmp\n  }\n  t.toArray\n}\n```\n* 重复前一个练习，不过这一次生成一个新的值交换过的数组。用for/yield。\n\n```scala\ndef switchNear(arr: Array[Int]): Array[Int] = {\n  val vector =\n    for (i <- 0 until arr.length; tmp = arr(i)) yield if (i % 2 == 0) arr(i + 1) else arr(i - 1)\n  vector.toArray\n}\n```\n\n* 给定一个整数数组，产生一个新的数组，包含元数组中的所有正值，以原有顺序排列，之后的元素是所有零或负值，以原有顺序排列。\n\n```scala\ndef branchArray(arr: Array[Int]): Array[Int] = {\n  val pre = ArrayBuffer[Int]()\n  val last = ArrayBuffer[Int]()\n  arr foreach (item => if (item >= 0) pre += item else last += item)\n  pre ++= last.toArray\n  pre.toArray\n}\n//另一个方法\ndef branchArray2(arr: Array[Int]): Array[Int] = {\n  val all = ArrayBuffer[Int]()\n  all ++= arr.filter(_ >= 0)\n  all ++= arr.filter(_ < 0)\n  all.toArray\n}\n```\n\n* 如何计算Aarray[Double]的平均值？\n\n```scala\ndef avgArr(arr: Array[Double]): Double = {\n  arr.sum / arr.length\n}\n```\n\n* 如何将Array[Int]反序排列？对于ArrayBuffer[Int]你又会怎么做？\n\n```scala\narr reverse\narr.toBuffer reverse\n```\n\n* 写一段代码，打印数组中的所有的值，并去掉重复项。（提示：查看Scaladoc）\n\n```scala\n//arr: Array[Int] = Array(-2, -1, 0, 1, 2, 1, 2, 3, 4, -1)\narr distinct\n//res116: Array[Int] = Array(-2, -1, 0, 1, 2, 3, 4)\n```\n\n* 收集一个数组的负值下标到一个数组，反序这个数组，再去掉它最后一个元素。然后对每个下标调用remove(i)。比较和之前做法的效率。\n\n```scala\nfor(i <- 0 until arr.length if arr(i)<0) yield i\nc.reverse.trimStart(1)\nval d = arr.toBuffer\nc.foreach(d.remove)\n```\n\n","slug":"Chapter-03-working-with-arrays","published":1,"updated":"2017-11-25T06:28:50.495Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjahvvnx30006pv4n8fwn9ono","content":"<h2><span id=\"chapter-03-working-with-arrays\"> Chapter-03-working-with-arrays</span></h2>\n<p>数组</p>\n<hr>\n<h3><span id=\"定长数组\"> 定长数组</span></h3>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> nums = <span class=\"keyword\">new</span> <span class=\"type\">Array</span>[<span class=\"type\">Int</span>](<span class=\"number\">10</span>)</span><br><span class=\"line\"><span class=\"comment\">//初始化10整数的数组，所有元素初始化为0</span></span><br><span class=\"line\"><span class=\"keyword\">val</span> strs = <span class=\"keyword\">new</span> <span class=\"type\">Array</span>[<span class=\"type\">String</span>](<span class=\"number\">10</span>)</span><br><span class=\"line\"><span class=\"comment\">//10个值为null</span></span><br><span class=\"line\"><span class=\"keyword\">val</span> s = <span class=\"type\">Array</span>(<span class=\"string\">\"Hello\"</span>, <span class=\"string\">\"Allon\"</span>)</span><br><span class=\"line\"><span class=\"comment\">//Array对象的apply方法</span></span><br><span class=\"line\">s(<span class=\"number\">0</span>) = <span class=\"string\">\"Goodbye\"</span></span><br><span class=\"line\"><span class=\"comment\">//用圆括号</span></span><br></pre></td></tr></table></figure>\n<h3><span id=\"变长数组\"> 变长数组</span></h3>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> scala.collection.mutable.<span class=\"type\">ArrayBuffer</span></span><br><span class=\"line\"><span class=\"keyword\">val</span> b = <span class=\"type\">ArrayBuffer</span>[<span class=\"type\">Int</span>]()</span><br><span class=\"line\"><span class=\"comment\">//一个空buffer</span></span><br><span class=\"line\">b += <span class=\"number\">1</span> </span><br><span class=\"line\"><span class=\"comment\">//相当于b.+=(ArrayBuffer(1))</span></span><br><span class=\"line\"><span class=\"comment\">//在结尾加一个元素</span></span><br><span class=\"line\">b += (<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>)</span><br><span class=\"line\"><span class=\"comment\">//在结尾加一坨元素，ArrayBuffer(1,2,3)</span></span><br><span class=\"line\">b ++= <span class=\"type\">Array</span>(<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>)</span><br><span class=\"line\"><span class=\"comment\">//在结尾加任何集合</span></span><br><span class=\"line\">b.trimEnd(<span class=\"number\">3</span>)</span><br><span class=\"line\"><span class=\"comment\">//移除最后3个元素，</span></span><br></pre></td></tr></table></figure>\n<p>在数组缓冲结尾追加和移除是高效的。也可以insert一些元素，后面的元素会顺移。</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">b.insert(<span class=\"number\">2</span>,<span class=\"number\">13</span>)</span><br><span class=\"line\"><span class=\"comment\">//输出(1, 1, 13, 2, 3)</span></span><br><span class=\"line\">b.insert(<span class=\"number\">2</span>,<span class=\"number\">31</span>,<span class=\"number\">32</span>,<span class=\"number\">33</span>)</span><br><span class=\"line\"><span class=\"comment\">//输出(1, 1, 31, 32, 33, 13, 2, 3)</span></span><br><span class=\"line\">b.remove(<span class=\"number\">2</span>)</span><br><span class=\"line\"><span class=\"comment\">//输出(1, 1, 32, 33, 13, 2, 3)</span></span><br><span class=\"line\">b.remove(<span class=\"number\">2</span>,<span class=\"number\">3</span>)</span><br><span class=\"line\"><span class=\"comment\">//输出(1, 1, 2, 3)，移除下标为2的起点共3个元素</span></span><br></pre></td></tr></table></figure>\n<p>一般来讲，可以先构建一个ArrayBuffer然后在buffer伸缩完成后再toArray。</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">b.toArray</span><br><span class=\"line\"><span class=\"comment\">//Array(1, 1, 2, 3)</span></span><br></pre></td></tr></table></figure>\n<h3><span id=\"遍历array和arraybuffer\"> 遍历Array和ArrayBuffer</span></h3>\n<p>常规遍历</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span>(i &lt;- <span class=\"number\">0</span> until (b.length, <span class=\"number\">2</span>)) println(b(i))</span><br><span class=\"line\"><span class=\"comment\">//隔一个搞一下</span></span><br><span class=\"line\"><span class=\"comment\">//输出</span></span><br><span class=\"line\"><span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"number\">2</span></span><br></pre></td></tr></table></figure>\n<p>如果不使用下标，可以更简单的遍历，有点像java中的增强for循环。</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span>(elem &lt;- b)&#123;</span><br><span class=\"line\">    println(elem)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3><span id=\"数组转换\"> 数组转换</span></h3>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (elem &lt;- b) <span class=\"keyword\">yield</span> elem</span><br><span class=\"line\"><span class=\"comment\">//b是一个ArrayBuffer，yield出来的结果也将会是一个ArrayBuffer</span></span><br><span class=\"line\"><span class=\"comment\">//如果b是一个Array，结果就会产生一个Array</span></span><br><span class=\"line\"><span class=\"keyword\">for</span>(i &lt;- <span class=\"number\">0</span> until <span class=\"number\">10</span>) <span class=\"keyword\">yield</span> i</span><br><span class=\"line\"><span class=\"comment\">//这样它会产生一个Vector(0, 1, 2, 3, 4, 5, 6, 7, 8, 9)</span></span><br></pre></td></tr></table></figure>\n<p>以上代码都会生成一个新的集合，原集合不变。其实在scala中，也可以这样来实现：</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">b.filter(_ % <span class=\"number\">2</span> == <span class=\"number\">0</span>).map(<span class=\"number\">2</span> * _)</span><br><span class=\"line\"><span class=\"comment\">//或</span></span><br><span class=\"line\">b filter &#123;_ % <span class=\"number\">2</span> == <span class=\"number\">0</span>&#125; map &#123;<span class=\"number\">2</span> * _&#125;</span><br></pre></td></tr></table></figure>\n<h3><span id=\"常用算法\"> 常用算法</span></h3>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">Array</span>(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span>).sum</span><br><span class=\"line\"><span class=\"type\">Array</span>(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span>).max</span><br></pre></td></tr></table></figure>\n<p>排序</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> b = <span class=\"type\">ArrayBuffer</span>(<span class=\"number\">1</span>, <span class=\"number\">7</span>, <span class=\"number\">2</span>, <span class=\"number\">9</span>)</span><br><span class=\"line\">b.sorted</span><br><span class=\"line\"><span class=\"comment\">//返回一个ArrayBuffer(1, 2, 7, 9)</span></span><br></pre></td></tr></table></figure>\n<p>也可以传入一个比较函数</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">b.sortWith(_ &lt; _)</span><br><span class=\"line\"><span class=\"comment\">//返回一个ArrayBuffer(9, 7, 2, 1)</span></span><br></pre></td></tr></table></figure>\n<p>对一个数组自身排序，（虽然b为val，但是它内部的元素是可以修改的）</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> b = <span class=\"type\">Array</span>(<span class=\"number\">1</span>, <span class=\"number\">7</span>, <span class=\"number\">2</span>, <span class=\"number\">9</span>)</span><br><span class=\"line\">util.<span class=\"type\">Sorting</span>.quickSort(b)</span><br><span class=\"line\"><span class=\"comment\">//b变成了Array(1, 2, 7, 9)</span></span><br></pre></td></tr></table></figure>\n<p>打印数组可以像python中的join方法一样（用分隔符输出），同时可以加前后缀</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">b.mkString(<span class=\"string\">\",\"</span>)</span><br><span class=\"line\"><span class=\"comment\">//加分隔符返回 String = 1,2,7,9</span></span><br><span class=\"line\"></span><br><span class=\"line\">b.mkString(<span class=\"string\">\"&lt;\"</span>,<span class=\"string\">\",\"</span>,<span class=\"string\">\"&gt;\"</span>)</span><br><span class=\"line\"><span class=\"comment\">//返回 String = &lt;1,2,7,9&gt;</span></span><br></pre></td></tr></table></figure>\n<p>ArrayBuffer（不是Array）的toString方法默认不会像java一样打些没用的东西，而是带有类似mkString的输出，打印出如下效果。</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> c = <span class=\"type\">ArrayBuffer</span>(<span class=\"number\">1</span>, <span class=\"number\">7</span>, <span class=\"number\">2</span>, <span class=\"number\">9</span>)</span><br><span class=\"line\">c.toString</span><br><span class=\"line\"><span class=\"comment\">//输出ArrayBuffer(1, 7, 2, 9)</span></span><br></pre></td></tr></table></figure>\n<h3><span id=\"多维数组\"> 多维数组</span></h3>\n<p>要构建一个Array[Array[Double]]，在scala中可以使用ofDim方法：</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> b = <span class=\"type\">Array</span>.ofDim[<span class=\"type\">Double</span>](<span class=\"number\">3</span>,<span class=\"number\">4</span>)<span class=\"comment\">//三行，四列</span></span><br><span class=\"line\"><span class=\"comment\">//输出b: Array[Array[Double]] = Array(Array(0.0, 0.0, 0.0, 0.0),Array(0.0, 0.0, 0.0, 0.0), Array(0.0, 0.0, 0.0, 0.0))</span></span><br><span class=\"line\">b(<span class=\"number\">2</span>)(<span class=\"number\">1</span>) = <span class=\"number\">1.111</span><span class=\"comment\">//下标为横2纵1（第3个数组中的第2个值）。</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>其实多维数组就是：数组的数组。所以每行长度都是可以自由定义来决定。</li>\n</ul>\n<h3><span id=\"和java相互转换\"> 和java相互转换</span></h3>\n<p>scala数组可以和java数组之间来回转换。请关注隐式转换那一章。</p>\n<h2><span id=\"习题\"> 习题</span></h2>\n<ul>\n<li>编写一段代码，将a设置为一个n个随机整数的数组，要求随机数介于0（包含）和n(不包含)之间。</li>\n</ul>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">randomArray</span></span>(n: <span class=\"type\">Int</span>): <span class=\"type\">Array</span>[<span class=\"type\">Int</span>] = &#123;</span><br><span class=\"line\">    <span class=\"keyword\">val</span> vector = <span class=\"keyword\">for</span> (i &lt;- <span class=\"number\">0</span> until n) <span class=\"keyword\">yield</span> scala.util.<span class=\"type\">Random</span>.nextInt(n)</span><br><span class=\"line\">    vector.toArray</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>编写一个循环，将整数数组中的相信元素对换，</li>\n</ul>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">switchNear</span></span>(arr: <span class=\"type\">Array</span>[<span class=\"type\">Int</span>]): <span class=\"type\">Array</span>[<span class=\"type\">Int</span>] = &#123;</span><br><span class=\"line\">  <span class=\"keyword\">val</span> t = arr.toBuffer</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (i &lt;- <span class=\"number\">1</span> until(t.length, <span class=\"number\">2</span>); tmp = t(i)) &#123;</span><br><span class=\"line\">    t(i) = t(i - <span class=\"number\">1</span>)</span><br><span class=\"line\">    t(i - <span class=\"number\">1</span>) = tmp</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  t.toArray</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>重复前一个练习，不过这一次生成一个新的值交换过的数组。用for/yield。</li>\n</ul>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">switchNear</span></span>(arr: <span class=\"type\">Array</span>[<span class=\"type\">Int</span>]): <span class=\"type\">Array</span>[<span class=\"type\">Int</span>] = &#123;</span><br><span class=\"line\">  <span class=\"keyword\">val</span> vector =</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i &lt;- <span class=\"number\">0</span> until arr.length; tmp = arr(i)) <span class=\"keyword\">yield</span> <span class=\"keyword\">if</span> (i % <span class=\"number\">2</span> == <span class=\"number\">0</span>) arr(i + <span class=\"number\">1</span>) <span class=\"keyword\">else</span> arr(i - <span class=\"number\">1</span>)</span><br><span class=\"line\">  vector.toArray</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>给定一个整数数组，产生一个新的数组，包含元数组中的所有正值，以原有顺序排列，之后的元素是所有零或负值，以原有顺序排列。</li>\n</ul>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">branchArray</span></span>(arr: <span class=\"type\">Array</span>[<span class=\"type\">Int</span>]): <span class=\"type\">Array</span>[<span class=\"type\">Int</span>] = &#123;</span><br><span class=\"line\">  <span class=\"keyword\">val</span> pre = <span class=\"type\">ArrayBuffer</span>[<span class=\"type\">Int</span>]()</span><br><span class=\"line\">  <span class=\"keyword\">val</span> last = <span class=\"type\">ArrayBuffer</span>[<span class=\"type\">Int</span>]()</span><br><span class=\"line\">  arr foreach (item =&gt; <span class=\"keyword\">if</span> (item &gt;= <span class=\"number\">0</span>) pre += item <span class=\"keyword\">else</span> last += item)</span><br><span class=\"line\">  pre ++= last.toArray</span><br><span class=\"line\">  pre.toArray</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//另一个方法</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">branchArray2</span></span>(arr: <span class=\"type\">Array</span>[<span class=\"type\">Int</span>]): <span class=\"type\">Array</span>[<span class=\"type\">Int</span>] = &#123;</span><br><span class=\"line\">  <span class=\"keyword\">val</span> all = <span class=\"type\">ArrayBuffer</span>[<span class=\"type\">Int</span>]()</span><br><span class=\"line\">  all ++= arr.filter(_ &gt;= <span class=\"number\">0</span>)</span><br><span class=\"line\">  all ++= arr.filter(_ &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">  all.toArray</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>如何计算Aarray[Double]的平均值？</li>\n</ul>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">avgArr</span></span>(arr: <span class=\"type\">Array</span>[<span class=\"type\">Double</span>]): <span class=\"type\">Double</span> = &#123;</span><br><span class=\"line\">  arr.sum / arr.length</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>如何将Array[Int]反序排列？对于ArrayBuffer[Int]你又会怎么做？</li>\n</ul>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">arr reverse</span><br><span class=\"line\">arr.toBuffer reverse</span><br></pre></td></tr></table></figure>\n<ul>\n<li>写一段代码，打印数组中的所有的值，并去掉重复项。（提示：查看Scaladoc）</li>\n</ul>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//arr: Array[Int] = Array(-2, -1, 0, 1, 2, 1, 2, 3, 4, -1)</span></span><br><span class=\"line\">arr distinct</span><br><span class=\"line\"><span class=\"comment\">//res116: Array[Int] = Array(-2, -1, 0, 1, 2, 3, 4)</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>收集一个数组的负值下标到一个数组，反序这个数组，再去掉它最后一个元素。然后对每个下标调用remove(i)。比较和之前做法的效率。</li>\n</ul>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span>(i &lt;- <span class=\"number\">0</span> until arr.length <span class=\"keyword\">if</span> arr(i)&lt;<span class=\"number\">0</span>) <span class=\"keyword\">yield</span> i</span><br><span class=\"line\">c.reverse.trimStart(<span class=\"number\">1</span>)</span><br><span class=\"line\"><span class=\"keyword\">val</span> d = arr.toBuffer</span><br><span class=\"line\">c.foreach(d.remove)</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"chapter-03-working-with-arrays\"><a class=\"markdownIt-Anchor\" href=\"#chapter-03-working-with-arrays\"></a> Chapter-03-working-with-arrays</h2>\n<p>数组</p>\n<hr>\n<h3 id=\"定长数组\"><a class=\"markdownIt-Anchor\" href=\"#定长数组\"></a> 定长数组</h3>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> nums = <span class=\"keyword\">new</span> <span class=\"type\">Array</span>[<span class=\"type\">Int</span>](<span class=\"number\">10</span>)</span><br><span class=\"line\"><span class=\"comment\">//初始化10整数的数组，所有元素初始化为0</span></span><br><span class=\"line\"><span class=\"keyword\">val</span> strs = <span class=\"keyword\">new</span> <span class=\"type\">Array</span>[<span class=\"type\">String</span>](<span class=\"number\">10</span>)</span><br><span class=\"line\"><span class=\"comment\">//10个值为null</span></span><br><span class=\"line\"><span class=\"keyword\">val</span> s = <span class=\"type\">Array</span>(<span class=\"string\">\"Hello\"</span>, <span class=\"string\">\"Allon\"</span>)</span><br><span class=\"line\"><span class=\"comment\">//Array对象的apply方法</span></span><br><span class=\"line\">s(<span class=\"number\">0</span>) = <span class=\"string\">\"Goodbye\"</span></span><br><span class=\"line\"><span class=\"comment\">//用圆括号</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"变长数组\"><a class=\"markdownIt-Anchor\" href=\"#变长数组\"></a> 变长数组</h3>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> scala.collection.mutable.<span class=\"type\">ArrayBuffer</span></span><br><span class=\"line\"><span class=\"keyword\">val</span> b = <span class=\"type\">ArrayBuffer</span>[<span class=\"type\">Int</span>]()</span><br><span class=\"line\"><span class=\"comment\">//一个空buffer</span></span><br><span class=\"line\">b += <span class=\"number\">1</span> </span><br><span class=\"line\"><span class=\"comment\">//相当于b.+=(ArrayBuffer(1))</span></span><br><span class=\"line\"><span class=\"comment\">//在结尾加一个元素</span></span><br><span class=\"line\">b += (<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>)</span><br><span class=\"line\"><span class=\"comment\">//在结尾加一坨元素，ArrayBuffer(1,2,3)</span></span><br><span class=\"line\">b ++= <span class=\"type\">Array</span>(<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>)</span><br><span class=\"line\"><span class=\"comment\">//在结尾加任何集合</span></span><br><span class=\"line\">b.trimEnd(<span class=\"number\">3</span>)</span><br><span class=\"line\"><span class=\"comment\">//移除最后3个元素，</span></span><br></pre></td></tr></table></figure>\n<p>在数组缓冲结尾追加和移除是高效的。也可以insert一些元素，后面的元素会顺移。</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">b.insert(<span class=\"number\">2</span>,<span class=\"number\">13</span>)</span><br><span class=\"line\"><span class=\"comment\">//输出(1, 1, 13, 2, 3)</span></span><br><span class=\"line\">b.insert(<span class=\"number\">2</span>,<span class=\"number\">31</span>,<span class=\"number\">32</span>,<span class=\"number\">33</span>)</span><br><span class=\"line\"><span class=\"comment\">//输出(1, 1, 31, 32, 33, 13, 2, 3)</span></span><br><span class=\"line\">b.remove(<span class=\"number\">2</span>)</span><br><span class=\"line\"><span class=\"comment\">//输出(1, 1, 32, 33, 13, 2, 3)</span></span><br><span class=\"line\">b.remove(<span class=\"number\">2</span>,<span class=\"number\">3</span>)</span><br><span class=\"line\"><span class=\"comment\">//输出(1, 1, 2, 3)，移除下标为2的起点共3个元素</span></span><br></pre></td></tr></table></figure>\n<p>一般来讲，可以先构建一个ArrayBuffer然后在buffer伸缩完成后再toArray。</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">b.toArray</span><br><span class=\"line\"><span class=\"comment\">//Array(1, 1, 2, 3)</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"遍历array和arraybuffer\"><a class=\"markdownIt-Anchor\" href=\"#遍历array和arraybuffer\"></a> 遍历Array和ArrayBuffer</h3>\n<p>常规遍历</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span>(i &lt;- <span class=\"number\">0</span> until (b.length, <span class=\"number\">2</span>)) println(b(i))</span><br><span class=\"line\"><span class=\"comment\">//隔一个搞一下</span></span><br><span class=\"line\"><span class=\"comment\">//输出</span></span><br><span class=\"line\"><span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"number\">2</span></span><br></pre></td></tr></table></figure>\n<p>如果不使用下标，可以更简单的遍历，有点像java中的增强for循环。</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span>(elem &lt;- b)&#123;</span><br><span class=\"line\">    println(elem)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"数组转换\"><a class=\"markdownIt-Anchor\" href=\"#数组转换\"></a> 数组转换</h3>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (elem &lt;- b) <span class=\"keyword\">yield</span> elem</span><br><span class=\"line\"><span class=\"comment\">//b是一个ArrayBuffer，yield出来的结果也将会是一个ArrayBuffer</span></span><br><span class=\"line\"><span class=\"comment\">//如果b是一个Array，结果就会产生一个Array</span></span><br><span class=\"line\"><span class=\"keyword\">for</span>(i &lt;- <span class=\"number\">0</span> until <span class=\"number\">10</span>) <span class=\"keyword\">yield</span> i</span><br><span class=\"line\"><span class=\"comment\">//这样它会产生一个Vector(0, 1, 2, 3, 4, 5, 6, 7, 8, 9)</span></span><br></pre></td></tr></table></figure>\n<p>以上代码都会生成一个新的集合，原集合不变。其实在scala中，也可以这样来实现：</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">b.filter(_ % <span class=\"number\">2</span> == <span class=\"number\">0</span>).map(<span class=\"number\">2</span> * _)</span><br><span class=\"line\"><span class=\"comment\">//或</span></span><br><span class=\"line\">b filter &#123;_ % <span class=\"number\">2</span> == <span class=\"number\">0</span>&#125; map &#123;<span class=\"number\">2</span> * _&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"常用算法\"><a class=\"markdownIt-Anchor\" href=\"#常用算法\"></a> 常用算法</h3>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">Array</span>(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span>).sum</span><br><span class=\"line\"><span class=\"type\">Array</span>(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span>).max</span><br></pre></td></tr></table></figure>\n<p>排序</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> b = <span class=\"type\">ArrayBuffer</span>(<span class=\"number\">1</span>, <span class=\"number\">7</span>, <span class=\"number\">2</span>, <span class=\"number\">9</span>)</span><br><span class=\"line\">b.sorted</span><br><span class=\"line\"><span class=\"comment\">//返回一个ArrayBuffer(1, 2, 7, 9)</span></span><br></pre></td></tr></table></figure>\n<p>也可以传入一个比较函数</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">b.sortWith(_ &lt; _)</span><br><span class=\"line\"><span class=\"comment\">//返回一个ArrayBuffer(9, 7, 2, 1)</span></span><br></pre></td></tr></table></figure>\n<p>对一个数组自身排序，（虽然b为val，但是它内部的元素是可以修改的）</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> b = <span class=\"type\">Array</span>(<span class=\"number\">1</span>, <span class=\"number\">7</span>, <span class=\"number\">2</span>, <span class=\"number\">9</span>)</span><br><span class=\"line\">util.<span class=\"type\">Sorting</span>.quickSort(b)</span><br><span class=\"line\"><span class=\"comment\">//b变成了Array(1, 2, 7, 9)</span></span><br></pre></td></tr></table></figure>\n<p>打印数组可以像python中的join方法一样（用分隔符输出），同时可以加前后缀</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">b.mkString(<span class=\"string\">\",\"</span>)</span><br><span class=\"line\"><span class=\"comment\">//加分隔符返回 String = 1,2,7,9</span></span><br><span class=\"line\"></span><br><span class=\"line\">b.mkString(<span class=\"string\">\"&lt;\"</span>,<span class=\"string\">\",\"</span>,<span class=\"string\">\"&gt;\"</span>)</span><br><span class=\"line\"><span class=\"comment\">//返回 String = &lt;1,2,7,9&gt;</span></span><br></pre></td></tr></table></figure>\n<p>ArrayBuffer（不是Array）的toString方法默认不会像java一样打些没用的东西，而是带有类似mkString的输出，打印出如下效果。</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> c = <span class=\"type\">ArrayBuffer</span>(<span class=\"number\">1</span>, <span class=\"number\">7</span>, <span class=\"number\">2</span>, <span class=\"number\">9</span>)</span><br><span class=\"line\">c.toString</span><br><span class=\"line\"><span class=\"comment\">//输出ArrayBuffer(1, 7, 2, 9)</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"多维数组\"><a class=\"markdownIt-Anchor\" href=\"#多维数组\"></a> 多维数组</h3>\n<p>要构建一个Array[Array[Double]]，在scala中可以使用ofDim方法：</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> b = <span class=\"type\">Array</span>.ofDim[<span class=\"type\">Double</span>](<span class=\"number\">3</span>,<span class=\"number\">4</span>)<span class=\"comment\">//三行，四列</span></span><br><span class=\"line\"><span class=\"comment\">//输出b: Array[Array[Double]] = Array(Array(0.0, 0.0, 0.0, 0.0),Array(0.0, 0.0, 0.0, 0.0), Array(0.0, 0.0, 0.0, 0.0))</span></span><br><span class=\"line\">b(<span class=\"number\">2</span>)(<span class=\"number\">1</span>) = <span class=\"number\">1.111</span><span class=\"comment\">//下标为横2纵1（第3个数组中的第2个值）。</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>其实多维数组就是：数组的数组。所以每行长度都是可以自由定义来决定。</li>\n</ul>\n<h3 id=\"和java相互转换\"><a class=\"markdownIt-Anchor\" href=\"#和java相互转换\"></a> 和java相互转换</h3>\n<p>scala数组可以和java数组之间来回转换。请关注隐式转换那一章。</p>\n<h2 id=\"习题\"><a class=\"markdownIt-Anchor\" href=\"#习题\"></a> 习题</h2>\n<ul>\n<li>编写一段代码，将a设置为一个n个随机整数的数组，要求随机数介于0（包含）和n(不包含)之间。</li>\n</ul>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">randomArray</span></span>(n: <span class=\"type\">Int</span>): <span class=\"type\">Array</span>[<span class=\"type\">Int</span>] = &#123;</span><br><span class=\"line\">    <span class=\"keyword\">val</span> vector = <span class=\"keyword\">for</span> (i &lt;- <span class=\"number\">0</span> until n) <span class=\"keyword\">yield</span> scala.util.<span class=\"type\">Random</span>.nextInt(n)</span><br><span class=\"line\">    vector.toArray</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>编写一个循环，将整数数组中的相信元素对换，</li>\n</ul>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">switchNear</span></span>(arr: <span class=\"type\">Array</span>[<span class=\"type\">Int</span>]): <span class=\"type\">Array</span>[<span class=\"type\">Int</span>] = &#123;</span><br><span class=\"line\">  <span class=\"keyword\">val</span> t = arr.toBuffer</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (i &lt;- <span class=\"number\">1</span> until(t.length, <span class=\"number\">2</span>); tmp = t(i)) &#123;</span><br><span class=\"line\">    t(i) = t(i - <span class=\"number\">1</span>)</span><br><span class=\"line\">    t(i - <span class=\"number\">1</span>) = tmp</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  t.toArray</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>重复前一个练习，不过这一次生成一个新的值交换过的数组。用for/yield。</li>\n</ul>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">switchNear</span></span>(arr: <span class=\"type\">Array</span>[<span class=\"type\">Int</span>]): <span class=\"type\">Array</span>[<span class=\"type\">Int</span>] = &#123;</span><br><span class=\"line\">  <span class=\"keyword\">val</span> vector =</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i &lt;- <span class=\"number\">0</span> until arr.length; tmp = arr(i)) <span class=\"keyword\">yield</span> <span class=\"keyword\">if</span> (i % <span class=\"number\">2</span> == <span class=\"number\">0</span>) arr(i + <span class=\"number\">1</span>) <span class=\"keyword\">else</span> arr(i - <span class=\"number\">1</span>)</span><br><span class=\"line\">  vector.toArray</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>给定一个整数数组，产生一个新的数组，包含元数组中的所有正值，以原有顺序排列，之后的元素是所有零或负值，以原有顺序排列。</li>\n</ul>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">branchArray</span></span>(arr: <span class=\"type\">Array</span>[<span class=\"type\">Int</span>]): <span class=\"type\">Array</span>[<span class=\"type\">Int</span>] = &#123;</span><br><span class=\"line\">  <span class=\"keyword\">val</span> pre = <span class=\"type\">ArrayBuffer</span>[<span class=\"type\">Int</span>]()</span><br><span class=\"line\">  <span class=\"keyword\">val</span> last = <span class=\"type\">ArrayBuffer</span>[<span class=\"type\">Int</span>]()</span><br><span class=\"line\">  arr foreach (item =&gt; <span class=\"keyword\">if</span> (item &gt;= <span class=\"number\">0</span>) pre += item <span class=\"keyword\">else</span> last += item)</span><br><span class=\"line\">  pre ++= last.toArray</span><br><span class=\"line\">  pre.toArray</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//另一个方法</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">branchArray2</span></span>(arr: <span class=\"type\">Array</span>[<span class=\"type\">Int</span>]): <span class=\"type\">Array</span>[<span class=\"type\">Int</span>] = &#123;</span><br><span class=\"line\">  <span class=\"keyword\">val</span> all = <span class=\"type\">ArrayBuffer</span>[<span class=\"type\">Int</span>]()</span><br><span class=\"line\">  all ++= arr.filter(_ &gt;= <span class=\"number\">0</span>)</span><br><span class=\"line\">  all ++= arr.filter(_ &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">  all.toArray</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>如何计算Aarray[Double]的平均值？</li>\n</ul>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">avgArr</span></span>(arr: <span class=\"type\">Array</span>[<span class=\"type\">Double</span>]): <span class=\"type\">Double</span> = &#123;</span><br><span class=\"line\">  arr.sum / arr.length</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>如何将Array[Int]反序排列？对于ArrayBuffer[Int]你又会怎么做？</li>\n</ul>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">arr reverse</span><br><span class=\"line\">arr.toBuffer reverse</span><br></pre></td></tr></table></figure>\n<ul>\n<li>写一段代码，打印数组中的所有的值，并去掉重复项。（提示：查看Scaladoc）</li>\n</ul>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//arr: Array[Int] = Array(-2, -1, 0, 1, 2, 1, 2, 3, 4, -1)</span></span><br><span class=\"line\">arr distinct</span><br><span class=\"line\"><span class=\"comment\">//res116: Array[Int] = Array(-2, -1, 0, 1, 2, 3, 4)</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>收集一个数组的负值下标到一个数组，反序这个数组，再去掉它最后一个元素。然后对每个下标调用remove(i)。比较和之前做法的效率。</li>\n</ul>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span>(i &lt;- <span class=\"number\">0</span> until arr.length <span class=\"keyword\">if</span> arr(i)&lt;<span class=\"number\">0</span>) <span class=\"keyword\">yield</span> i</span><br><span class=\"line\">c.reverse.trimStart(<span class=\"number\">1</span>)</span><br><span class=\"line\"><span class=\"keyword\">val</span> d = arr.toBuffer</span><br><span class=\"line\">c.foreach(d.remove)</span><br></pre></td></tr></table></figure>\n"},{"title":"Chapter-04-Map和元组","catalog":true,"date":"2015-06-22T09:21:29.000Z","header-img":"/img/04.jpg","_content":"\n## Chapter-04-Map和元组\n\nMap 映射 元组\n\n---\n\n### 创建Map并取值\nscala中的Map可以非常直观的创建，下面是创建一个不可变的Map\n\n\n```scala\nval map = Map(\"Allon\" -> 29, \"Jerry\" -> 18, \"Karen\" -> 54 )\nmap(\"Allon\")\n//返回29\nmap(\"Allon\") = 30\n//会报错，因为这个Map默认为collection.immutable.Map的不可变Map。不能修改，也不能添加元素。\n```\n上面的map是不可以被修改的，如果想要一个可变的Map可以用\n\n\n```scala\nval map = collection.mutable.Map(\"Allon\" -> 29, \"Jerry\" -> 18, \"Karen\" -> 54 )\nmap(\"Allon\") = 99\n//可以修改成功\n```\n操作符 \"->\" 也可以换成逗号。\n\nmap取值比较简单，就像上面一样。不过如果map中不存在对应的key，会抛错。这时我们可以用contains方法检查是否包含key。\n\n\n```scala\nif(map.contains(\"XXX\")) map(\"XXX\") else 0\n```\n上面的写法有些麻烦，更常用的是：\n\n\n```scala\nval value1 = map.getOrElse(\"Allon\",0)\n```\n像java中一样，map是有get方法的。它的返回是Option类的子类，要么是Some，要么是None。在模式匹配那章会具体讲Option类。\n\n\n```scala\nmap.get(\"Allon\")\n//返回 Option[Int] = Some(99)\n```\n\n### 更新Map中的值\n\n\n```scala\nval map = collection.mutable.Map(\"Allon\" -> 29, \"Jerry\" -> 18, \"Karen\" -> 54 )\nmap +=  (\"Bob\" -> 63) \n//Map(Karen -> 54, Bob -> 63, Allon -> 29, Jerry -> 18)\n```\n如果更新过程中，不存在key，那么它会自动添加\n\n\n```scala\nmap(\"Koran\") = 77 \n//Map(Karen -> 54, Bob -> 63, Allon -> 29, Jerry -> 18, Koran -> 77)\n```\n删除，如果不存在该key，就当没发生。\n\n\n```scala\nmap -= \"Koran\"\n//Map(Karen -> 54, Bob -> 63, Allon -> 29, Jerry -> 18)\n```\n不能更新一个不可变Map，但是可以把它追加到其他Map上。\n\n*   累加过程中遇到冲突元素会update。\n*   不管是不是可变Map都支持这种操作。\n*   写法只能如下这么写，不可以直接两个Map直接相加。\n\n```scala\nmap + (\"Iresb\" -> 43,\"Karen\" -> 12)\n//Map(Karen -> 12, Allon -> 29, Bob -> 63, Iresb -> 43, Jerry -> 18)\n```\n也可以\n\n```scala\nvar map = collection.immutable.Map(\"Iresb\" -> 43,\"Karen\" -> 12)\nmap = map + (\"Abc\" -> 43,\"Kkk\" -> 12)\n```\n\n### 遍历Map和有序Map\n\n```scala\nfor((k, v) <- map) println(\"key:\" + k +\", \"+ \"value:\"+ v)\nmap.keyset //Set(Iresb, Karen, Abc, Kkk)\nmap.values //MapLike(43, 12, 43, 12)\nfor((k, v) <- map) yield (v, k)//对调k和v\n```\nscala中没有可变的tree map，下面两种是scala中的有序map。\n\n```scala\nval map = collection.immutable.SortedMap(\"Allon\" -> 29, \"Jerry\" -> 18, \"Karen\" -> 54 ) //基于平衡树实现的有序map。它是不可变的！\n\nval map = collection.immutable.LinkedHashMap(\"Allon\" -> 29, \"Jerry\" -> 18, \"Karen\" -> 54 ) //基于链表实现的有序map，顺序卽为插入顺序 \n```\n\n### 与java的互操作\nscala中没有可变tree map，我们可以使用java的API，从而把java的转成scala的map。\n\n```scala\nimport collection.JavaConversions.mapAsScalaMap\n\nval map = new java.util.TreeMap[String, Int]\nmap.put(\"Jerry\",18)\nmap += (\"Jerry\"->18)// 相当于\"map.+=(k -> v)\"，返回一个scala的map。从java的TreeMap直接返回scala的map，经历了一次“偷偷”（隐式）转换。\n\nval map: collection.mutable.Map[String, Int] = new java.util.TreeMap[String, Int]\n//经过修改后，再转换scala的普通map\n```\n除此之外，scala还可以从java.util.Properties转成scala的Map\n\n```scala\nimport collection.JavaConversions.propertiesAsScalaMap\nval props : collection.Map[String, String] = System.getProperties()\n```\n也可以相反的转换，把scala的Map给java的API用。\n\n```scala\nimport collection.JavaConversions.mapAsJavaMap\nimport java.awt.font.TextAttribute._ //引入java相关的枚举key\n\nval attrs = Map(FAMILY -> \"Serif\", SIZE -> 12) //scala的Map\nval font = new java.awt.Font(attrs) //该方法入参是一个Java的Map，这里其实是“偷偷”把attrs转成了java的Map。\n```\n### Tuple (元组)\n元组是不同类型的值的聚集；K->V是最简单的元组。它和数组的区别是：\n>* 元组内的元素不能修改。\n>* 元组为不同类型的数据聚集。\n>* 访问从1开始，而不是0。\n\n元组的定义和使用非常简单\n\n```scala\nval tuple1 = (1, 3.14, \"Fred\")\n// 本质上就是一个：val tuple1 = Tuple3[Int, Double, java.lang.String](1, 3.14, \"Fred\")\ntuple1._2 //第二个元素，首个元素为1不是0。\ntuple1 _2 //两种写都可以，只要别写成tuple1_2就可以了\n```\n\n一般，元组的元素用模式匹配来获取（后面一章会讲模式匹配）\n\n```scala\nval (first, second, third) = t\n/*\nfirst: Int = 1\nsecond: Double = 3.14\nthird: String = Fred\n*/\n\n//如果只需要部分元素可以用“_”省略\nval (first, second, _) = t\nfirst: Int = 1\nsecond: Double = 3.14\n/*\nfirst: Int = 1\nsecond: Double = 3.14\n*/\n```\n\n元组可以用在有多个返回结果的函数上。如：\n\n```scala\n\"New York\".partition(_.isUpper)\n// 返回(\"NY\",\"ew ork\"),分别是满足和不满足条件的字符。\n```\n\n### 拉链操作\n\n```scala\nval symbols = Array(\"<\", \"-\", \">\")\nval counts = Array(2, 10, 2)\nval pairs = symbols.zip(counts)\n//输出Array((<,2), (-,10), (>,2))\nval map = pairs.toMap //变为一个Map\n//输出Map(\"<\" -> 2, \"-\" -> 10, \">\" -> 2)\n```\n\n\n","source":"_posts/Chapter-04-Map和元组.md","raw":"---\ntitle: 'Chapter-04-Map和元组'\ncatalog: true\ndate: 2015-06-22 17:21:29\nheader-img: \"/img/04.jpg\"\ntags: \"scala\"\n---\n\n## Chapter-04-Map和元组\n\nMap 映射 元组\n\n---\n\n### 创建Map并取值\nscala中的Map可以非常直观的创建，下面是创建一个不可变的Map\n\n\n```scala\nval map = Map(\"Allon\" -> 29, \"Jerry\" -> 18, \"Karen\" -> 54 )\nmap(\"Allon\")\n//返回29\nmap(\"Allon\") = 30\n//会报错，因为这个Map默认为collection.immutable.Map的不可变Map。不能修改，也不能添加元素。\n```\n上面的map是不可以被修改的，如果想要一个可变的Map可以用\n\n\n```scala\nval map = collection.mutable.Map(\"Allon\" -> 29, \"Jerry\" -> 18, \"Karen\" -> 54 )\nmap(\"Allon\") = 99\n//可以修改成功\n```\n操作符 \"->\" 也可以换成逗号。\n\nmap取值比较简单，就像上面一样。不过如果map中不存在对应的key，会抛错。这时我们可以用contains方法检查是否包含key。\n\n\n```scala\nif(map.contains(\"XXX\")) map(\"XXX\") else 0\n```\n上面的写法有些麻烦，更常用的是：\n\n\n```scala\nval value1 = map.getOrElse(\"Allon\",0)\n```\n像java中一样，map是有get方法的。它的返回是Option类的子类，要么是Some，要么是None。在模式匹配那章会具体讲Option类。\n\n\n```scala\nmap.get(\"Allon\")\n//返回 Option[Int] = Some(99)\n```\n\n### 更新Map中的值\n\n\n```scala\nval map = collection.mutable.Map(\"Allon\" -> 29, \"Jerry\" -> 18, \"Karen\" -> 54 )\nmap +=  (\"Bob\" -> 63) \n//Map(Karen -> 54, Bob -> 63, Allon -> 29, Jerry -> 18)\n```\n如果更新过程中，不存在key，那么它会自动添加\n\n\n```scala\nmap(\"Koran\") = 77 \n//Map(Karen -> 54, Bob -> 63, Allon -> 29, Jerry -> 18, Koran -> 77)\n```\n删除，如果不存在该key，就当没发生。\n\n\n```scala\nmap -= \"Koran\"\n//Map(Karen -> 54, Bob -> 63, Allon -> 29, Jerry -> 18)\n```\n不能更新一个不可变Map，但是可以把它追加到其他Map上。\n\n*   累加过程中遇到冲突元素会update。\n*   不管是不是可变Map都支持这种操作。\n*   写法只能如下这么写，不可以直接两个Map直接相加。\n\n```scala\nmap + (\"Iresb\" -> 43,\"Karen\" -> 12)\n//Map(Karen -> 12, Allon -> 29, Bob -> 63, Iresb -> 43, Jerry -> 18)\n```\n也可以\n\n```scala\nvar map = collection.immutable.Map(\"Iresb\" -> 43,\"Karen\" -> 12)\nmap = map + (\"Abc\" -> 43,\"Kkk\" -> 12)\n```\n\n### 遍历Map和有序Map\n\n```scala\nfor((k, v) <- map) println(\"key:\" + k +\", \"+ \"value:\"+ v)\nmap.keyset //Set(Iresb, Karen, Abc, Kkk)\nmap.values //MapLike(43, 12, 43, 12)\nfor((k, v) <- map) yield (v, k)//对调k和v\n```\nscala中没有可变的tree map，下面两种是scala中的有序map。\n\n```scala\nval map = collection.immutable.SortedMap(\"Allon\" -> 29, \"Jerry\" -> 18, \"Karen\" -> 54 ) //基于平衡树实现的有序map。它是不可变的！\n\nval map = collection.immutable.LinkedHashMap(\"Allon\" -> 29, \"Jerry\" -> 18, \"Karen\" -> 54 ) //基于链表实现的有序map，顺序卽为插入顺序 \n```\n\n### 与java的互操作\nscala中没有可变tree map，我们可以使用java的API，从而把java的转成scala的map。\n\n```scala\nimport collection.JavaConversions.mapAsScalaMap\n\nval map = new java.util.TreeMap[String, Int]\nmap.put(\"Jerry\",18)\nmap += (\"Jerry\"->18)// 相当于\"map.+=(k -> v)\"，返回一个scala的map。从java的TreeMap直接返回scala的map，经历了一次“偷偷”（隐式）转换。\n\nval map: collection.mutable.Map[String, Int] = new java.util.TreeMap[String, Int]\n//经过修改后，再转换scala的普通map\n```\n除此之外，scala还可以从java.util.Properties转成scala的Map\n\n```scala\nimport collection.JavaConversions.propertiesAsScalaMap\nval props : collection.Map[String, String] = System.getProperties()\n```\n也可以相反的转换，把scala的Map给java的API用。\n\n```scala\nimport collection.JavaConversions.mapAsJavaMap\nimport java.awt.font.TextAttribute._ //引入java相关的枚举key\n\nval attrs = Map(FAMILY -> \"Serif\", SIZE -> 12) //scala的Map\nval font = new java.awt.Font(attrs) //该方法入参是一个Java的Map，这里其实是“偷偷”把attrs转成了java的Map。\n```\n### Tuple (元组)\n元组是不同类型的值的聚集；K->V是最简单的元组。它和数组的区别是：\n>* 元组内的元素不能修改。\n>* 元组为不同类型的数据聚集。\n>* 访问从1开始，而不是0。\n\n元组的定义和使用非常简单\n\n```scala\nval tuple1 = (1, 3.14, \"Fred\")\n// 本质上就是一个：val tuple1 = Tuple3[Int, Double, java.lang.String](1, 3.14, \"Fred\")\ntuple1._2 //第二个元素，首个元素为1不是0。\ntuple1 _2 //两种写都可以，只要别写成tuple1_2就可以了\n```\n\n一般，元组的元素用模式匹配来获取（后面一章会讲模式匹配）\n\n```scala\nval (first, second, third) = t\n/*\nfirst: Int = 1\nsecond: Double = 3.14\nthird: String = Fred\n*/\n\n//如果只需要部分元素可以用“_”省略\nval (first, second, _) = t\nfirst: Int = 1\nsecond: Double = 3.14\n/*\nfirst: Int = 1\nsecond: Double = 3.14\n*/\n```\n\n元组可以用在有多个返回结果的函数上。如：\n\n```scala\n\"New York\".partition(_.isUpper)\n// 返回(\"NY\",\"ew ork\"),分别是满足和不满足条件的字符。\n```\n\n### 拉链操作\n\n```scala\nval symbols = Array(\"<\", \"-\", \">\")\nval counts = Array(2, 10, 2)\nval pairs = symbols.zip(counts)\n//输出Array((<,2), (-,10), (>,2))\nval map = pairs.toMap //变为一个Map\n//输出Map(\"<\" -> 2, \"-\" -> 10, \">\" -> 2)\n```\n\n\n","slug":"Chapter-04-Map和元组","published":1,"updated":"2017-11-25T06:28:50.495Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjahvvnx40007pv4njiwqtv30","content":"<h2><span id=\"chapter-04-map和元组\"> Chapter-04-Map和元组</span></h2>\n<p>Map 映射 元组</p>\n<hr>\n<h3><span id=\"创建map并取值\"> 创建Map并取值</span></h3>\n<p>scala中的Map可以非常直观的创建，下面是创建一个不可变的Map</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> map = <span class=\"type\">Map</span>(<span class=\"string\">\"Allon\"</span> -&gt; <span class=\"number\">29</span>, <span class=\"string\">\"Jerry\"</span> -&gt; <span class=\"number\">18</span>, <span class=\"string\">\"Karen\"</span> -&gt; <span class=\"number\">54</span> )</span><br><span class=\"line\">map(<span class=\"string\">\"Allon\"</span>)</span><br><span class=\"line\"><span class=\"comment\">//返回29</span></span><br><span class=\"line\">map(<span class=\"string\">\"Allon\"</span>) = <span class=\"number\">30</span></span><br><span class=\"line\"><span class=\"comment\">//会报错，因为这个Map默认为collection.immutable.Map的不可变Map。不能修改，也不能添加元素。</span></span><br></pre></td></tr></table></figure>\n<p>上面的map是不可以被修改的，如果想要一个可变的Map可以用</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> map = collection.mutable.<span class=\"type\">Map</span>(<span class=\"string\">\"Allon\"</span> -&gt; <span class=\"number\">29</span>, <span class=\"string\">\"Jerry\"</span> -&gt; <span class=\"number\">18</span>, <span class=\"string\">\"Karen\"</span> -&gt; <span class=\"number\">54</span> )</span><br><span class=\"line\">map(<span class=\"string\">\"Allon\"</span>) = <span class=\"number\">99</span></span><br><span class=\"line\"><span class=\"comment\">//可以修改成功</span></span><br></pre></td></tr></table></figure>\n<p>操作符 “-&gt;” 也可以换成逗号。</p>\n<p>map取值比较简单，就像上面一样。不过如果map中不存在对应的key，会抛错。这时我们可以用contains方法检查是否包含key。</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span>(map.contains(<span class=\"string\">\"XXX\"</span>)) map(<span class=\"string\">\"XXX\"</span>) <span class=\"keyword\">else</span> <span class=\"number\">0</span></span><br></pre></td></tr></table></figure>\n<p>上面的写法有些麻烦，更常用的是：</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> value1 = map.getOrElse(<span class=\"string\">\"Allon\"</span>,<span class=\"number\">0</span>)</span><br></pre></td></tr></table></figure>\n<p>像java中一样，map是有get方法的。它的返回是Option类的子类，要么是Some，要么是None。在模式匹配那章会具体讲Option类。</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">map.get(<span class=\"string\">\"Allon\"</span>)</span><br><span class=\"line\"><span class=\"comment\">//返回 Option[Int] = Some(99)</span></span><br></pre></td></tr></table></figure>\n<h3><span id=\"更新map中的值\"> 更新Map中的值</span></h3>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> map = collection.mutable.<span class=\"type\">Map</span>(<span class=\"string\">\"Allon\"</span> -&gt; <span class=\"number\">29</span>, <span class=\"string\">\"Jerry\"</span> -&gt; <span class=\"number\">18</span>, <span class=\"string\">\"Karen\"</span> -&gt; <span class=\"number\">54</span> )</span><br><span class=\"line\">map +=  (<span class=\"string\">\"Bob\"</span> -&gt; <span class=\"number\">63</span>) </span><br><span class=\"line\"><span class=\"comment\">//Map(Karen -&gt; 54, Bob -&gt; 63, Allon -&gt; 29, Jerry -&gt; 18)</span></span><br></pre></td></tr></table></figure>\n<p>如果更新过程中，不存在key，那么它会自动添加</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">map(<span class=\"string\">\"Koran\"</span>) = <span class=\"number\">77</span> </span><br><span class=\"line\"><span class=\"comment\">//Map(Karen -&gt; 54, Bob -&gt; 63, Allon -&gt; 29, Jerry -&gt; 18, Koran -&gt; 77)</span></span><br></pre></td></tr></table></figure>\n<p>删除，如果不存在该key，就当没发生。</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">map -= <span class=\"string\">\"Koran\"</span></span><br><span class=\"line\"><span class=\"comment\">//Map(Karen -&gt; 54, Bob -&gt; 63, Allon -&gt; 29, Jerry -&gt; 18)</span></span><br></pre></td></tr></table></figure>\n<p>不能更新一个不可变Map，但是可以把它追加到其他Map上。</p>\n<ul>\n<li>累加过程中遇到冲突元素会update。</li>\n<li>不管是不是可变Map都支持这种操作。</li>\n<li>写法只能如下这么写，不可以直接两个Map直接相加。</li>\n</ul>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">map + (<span class=\"string\">\"Iresb\"</span> -&gt; <span class=\"number\">43</span>,<span class=\"string\">\"Karen\"</span> -&gt; <span class=\"number\">12</span>)</span><br><span class=\"line\"><span class=\"comment\">//Map(Karen -&gt; 12, Allon -&gt; 29, Bob -&gt; 63, Iresb -&gt; 43, Jerry -&gt; 18)</span></span><br></pre></td></tr></table></figure>\n<p>也可以</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> map = collection.immutable.<span class=\"type\">Map</span>(<span class=\"string\">\"Iresb\"</span> -&gt; <span class=\"number\">43</span>,<span class=\"string\">\"Karen\"</span> -&gt; <span class=\"number\">12</span>)</span><br><span class=\"line\">map = map + (<span class=\"string\">\"Abc\"</span> -&gt; <span class=\"number\">43</span>,<span class=\"string\">\"Kkk\"</span> -&gt; <span class=\"number\">12</span>)</span><br></pre></td></tr></table></figure>\n<h3><span id=\"遍历map和有序map\"> 遍历Map和有序Map</span></h3>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span>((k, v) &lt;- map) println(<span class=\"string\">\"key:\"</span> + k +<span class=\"string\">\", \"</span>+ <span class=\"string\">\"value:\"</span>+ v)</span><br><span class=\"line\">map.keyset <span class=\"comment\">//Set(Iresb, Karen, Abc, Kkk)</span></span><br><span class=\"line\">map.values <span class=\"comment\">//MapLike(43, 12, 43, 12)</span></span><br><span class=\"line\"><span class=\"keyword\">for</span>((k, v) &lt;- map) <span class=\"keyword\">yield</span> (v, k)<span class=\"comment\">//对调k和v</span></span><br></pre></td></tr></table></figure>\n<p>scala中没有可变的tree map，下面两种是scala中的有序map。</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> map = collection.immutable.<span class=\"type\">SortedMap</span>(<span class=\"string\">\"Allon\"</span> -&gt; <span class=\"number\">29</span>, <span class=\"string\">\"Jerry\"</span> -&gt; <span class=\"number\">18</span>, <span class=\"string\">\"Karen\"</span> -&gt; <span class=\"number\">54</span> ) <span class=\"comment\">//基于平衡树实现的有序map。它是不可变的！</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">val</span> map = collection.immutable.<span class=\"type\">LinkedHashMap</span>(<span class=\"string\">\"Allon\"</span> -&gt; <span class=\"number\">29</span>, <span class=\"string\">\"Jerry\"</span> -&gt; <span class=\"number\">18</span>, <span class=\"string\">\"Karen\"</span> -&gt; <span class=\"number\">54</span> ) <span class=\"comment\">//基于链表实现的有序map，顺序卽为插入顺序</span></span><br></pre></td></tr></table></figure>\n<h3><span id=\"与java的互操作\"> 与java的互操作</span></h3>\n<p>scala中没有可变tree map，我们可以使用java的API，从而把java的转成scala的map。</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> collection.<span class=\"type\">JavaConversions</span>.mapAsScalaMap</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">val</span> map = <span class=\"keyword\">new</span> java.util.<span class=\"type\">TreeMap</span>[<span class=\"type\">String</span>, <span class=\"type\">Int</span>]</span><br><span class=\"line\">map.put(<span class=\"string\">\"Jerry\"</span>,<span class=\"number\">18</span>)</span><br><span class=\"line\">map += (<span class=\"string\">\"Jerry\"</span>-&gt;<span class=\"number\">18</span>)<span class=\"comment\">// 相当于\"map.+=(k -&gt; v)\"，返回一个scala的map。从java的TreeMap直接返回scala的map，经历了一次“偷偷”（隐式）转换。</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">val</span> map: collection.mutable.<span class=\"type\">Map</span>[<span class=\"type\">String</span>, <span class=\"type\">Int</span>] = <span class=\"keyword\">new</span> java.util.<span class=\"type\">TreeMap</span>[<span class=\"type\">String</span>, <span class=\"type\">Int</span>]</span><br><span class=\"line\"><span class=\"comment\">//经过修改后，再转换scala的普通map</span></span><br></pre></td></tr></table></figure>\n<p>除此之外，scala还可以从java.util.Properties转成scala的Map</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> collection.<span class=\"type\">JavaConversions</span>.propertiesAsScalaMap</span><br><span class=\"line\"><span class=\"keyword\">val</span> props : collection.<span class=\"type\">Map</span>[<span class=\"type\">String</span>, <span class=\"type\">String</span>] = <span class=\"type\">System</span>.getProperties()</span><br></pre></td></tr></table></figure>\n<p>也可以相反的转换，把scala的Map给java的API用。</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> collection.<span class=\"type\">JavaConversions</span>.mapAsJavaMap</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.awt.font.<span class=\"type\">TextAttribute</span>._ <span class=\"comment\">//引入java相关的枚举key</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">val</span> attrs = <span class=\"type\">Map</span>(<span class=\"type\">FAMILY</span> -&gt; <span class=\"string\">\"Serif\"</span>, <span class=\"type\">SIZE</span> -&gt; <span class=\"number\">12</span>) <span class=\"comment\">//scala的Map</span></span><br><span class=\"line\"><span class=\"keyword\">val</span> font = <span class=\"keyword\">new</span> java.awt.<span class=\"type\">Font</span>(attrs) <span class=\"comment\">//该方法入参是一个Java的Map，这里其实是“偷偷”把attrs转成了java的Map。</span></span><br></pre></td></tr></table></figure>\n<h3><span id=\"tuple-元组\"> Tuple (元组)</span></h3>\n<p>元组是不同类型的值的聚集；K-&gt;V是最简单的元组。它和数组的区别是：</p>\n<blockquote>\n<ul>\n<li>元组内的元素不能修改。</li>\n<li>元组为不同类型的数据聚集。</li>\n<li>访问从1开始，而不是0。</li>\n</ul>\n</blockquote>\n<p>元组的定义和使用非常简单</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> tuple1 = (<span class=\"number\">1</span>, <span class=\"number\">3.14</span>, <span class=\"string\">\"Fred\"</span>)</span><br><span class=\"line\"><span class=\"comment\">// 本质上就是一个：val tuple1 = Tuple3[Int, Double, java.lang.String](1, 3.14, \"Fred\")</span></span><br><span class=\"line\">tuple1._2 <span class=\"comment\">//第二个元素，首个元素为1不是0。</span></span><br><span class=\"line\">tuple1 _2 <span class=\"comment\">//两种写都可以，只要别写成tuple1_2就可以了</span></span><br></pre></td></tr></table></figure>\n<p>一般，元组的元素用模式匹配来获取（后面一章会讲模式匹配）</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> (first, second, third) = t</span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">first: Int = 1</span></span><br><span class=\"line\"><span class=\"comment\">second: Double = 3.14</span></span><br><span class=\"line\"><span class=\"comment\">third: String = Fred</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//如果只需要部分元素可以用“_”省略</span></span><br><span class=\"line\"><span class=\"keyword\">val</span> (first, second, _) = t</span><br><span class=\"line\">first: <span class=\"type\">Int</span> = <span class=\"number\">1</span></span><br><span class=\"line\">second: <span class=\"type\">Double</span> = <span class=\"number\">3.14</span></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">first: Int = 1</span></span><br><span class=\"line\"><span class=\"comment\">second: Double = 3.14</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br></pre></td></tr></table></figure>\n<p>元组可以用在有多个返回结果的函数上。如：</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">\"New York\"</span>.partition(_.isUpper)</span><br><span class=\"line\"><span class=\"comment\">// 返回(\"NY\",\"ew ork\"),分别是满足和不满足条件的字符。</span></span><br></pre></td></tr></table></figure>\n<h3><span id=\"拉链操作\"> 拉链操作</span></h3>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> symbols = <span class=\"type\">Array</span>(<span class=\"string\">\"&lt;\"</span>, <span class=\"string\">\"-\"</span>, <span class=\"string\">\"&gt;\"</span>)</span><br><span class=\"line\"><span class=\"keyword\">val</span> counts = <span class=\"type\">Array</span>(<span class=\"number\">2</span>, <span class=\"number\">10</span>, <span class=\"number\">2</span>)</span><br><span class=\"line\"><span class=\"keyword\">val</span> pairs = symbols.zip(counts)</span><br><span class=\"line\"><span class=\"comment\">//输出Array((&lt;,2), (-,10), (&gt;,2))</span></span><br><span class=\"line\"><span class=\"keyword\">val</span> map = pairs.toMap <span class=\"comment\">//变为一个Map</span></span><br><span class=\"line\"><span class=\"comment\">//输出Map(\"&lt;\" -&gt; 2, \"-\" -&gt; 10, \"&gt;\" -&gt; 2)</span></span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"chapter-04-map和元组\"><a class=\"markdownIt-Anchor\" href=\"#chapter-04-map和元组\"></a> Chapter-04-Map和元组</h2>\n<p>Map 映射 元组</p>\n<hr>\n<h3 id=\"创建map并取值\"><a class=\"markdownIt-Anchor\" href=\"#创建map并取值\"></a> 创建Map并取值</h3>\n<p>scala中的Map可以非常直观的创建，下面是创建一个不可变的Map</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> map = <span class=\"type\">Map</span>(<span class=\"string\">\"Allon\"</span> -&gt; <span class=\"number\">29</span>, <span class=\"string\">\"Jerry\"</span> -&gt; <span class=\"number\">18</span>, <span class=\"string\">\"Karen\"</span> -&gt; <span class=\"number\">54</span> )</span><br><span class=\"line\">map(<span class=\"string\">\"Allon\"</span>)</span><br><span class=\"line\"><span class=\"comment\">//返回29</span></span><br><span class=\"line\">map(<span class=\"string\">\"Allon\"</span>) = <span class=\"number\">30</span></span><br><span class=\"line\"><span class=\"comment\">//会报错，因为这个Map默认为collection.immutable.Map的不可变Map。不能修改，也不能添加元素。</span></span><br></pre></td></tr></table></figure>\n<p>上面的map是不可以被修改的，如果想要一个可变的Map可以用</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> map = collection.mutable.<span class=\"type\">Map</span>(<span class=\"string\">\"Allon\"</span> -&gt; <span class=\"number\">29</span>, <span class=\"string\">\"Jerry\"</span> -&gt; <span class=\"number\">18</span>, <span class=\"string\">\"Karen\"</span> -&gt; <span class=\"number\">54</span> )</span><br><span class=\"line\">map(<span class=\"string\">\"Allon\"</span>) = <span class=\"number\">99</span></span><br><span class=\"line\"><span class=\"comment\">//可以修改成功</span></span><br></pre></td></tr></table></figure>\n<p>操作符 “-&gt;” 也可以换成逗号。</p>\n<p>map取值比较简单，就像上面一样。不过如果map中不存在对应的key，会抛错。这时我们可以用contains方法检查是否包含key。</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span>(map.contains(<span class=\"string\">\"XXX\"</span>)) map(<span class=\"string\">\"XXX\"</span>) <span class=\"keyword\">else</span> <span class=\"number\">0</span></span><br></pre></td></tr></table></figure>\n<p>上面的写法有些麻烦，更常用的是：</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> value1 = map.getOrElse(<span class=\"string\">\"Allon\"</span>,<span class=\"number\">0</span>)</span><br></pre></td></tr></table></figure>\n<p>像java中一样，map是有get方法的。它的返回是Option类的子类，要么是Some，要么是None。在模式匹配那章会具体讲Option类。</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">map.get(<span class=\"string\">\"Allon\"</span>)</span><br><span class=\"line\"><span class=\"comment\">//返回 Option[Int] = Some(99)</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"更新map中的值\"><a class=\"markdownIt-Anchor\" href=\"#更新map中的值\"></a> 更新Map中的值</h3>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> map = collection.mutable.<span class=\"type\">Map</span>(<span class=\"string\">\"Allon\"</span> -&gt; <span class=\"number\">29</span>, <span class=\"string\">\"Jerry\"</span> -&gt; <span class=\"number\">18</span>, <span class=\"string\">\"Karen\"</span> -&gt; <span class=\"number\">54</span> )</span><br><span class=\"line\">map +=  (<span class=\"string\">\"Bob\"</span> -&gt; <span class=\"number\">63</span>) </span><br><span class=\"line\"><span class=\"comment\">//Map(Karen -&gt; 54, Bob -&gt; 63, Allon -&gt; 29, Jerry -&gt; 18)</span></span><br></pre></td></tr></table></figure>\n<p>如果更新过程中，不存在key，那么它会自动添加</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">map(<span class=\"string\">\"Koran\"</span>) = <span class=\"number\">77</span> </span><br><span class=\"line\"><span class=\"comment\">//Map(Karen -&gt; 54, Bob -&gt; 63, Allon -&gt; 29, Jerry -&gt; 18, Koran -&gt; 77)</span></span><br></pre></td></tr></table></figure>\n<p>删除，如果不存在该key，就当没发生。</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">map -= <span class=\"string\">\"Koran\"</span></span><br><span class=\"line\"><span class=\"comment\">//Map(Karen -&gt; 54, Bob -&gt; 63, Allon -&gt; 29, Jerry -&gt; 18)</span></span><br></pre></td></tr></table></figure>\n<p>不能更新一个不可变Map，但是可以把它追加到其他Map上。</p>\n<ul>\n<li>累加过程中遇到冲突元素会update。</li>\n<li>不管是不是可变Map都支持这种操作。</li>\n<li>写法只能如下这么写，不可以直接两个Map直接相加。</li>\n</ul>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">map + (<span class=\"string\">\"Iresb\"</span> -&gt; <span class=\"number\">43</span>,<span class=\"string\">\"Karen\"</span> -&gt; <span class=\"number\">12</span>)</span><br><span class=\"line\"><span class=\"comment\">//Map(Karen -&gt; 12, Allon -&gt; 29, Bob -&gt; 63, Iresb -&gt; 43, Jerry -&gt; 18)</span></span><br></pre></td></tr></table></figure>\n<p>也可以</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> map = collection.immutable.<span class=\"type\">Map</span>(<span class=\"string\">\"Iresb\"</span> -&gt; <span class=\"number\">43</span>,<span class=\"string\">\"Karen\"</span> -&gt; <span class=\"number\">12</span>)</span><br><span class=\"line\">map = map + (<span class=\"string\">\"Abc\"</span> -&gt; <span class=\"number\">43</span>,<span class=\"string\">\"Kkk\"</span> -&gt; <span class=\"number\">12</span>)</span><br></pre></td></tr></table></figure>\n<h3 id=\"遍历map和有序map\"><a class=\"markdownIt-Anchor\" href=\"#遍历map和有序map\"></a> 遍历Map和有序Map</h3>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span>((k, v) &lt;- map) println(<span class=\"string\">\"key:\"</span> + k +<span class=\"string\">\", \"</span>+ <span class=\"string\">\"value:\"</span>+ v)</span><br><span class=\"line\">map.keyset <span class=\"comment\">//Set(Iresb, Karen, Abc, Kkk)</span></span><br><span class=\"line\">map.values <span class=\"comment\">//MapLike(43, 12, 43, 12)</span></span><br><span class=\"line\"><span class=\"keyword\">for</span>((k, v) &lt;- map) <span class=\"keyword\">yield</span> (v, k)<span class=\"comment\">//对调k和v</span></span><br></pre></td></tr></table></figure>\n<p>scala中没有可变的tree map，下面两种是scala中的有序map。</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> map = collection.immutable.<span class=\"type\">SortedMap</span>(<span class=\"string\">\"Allon\"</span> -&gt; <span class=\"number\">29</span>, <span class=\"string\">\"Jerry\"</span> -&gt; <span class=\"number\">18</span>, <span class=\"string\">\"Karen\"</span> -&gt; <span class=\"number\">54</span> ) <span class=\"comment\">//基于平衡树实现的有序map。它是不可变的！</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">val</span> map = collection.immutable.<span class=\"type\">LinkedHashMap</span>(<span class=\"string\">\"Allon\"</span> -&gt; <span class=\"number\">29</span>, <span class=\"string\">\"Jerry\"</span> -&gt; <span class=\"number\">18</span>, <span class=\"string\">\"Karen\"</span> -&gt; <span class=\"number\">54</span> ) <span class=\"comment\">//基于链表实现的有序map，顺序卽为插入顺序</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"与java的互操作\"><a class=\"markdownIt-Anchor\" href=\"#与java的互操作\"></a> 与java的互操作</h3>\n<p>scala中没有可变tree map，我们可以使用java的API，从而把java的转成scala的map。</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> collection.<span class=\"type\">JavaConversions</span>.mapAsScalaMap</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">val</span> map = <span class=\"keyword\">new</span> java.util.<span class=\"type\">TreeMap</span>[<span class=\"type\">String</span>, <span class=\"type\">Int</span>]</span><br><span class=\"line\">map.put(<span class=\"string\">\"Jerry\"</span>,<span class=\"number\">18</span>)</span><br><span class=\"line\">map += (<span class=\"string\">\"Jerry\"</span>-&gt;<span class=\"number\">18</span>)<span class=\"comment\">// 相当于\"map.+=(k -&gt; v)\"，返回一个scala的map。从java的TreeMap直接返回scala的map，经历了一次“偷偷”（隐式）转换。</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">val</span> map: collection.mutable.<span class=\"type\">Map</span>[<span class=\"type\">String</span>, <span class=\"type\">Int</span>] = <span class=\"keyword\">new</span> java.util.<span class=\"type\">TreeMap</span>[<span class=\"type\">String</span>, <span class=\"type\">Int</span>]</span><br><span class=\"line\"><span class=\"comment\">//经过修改后，再转换scala的普通map</span></span><br></pre></td></tr></table></figure>\n<p>除此之外，scala还可以从java.util.Properties转成scala的Map</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> collection.<span class=\"type\">JavaConversions</span>.propertiesAsScalaMap</span><br><span class=\"line\"><span class=\"keyword\">val</span> props : collection.<span class=\"type\">Map</span>[<span class=\"type\">String</span>, <span class=\"type\">String</span>] = <span class=\"type\">System</span>.getProperties()</span><br></pre></td></tr></table></figure>\n<p>也可以相反的转换，把scala的Map给java的API用。</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> collection.<span class=\"type\">JavaConversions</span>.mapAsJavaMap</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.awt.font.<span class=\"type\">TextAttribute</span>._ <span class=\"comment\">//引入java相关的枚举key</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">val</span> attrs = <span class=\"type\">Map</span>(<span class=\"type\">FAMILY</span> -&gt; <span class=\"string\">\"Serif\"</span>, <span class=\"type\">SIZE</span> -&gt; <span class=\"number\">12</span>) <span class=\"comment\">//scala的Map</span></span><br><span class=\"line\"><span class=\"keyword\">val</span> font = <span class=\"keyword\">new</span> java.awt.<span class=\"type\">Font</span>(attrs) <span class=\"comment\">//该方法入参是一个Java的Map，这里其实是“偷偷”把attrs转成了java的Map。</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"tuple-元组\"><a class=\"markdownIt-Anchor\" href=\"#tuple-元组\"></a> Tuple (元组)</h3>\n<p>元组是不同类型的值的聚集；K-&gt;V是最简单的元组。它和数组的区别是：</p>\n<blockquote>\n<ul>\n<li>元组内的元素不能修改。</li>\n<li>元组为不同类型的数据聚集。</li>\n<li>访问从1开始，而不是0。</li>\n</ul>\n</blockquote>\n<p>元组的定义和使用非常简单</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> tuple1 = (<span class=\"number\">1</span>, <span class=\"number\">3.14</span>, <span class=\"string\">\"Fred\"</span>)</span><br><span class=\"line\"><span class=\"comment\">// 本质上就是一个：val tuple1 = Tuple3[Int, Double, java.lang.String](1, 3.14, \"Fred\")</span></span><br><span class=\"line\">tuple1._2 <span class=\"comment\">//第二个元素，首个元素为1不是0。</span></span><br><span class=\"line\">tuple1 _2 <span class=\"comment\">//两种写都可以，只要别写成tuple1_2就可以了</span></span><br></pre></td></tr></table></figure>\n<p>一般，元组的元素用模式匹配来获取（后面一章会讲模式匹配）</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> (first, second, third) = t</span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">first: Int = 1</span></span><br><span class=\"line\"><span class=\"comment\">second: Double = 3.14</span></span><br><span class=\"line\"><span class=\"comment\">third: String = Fred</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//如果只需要部分元素可以用“_”省略</span></span><br><span class=\"line\"><span class=\"keyword\">val</span> (first, second, _) = t</span><br><span class=\"line\">first: <span class=\"type\">Int</span> = <span class=\"number\">1</span></span><br><span class=\"line\">second: <span class=\"type\">Double</span> = <span class=\"number\">3.14</span></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">first: Int = 1</span></span><br><span class=\"line\"><span class=\"comment\">second: Double = 3.14</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br></pre></td></tr></table></figure>\n<p>元组可以用在有多个返回结果的函数上。如：</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">\"New York\"</span>.partition(_.isUpper)</span><br><span class=\"line\"><span class=\"comment\">// 返回(\"NY\",\"ew ork\"),分别是满足和不满足条件的字符。</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"拉链操作\"><a class=\"markdownIt-Anchor\" href=\"#拉链操作\"></a> 拉链操作</h3>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> symbols = <span class=\"type\">Array</span>(<span class=\"string\">\"&lt;\"</span>, <span class=\"string\">\"-\"</span>, <span class=\"string\">\"&gt;\"</span>)</span><br><span class=\"line\"><span class=\"keyword\">val</span> counts = <span class=\"type\">Array</span>(<span class=\"number\">2</span>, <span class=\"number\">10</span>, <span class=\"number\">2</span>)</span><br><span class=\"line\"><span class=\"keyword\">val</span> pairs = symbols.zip(counts)</span><br><span class=\"line\"><span class=\"comment\">//输出Array((&lt;,2), (-,10), (&gt;,2))</span></span><br><span class=\"line\"><span class=\"keyword\">val</span> map = pairs.toMap <span class=\"comment\">//变为一个Map</span></span><br><span class=\"line\"><span class=\"comment\">//输出Map(\"&lt;\" -&gt; 2, \"-\" -&gt; 10, \"&gt;\" -&gt; 2)</span></span><br></pre></td></tr></table></figure>\n"},{"title":"Chapter-05-类","catalog":true,"date":"2015-06-22T09:21:29.000Z","header-img":"/img/04.jpg","_content":"\n## Chapter-05-类\n\n类 class\n\n---\n\n### 简单类和无参方法\nscala中的类简单的和java相似，主要设计和习惯区别是：\n\n* scala类中的方法默认为public的\n* 字段必须初始化\n* 类只有public的，所以不声明public关键字了（经常一个scala源文件会包含很多个类）\n\n```scala\nclass Counter {\n    private var value = 0 //你必须初始化字段\n    def increment() { value += 1 } //默认是public的。\n    def current() = value\n}\n\nval counter1 = new Counter\ncounter1.increment() // 当修改值时，最好加上“()”\ncounter1.current // 查询时不使用“()”，好一点\n```\n\n### getter和setter\n在scala中，每个字段默认提供了getter和setter方法。在scala中的getter和setter是这样\n\n>* age 等价于get方法；age_= 等价于set方法\n    \n\n```scala\nclass Person {\n    var age = 0\n}\n\n val person = new Person\n person age // 这么写和person.age是一样的\n person.age=(20) // 也可以很古怪的这么写 person age_= 10 ,因为方法名叫“.get_=” 这...！\n```\n>* jvm的内部实现会把上面的代码生成一个private的age和对应的getter、setter方法。\n\n\n//建一个Person.scala文件把上面的Person代码放进去。在命令行中执行以下编译代码\n\n    scalac Person.scala\n//反编译\n\n    javap -private Person\n可以看到输出的结果，表明jvm的内部实现会把上面的代码生成一个private的age和对应的getter、setter方法。\n```bash\nCompiled from \"Person.scala\"\npublic class Person {\n  private int age;\n  public int age();//getter\n  public void age_$eq(int);//setter ，java中不允许使用等号做为方法名，使用了“$eq”替代。\n  public Person();\n}\n```\n* 如果字段是私有的，getter和setter也是私有的。\n* 如果字段是val的，只有getter被自动生成。(val已经不能修改，所以没必要提供setter)\n* 如果将字段声明为private[this]，就不会再有getter和setter生成。\n\n总结\n\n* var的成员变量自动生成一个getter和setter\n* val的成员变量自动生成一个getter\n* scala中不能生成只有setter的成员变量\n\n### 对象私有字段\n和java一样，一个对象的方法内可以访问的其他任何该类对象的私有字段。（类私有字段）\n\n```scala\nclass Counter {\n    private var value = 0\n    def increment() { value += 1 }\n    def isLess(other : Counter) = value < other.value\n    //可以访问另一个对象的私有字段\n}\n```\n同时在scala中，权限可以控制的更细。如果字段加上private[this]修饰，则不能跨对象访问私有字段。（对象私有字段，SmallTalk等语言中也有对象级私有）\n\n```scala\nprivate[this] var value = 0 //只能自己用\n```\nprivate[this]中的this也可以换成自己的类名，或者外部类的类名（只有这两种选择，其他的会在编译期报错）。表示只能指定的类或者伴生对象（对象那章会讲）来调用。\n### Bean属性\n由于scala的默认生成的getter和setter和java中的规范不同（java bean是getXXX和setXXX），为了解决一些需要这种规范的场景，scala提供了兼容的注解来@BeanProperty。这样会同时生成两种风格的getter和setter.\n\n```scala\nimport scala.beans.BeanProperty\nclass Person {\n    @BeanProperty var name: String = _\n}\n// 将自动生成以下四个方法：\n// name: String\n// name_ = (newValue: String): Unit\n// getName(): String\n// setName(newValue: String): Unit\n```\n\n### 辅助构造器\nscala中的构造函数分主辅。辅助的构造器和java基本相同，区别于：\n>* 辅助构造器名为this。（修改类名变得更容易了）\n>* 辅助构造器方法内的第一行，必须调用其他主、辅助构造器。\n\n```scala\nclass Person{\n  private var name = \"\"\n  private var age = 0\n\n  def this(name:String){\n    this() //调用主构造器\n    this.name = name\n  }\n\n  def this(name:String, age:Int){\n    this(name) // 调用前一个辅助构造器\n    this.age = age\n  }\n}\n```\n### 主构造器\n主构造器在类名之后直接定义，如果类名后什么也不写，像java一样会默认提供一个无参的主构造器。\n\n```scala\nclass Person(val name: String, val age: Int) \n```\n以上语句换成java代码如下（始觉大道至简！）\n```java\npublic class Person {\n    private String name;\n    private int age;\n    public Person(String name, int age) {\n        this.name = name;\n        this.age = age;\n    }\n    public String getName(){ return this.name; }\n    public int getAge(){ return this.age }\n    public void setName(String name){\n        this.name = name;\n    }\n    public void setAge(int age){\n        this.age = age;\n    }\n}\n```\n直接写在类体中的执行语句，会在主构造器中执行。\n\n```scala\nclass Person(val name: String, val age: Int) {\n    println(\"主构造器被调用！\")\n    def desc = name + \" is \" + age + \" years old \"\n}\nval person = new Person(\"allon\", 29)\nprintln(per desc)\n//输出\n// 主构造器被调用！\n// allon is 29 years old \n```\n常见的初始化配置文件等操作，就可以在类体中直接操作，因为它会做为主构造器中的一部分被执行。\n\n主构造器中的参数实际是字段，它同样可以使用一些关键字来修饰。val\\var\\private\\private[String]。也可以完全不加修饰关键字。\n\n```scala\nclass Person(name: String, age:Int) {\n    def desc = name + \" is \" + age + \" years old \"\n}\n```\n以上主构造器的参数如果在该类内部方法中被使用了，它就相当于private[String]的效果，会自动升级为字段。如果没有被使用过，它就只是一个普通的主构造器中可以使用的参数而已。\n\n也可以让主构造器变成private的。这样只能通过辅助构造器来创建Person对象了。\n\n```scala\nclass Person private(val name: String, val age: Int) \n```\n\n> 可以把类看作一个函数，主构造器参数就是这个函数的参数，那么类的内部任何位置当然可以使用该参数。只是当方法内部使用它时，它就会自动升级为字段而已。\n\n\n### 内部类\n在scala中，几乎可以随意嵌套语法结构。函数中可以定义函数，类中可以定义类。\n\n```scala\nimport collection.mutable.ArrayBuffer\n\nclass Network {\n    class Member\n    \n    pirvate val members = new ArrayBuffer[Member]\n    \n    def join(m:Member) = {\n        members += m\n    }\n}\n\nval chatter =  new Network\nval myFace = new Network\n```\n> 在java中，内部类从属于外部类，scala中内部类从属于外部类对象。就像上面的代码中，myFace.Member和chatter.Member是两个不同的类。\n\n\n```scala\n  val chatter =  new Network\n  val myFace = new Network\n  val chatterMember = new chatter.Member\n  val myFaceMember = new myFace.Member\n\n  chatter.join(chatterMember)\n  chatter.join(myFaceMember) //这里会报错，因为myFace.Member和chatter.Member是两个不同的类，members的泛型冲突了。\n```\n\n如果想解决以上问题，可以在到定义处把Member换成Netwok#Member。\n\n\n```scala\n  private val members = new ArrayBuffer[Network#Member]\n\n  def join(m: Network#Member) = {\n    members += m\n  }\n```\n\nNetwork#Member的含义是，“任何Network的Member”。这种方式叫类型投影。后面也会讲到类型投影。\n### 重命名外部类this引用\n和java一样，在内部类中，可以通过“外部类.this”的方式来访问外部类的this引用。同时，在scala中你也可以为这个引用定义一个别名。\n\n\n```scala\nclass Network(val name: String) {\n  outer => //outer指向的是Network.this。可以用任何合法名来定义它，self在内部类中可能会引发岐义。\n\n  class Member {\n    def desc = outer.name\n  }\n}\n```\n\n\n","source":"_posts/Chapter-05-类.md","raw":"---\ntitle: 'Chapter-05-类'\ncatalog: true\ndate: 2015-06-22 17:21:29\nheader-img: \"/img/04.jpg\"\ntags: \"scala\"\n---\n\n## Chapter-05-类\n\n类 class\n\n---\n\n### 简单类和无参方法\nscala中的类简单的和java相似，主要设计和习惯区别是：\n\n* scala类中的方法默认为public的\n* 字段必须初始化\n* 类只有public的，所以不声明public关键字了（经常一个scala源文件会包含很多个类）\n\n```scala\nclass Counter {\n    private var value = 0 //你必须初始化字段\n    def increment() { value += 1 } //默认是public的。\n    def current() = value\n}\n\nval counter1 = new Counter\ncounter1.increment() // 当修改值时，最好加上“()”\ncounter1.current // 查询时不使用“()”，好一点\n```\n\n### getter和setter\n在scala中，每个字段默认提供了getter和setter方法。在scala中的getter和setter是这样\n\n>* age 等价于get方法；age_= 等价于set方法\n    \n\n```scala\nclass Person {\n    var age = 0\n}\n\n val person = new Person\n person age // 这么写和person.age是一样的\n person.age=(20) // 也可以很古怪的这么写 person age_= 10 ,因为方法名叫“.get_=” 这...！\n```\n>* jvm的内部实现会把上面的代码生成一个private的age和对应的getter、setter方法。\n\n\n//建一个Person.scala文件把上面的Person代码放进去。在命令行中执行以下编译代码\n\n    scalac Person.scala\n//反编译\n\n    javap -private Person\n可以看到输出的结果，表明jvm的内部实现会把上面的代码生成一个private的age和对应的getter、setter方法。\n```bash\nCompiled from \"Person.scala\"\npublic class Person {\n  private int age;\n  public int age();//getter\n  public void age_$eq(int);//setter ，java中不允许使用等号做为方法名，使用了“$eq”替代。\n  public Person();\n}\n```\n* 如果字段是私有的，getter和setter也是私有的。\n* 如果字段是val的，只有getter被自动生成。(val已经不能修改，所以没必要提供setter)\n* 如果将字段声明为private[this]，就不会再有getter和setter生成。\n\n总结\n\n* var的成员变量自动生成一个getter和setter\n* val的成员变量自动生成一个getter\n* scala中不能生成只有setter的成员变量\n\n### 对象私有字段\n和java一样，一个对象的方法内可以访问的其他任何该类对象的私有字段。（类私有字段）\n\n```scala\nclass Counter {\n    private var value = 0\n    def increment() { value += 1 }\n    def isLess(other : Counter) = value < other.value\n    //可以访问另一个对象的私有字段\n}\n```\n同时在scala中，权限可以控制的更细。如果字段加上private[this]修饰，则不能跨对象访问私有字段。（对象私有字段，SmallTalk等语言中也有对象级私有）\n\n```scala\nprivate[this] var value = 0 //只能自己用\n```\nprivate[this]中的this也可以换成自己的类名，或者外部类的类名（只有这两种选择，其他的会在编译期报错）。表示只能指定的类或者伴生对象（对象那章会讲）来调用。\n### Bean属性\n由于scala的默认生成的getter和setter和java中的规范不同（java bean是getXXX和setXXX），为了解决一些需要这种规范的场景，scala提供了兼容的注解来@BeanProperty。这样会同时生成两种风格的getter和setter.\n\n```scala\nimport scala.beans.BeanProperty\nclass Person {\n    @BeanProperty var name: String = _\n}\n// 将自动生成以下四个方法：\n// name: String\n// name_ = (newValue: String): Unit\n// getName(): String\n// setName(newValue: String): Unit\n```\n\n### 辅助构造器\nscala中的构造函数分主辅。辅助的构造器和java基本相同，区别于：\n>* 辅助构造器名为this。（修改类名变得更容易了）\n>* 辅助构造器方法内的第一行，必须调用其他主、辅助构造器。\n\n```scala\nclass Person{\n  private var name = \"\"\n  private var age = 0\n\n  def this(name:String){\n    this() //调用主构造器\n    this.name = name\n  }\n\n  def this(name:String, age:Int){\n    this(name) // 调用前一个辅助构造器\n    this.age = age\n  }\n}\n```\n### 主构造器\n主构造器在类名之后直接定义，如果类名后什么也不写，像java一样会默认提供一个无参的主构造器。\n\n```scala\nclass Person(val name: String, val age: Int) \n```\n以上语句换成java代码如下（始觉大道至简！）\n```java\npublic class Person {\n    private String name;\n    private int age;\n    public Person(String name, int age) {\n        this.name = name;\n        this.age = age;\n    }\n    public String getName(){ return this.name; }\n    public int getAge(){ return this.age }\n    public void setName(String name){\n        this.name = name;\n    }\n    public void setAge(int age){\n        this.age = age;\n    }\n}\n```\n直接写在类体中的执行语句，会在主构造器中执行。\n\n```scala\nclass Person(val name: String, val age: Int) {\n    println(\"主构造器被调用！\")\n    def desc = name + \" is \" + age + \" years old \"\n}\nval person = new Person(\"allon\", 29)\nprintln(per desc)\n//输出\n// 主构造器被调用！\n// allon is 29 years old \n```\n常见的初始化配置文件等操作，就可以在类体中直接操作，因为它会做为主构造器中的一部分被执行。\n\n主构造器中的参数实际是字段，它同样可以使用一些关键字来修饰。val\\var\\private\\private[String]。也可以完全不加修饰关键字。\n\n```scala\nclass Person(name: String, age:Int) {\n    def desc = name + \" is \" + age + \" years old \"\n}\n```\n以上主构造器的参数如果在该类内部方法中被使用了，它就相当于private[String]的效果，会自动升级为字段。如果没有被使用过，它就只是一个普通的主构造器中可以使用的参数而已。\n\n也可以让主构造器变成private的。这样只能通过辅助构造器来创建Person对象了。\n\n```scala\nclass Person private(val name: String, val age: Int) \n```\n\n> 可以把类看作一个函数，主构造器参数就是这个函数的参数，那么类的内部任何位置当然可以使用该参数。只是当方法内部使用它时，它就会自动升级为字段而已。\n\n\n### 内部类\n在scala中，几乎可以随意嵌套语法结构。函数中可以定义函数，类中可以定义类。\n\n```scala\nimport collection.mutable.ArrayBuffer\n\nclass Network {\n    class Member\n    \n    pirvate val members = new ArrayBuffer[Member]\n    \n    def join(m:Member) = {\n        members += m\n    }\n}\n\nval chatter =  new Network\nval myFace = new Network\n```\n> 在java中，内部类从属于外部类，scala中内部类从属于外部类对象。就像上面的代码中，myFace.Member和chatter.Member是两个不同的类。\n\n\n```scala\n  val chatter =  new Network\n  val myFace = new Network\n  val chatterMember = new chatter.Member\n  val myFaceMember = new myFace.Member\n\n  chatter.join(chatterMember)\n  chatter.join(myFaceMember) //这里会报错，因为myFace.Member和chatter.Member是两个不同的类，members的泛型冲突了。\n```\n\n如果想解决以上问题，可以在到定义处把Member换成Netwok#Member。\n\n\n```scala\n  private val members = new ArrayBuffer[Network#Member]\n\n  def join(m: Network#Member) = {\n    members += m\n  }\n```\n\nNetwork#Member的含义是，“任何Network的Member”。这种方式叫类型投影。后面也会讲到类型投影。\n### 重命名外部类this引用\n和java一样，在内部类中，可以通过“外部类.this”的方式来访问外部类的this引用。同时，在scala中你也可以为这个引用定义一个别名。\n\n\n```scala\nclass Network(val name: String) {\n  outer => //outer指向的是Network.this。可以用任何合法名来定义它，self在内部类中可能会引发岐义。\n\n  class Member {\n    def desc = outer.name\n  }\n}\n```\n\n\n","slug":"Chapter-05-类","published":1,"updated":"2017-11-25T06:28:50.495Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjahvvnx50008pv4npa2t8cvx","content":"<h2><span id=\"chapter-05-类\"> Chapter-05-类</span></h2>\n<p>类 class</p>\n<hr>\n<h3><span id=\"简单类和无参方法\"> 简单类和无参方法</span></h3>\n<p>scala中的类简单的和java相似，主要设计和习惯区别是：</p>\n<ul>\n<li>scala类中的方法默认为public的</li>\n<li>字段必须初始化</li>\n<li>类只有public的，所以不声明public关键字了（经常一个scala源文件会包含很多个类）</li>\n</ul>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Counter</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">var</span> value = <span class=\"number\">0</span> <span class=\"comment\">//你必须初始化字段</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">increment</span></span>() &#123; value += <span class=\"number\">1</span> &#125; <span class=\"comment\">//默认是public的。</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">current</span></span>() = value</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">val</span> counter1 = <span class=\"keyword\">new</span> <span class=\"type\">Counter</span></span><br><span class=\"line\">counter1.increment() <span class=\"comment\">// 当修改值时，最好加上“()”</span></span><br><span class=\"line\">counter1.current <span class=\"comment\">// 查询时不使用“()”，好一点</span></span><br></pre></td></tr></table></figure>\n<h3><span id=\"getter和setter\"> getter和setter</span></h3>\n<p>在scala中，每个字段默认提供了getter和setter方法。在scala中的getter和setter是这样</p>\n<blockquote>\n<ul>\n<li>age 等价于get方法；age_= 等价于set方法</li>\n</ul>\n</blockquote>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> age = <span class=\"number\">0</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"keyword\">val</span> person = <span class=\"keyword\">new</span> <span class=\"type\">Person</span></span><br><span class=\"line\"> person age <span class=\"comment\">// 这么写和person.age是一样的</span></span><br><span class=\"line\"> person.age=(<span class=\"number\">20</span>) <span class=\"comment\">// 也可以很古怪的这么写 person age_= 10 ,因为方法名叫“.get_=” 这...！</span></span><br></pre></td></tr></table></figure>\n<blockquote>\n<ul>\n<li>jvm的内部实现会把上面的代码生成一个private的age和对应的getter、setter方法。</li>\n</ul>\n</blockquote>\n<p><a href=\"//xn--Person-9m7iglt94k.xn--scalaPerson-4p8ql2gnhl86d119cmvjiib868q6hgws9k7u8a\">//建一个Person.scala文件把上面的Person代码放进去</a>。在命令行中执行以下编译代码</p>\n<pre><code>scalac Person.scala\n</code></pre>\n<p>//反编译</p>\n<pre><code>javap -private Person\n</code></pre>\n<p>可以看到输出的结果，表明jvm的内部实现会把上面的代码生成一个private的age和对应的getter、setter方法。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Compiled from <span class=\"string\">\"Person.scala\"</span></span><br><span class=\"line\">public class Person &#123;</span><br><span class=\"line\">  private int age;</span><br><span class=\"line\">  public int age();//getter</span><br><span class=\"line\">  public void age_<span class=\"variable\">$eq</span>(int);//setter ，java中不允许使用等号做为方法名，使用了“<span class=\"variable\">$eq</span>”替代。</span><br><span class=\"line\">  public Person();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>如果字段是私有的，getter和setter也是私有的。</li>\n<li>如果字段是val的，只有getter被自动生成。(val已经不能修改，所以没必要提供setter)</li>\n<li>如果将字段声明为private[this]，就不会再有getter和setter生成。</li>\n</ul>\n<p>总结</p>\n<ul>\n<li>var的成员变量自动生成一个getter和setter</li>\n<li>val的成员变量自动生成一个getter</li>\n<li>scala中不能生成只有setter的成员变量</li>\n</ul>\n<h3><span id=\"对象私有字段\"> 对象私有字段</span></h3>\n<p>和java一样，一个对象的方法内可以访问的其他任何该类对象的私有字段。（类私有字段）</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Counter</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">var</span> value = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">increment</span></span>() &#123; value += <span class=\"number\">1</span> &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">isLess</span></span>(other : <span class=\"type\">Counter</span>) = value &lt; other.value</span><br><span class=\"line\">    <span class=\"comment\">//可以访问另一个对象的私有字段</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>同时在scala中，权限可以控制的更细。如果字段加上private[this]修饰，则不能跨对象访问私有字段。（对象私有字段，SmallTalk等语言中也有对象级私有）</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span>[<span class=\"keyword\">this</span>] <span class=\"keyword\">var</span> value = <span class=\"number\">0</span> <span class=\"comment\">//只能自己用</span></span><br></pre></td></tr></table></figure>\n<p>private[this]中的this也可以换成自己的类名，或者外部类的类名（只有这两种选择，其他的会在编译期报错）。表示只能指定的类或者伴生对象（对象那章会讲）来调用。</p>\n<h3><span id=\"bean属性\"> Bean属性</span></h3>\n<p>由于scala的默认生成的getter和setter和java中的规范不同（java bean是getXXX和setXXX），为了解决一些需要这种规范的场景，scala提供了兼容的注解来@BeanProperty。这样会同时生成两种风格的getter和setter.</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> scala.beans.<span class=\"type\">BeanProperty</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@BeanProperty</span> <span class=\"keyword\">var</span> name: <span class=\"type\">String</span> = _</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 将自动生成以下四个方法：</span></span><br><span class=\"line\"><span class=\"comment\">// name: String</span></span><br><span class=\"line\"><span class=\"comment\">// name_ = (newValue: String): Unit</span></span><br><span class=\"line\"><span class=\"comment\">// getName(): String</span></span><br><span class=\"line\"><span class=\"comment\">// setName(newValue: String): Unit</span></span><br></pre></td></tr></table></figure>\n<h3><span id=\"辅助构造器\"> 辅助构造器</span></h3>\n<p>scala中的构造函数分主辅。辅助的构造器和java基本相同，区别于：</p>\n<blockquote>\n<ul>\n<li>辅助构造器名为this。（修改类名变得更容易了）</li>\n<li>辅助构造器方法内的第一行，必须调用其他主、辅助构造器。</li>\n</ul>\n</blockquote>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span></span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">var</span> name = <span class=\"string\">\"\"</span></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">var</span> age = <span class=\"number\">0</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">this</span></span>(name:<span class=\"type\">String</span>)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>() <span class=\"comment\">//调用主构造器</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.name = name</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">this</span></span>(name:<span class=\"type\">String</span>, age:<span class=\"type\">Int</span>)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>(name) <span class=\"comment\">// 调用前一个辅助构造器</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.age = age</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3><span id=\"主构造器\"> 主构造器</span></h3>\n<p>主构造器在类名之后直接定义，如果类名后什么也不写，像java一样会默认提供一个无参的主构造器。</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span>(<span class=\"params\">val name: <span class=\"type\">String</span>, val age: <span class=\"type\">Int</span></span>)</span></span><br></pre></td></tr></table></figure>\n<p>以上语句换成java代码如下（始觉大道至简！）</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String name;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> age;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Person</span><span class=\"params\">(String name, <span class=\"keyword\">int</span> age)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.age = age;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getName</span><span class=\"params\">()</span></span>&#123; <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.name; &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">getAge</span><span class=\"params\">()</span></span>&#123; <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.age &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setName</span><span class=\"params\">(String name)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setAge</span><span class=\"params\">(<span class=\"keyword\">int</span> age)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.age = age;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>直接写在类体中的执行语句，会在主构造器中执行。</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span>(<span class=\"params\">val name: <span class=\"type\">String</span>, val age: <span class=\"type\">Int</span></span>) </span>&#123;</span><br><span class=\"line\">    println(<span class=\"string\">\"主构造器被调用！\"</span>)</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">desc</span> </span>= name + <span class=\"string\">\" is \"</span> + age + <span class=\"string\">\" years old \"</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">val</span> person = <span class=\"keyword\">new</span> <span class=\"type\">Person</span>(<span class=\"string\">\"allon\"</span>, <span class=\"number\">29</span>)</span><br><span class=\"line\">println(per desc)</span><br><span class=\"line\"><span class=\"comment\">//输出</span></span><br><span class=\"line\"><span class=\"comment\">// 主构造器被调用！</span></span><br><span class=\"line\"><span class=\"comment\">// allon is 29 years old</span></span><br></pre></td></tr></table></figure>\n<p>常见的初始化配置文件等操作，就可以在类体中直接操作，因为它会做为主构造器中的一部分被执行。</p>\n<p>主构造器中的参数实际是字段，它同样可以使用一些关键字来修饰。val\\var\\private\\private[String]。也可以完全不加修饰关键字。</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span>(<span class=\"params\">name: <span class=\"type\">String</span>, age:<span class=\"type\">Int</span></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">desc</span> </span>= name + <span class=\"string\">\" is \"</span> + age + <span class=\"string\">\" years old \"</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>以上主构造器的参数如果在该类内部方法中被使用了，它就相当于private[String]的效果，会自动升级为字段。如果没有被使用过，它就只是一个普通的主构造器中可以使用的参数而已。</p>\n<p>也可以让主构造器变成private的。这样只能通过辅助构造器来创建Person对象了。</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span> <span class=\"title\">private</span>(<span class=\"params\">val name: <span class=\"type\">String</span>, val age: <span class=\"type\">Int</span></span>)</span></span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>可以把类看作一个函数，主构造器参数就是这个函数的参数，那么类的内部任何位置当然可以使用该参数。只是当方法内部使用它时，它就会自动升级为字段而已。</p>\n</blockquote>\n<h3><span id=\"内部类\"> 内部类</span></h3>\n<p>在scala中，几乎可以随意嵌套语法结构。函数中可以定义函数，类中可以定义类。</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> collection.mutable.<span class=\"type\">ArrayBuffer</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Network</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Member</span></span></span><br><span class=\"line\"><span class=\"class\">    </span></span><br><span class=\"line\"><span class=\"class\">    <span class=\"title\">pirvate</span> <span class=\"title\">val</span> <span class=\"title\">members</span> </span>= <span class=\"keyword\">new</span> <span class=\"type\">ArrayBuffer</span>[<span class=\"type\">Member</span>]</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">join</span></span>(m:<span class=\"type\">Member</span>) = &#123;</span><br><span class=\"line\">        members += m</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">val</span> chatter =  <span class=\"keyword\">new</span> <span class=\"type\">Network</span></span><br><span class=\"line\"><span class=\"keyword\">val</span> myFace = <span class=\"keyword\">new</span> <span class=\"type\">Network</span></span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>在java中，内部类从属于外部类，scala中内部类从属于外部类对象。就像上面的代码中，myFace.Member和chatter.Member是两个不同的类。</p>\n</blockquote>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> chatter =  <span class=\"keyword\">new</span> <span class=\"type\">Network</span></span><br><span class=\"line\"><span class=\"keyword\">val</span> myFace = <span class=\"keyword\">new</span> <span class=\"type\">Network</span></span><br><span class=\"line\"><span class=\"keyword\">val</span> chatterMember = <span class=\"keyword\">new</span> chatter.<span class=\"type\">Member</span></span><br><span class=\"line\"><span class=\"keyword\">val</span> myFaceMember = <span class=\"keyword\">new</span> myFace.<span class=\"type\">Member</span></span><br><span class=\"line\"></span><br><span class=\"line\">chatter.join(chatterMember)</span><br><span class=\"line\">chatter.join(myFaceMember) <span class=\"comment\">//这里会报错，因为myFace.Member和chatter.Member是两个不同的类，members的泛型冲突了。</span></span><br></pre></td></tr></table></figure>\n<p>如果想解决以上问题，可以在到定义处把Member换成Netwok#Member。</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">val</span> members = <span class=\"keyword\">new</span> <span class=\"type\">ArrayBuffer</span>[<span class=\"type\">Network</span>#<span class=\"type\">Member</span>]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">join</span></span>(m: <span class=\"type\">Network</span>#<span class=\"type\">Member</span>) = &#123;</span><br><span class=\"line\">  members += m</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Network#Member的含义是，“任何Network的Member”。这种方式叫类型投影。后面也会讲到类型投影。</p>\n<h3><span id=\"重命名外部类this引用\"> 重命名外部类this引用</span></h3>\n<p>和java一样，在内部类中，可以通过“外部类.this”的方式来访问外部类的this引用。同时，在scala中你也可以为这个引用定义一个别名。</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Network</span>(<span class=\"params\">val name: <span class=\"type\">String</span></span>) </span>&#123;</span><br><span class=\"line\">  outer =&gt; <span class=\"comment\">//outer指向的是Network.this。可以用任何合法名来定义它，self在内部类中可能会引发岐义。</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Member</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">desc</span> </span>= outer.name</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"chapter-05-类\"><a class=\"markdownIt-Anchor\" href=\"#chapter-05-类\"></a> Chapter-05-类</h2>\n<p>类 class</p>\n<hr>\n<h3 id=\"简单类和无参方法\"><a class=\"markdownIt-Anchor\" href=\"#简单类和无参方法\"></a> 简单类和无参方法</h3>\n<p>scala中的类简单的和java相似，主要设计和习惯区别是：</p>\n<ul>\n<li>scala类中的方法默认为public的</li>\n<li>字段必须初始化</li>\n<li>类只有public的，所以不声明public关键字了（经常一个scala源文件会包含很多个类）</li>\n</ul>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Counter</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">var</span> value = <span class=\"number\">0</span> <span class=\"comment\">//你必须初始化字段</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">increment</span></span>() &#123; value += <span class=\"number\">1</span> &#125; <span class=\"comment\">//默认是public的。</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">current</span></span>() = value</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">val</span> counter1 = <span class=\"keyword\">new</span> <span class=\"type\">Counter</span></span><br><span class=\"line\">counter1.increment() <span class=\"comment\">// 当修改值时，最好加上“()”</span></span><br><span class=\"line\">counter1.current <span class=\"comment\">// 查询时不使用“()”，好一点</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"getter和setter\"><a class=\"markdownIt-Anchor\" href=\"#getter和setter\"></a> getter和setter</h3>\n<p>在scala中，每个字段默认提供了getter和setter方法。在scala中的getter和setter是这样</p>\n<blockquote>\n<ul>\n<li>age 等价于get方法；age_= 等价于set方法</li>\n</ul>\n</blockquote>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> age = <span class=\"number\">0</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"keyword\">val</span> person = <span class=\"keyword\">new</span> <span class=\"type\">Person</span></span><br><span class=\"line\"> person age <span class=\"comment\">// 这么写和person.age是一样的</span></span><br><span class=\"line\"> person.age=(<span class=\"number\">20</span>) <span class=\"comment\">// 也可以很古怪的这么写 person age_= 10 ,因为方法名叫“.get_=” 这...！</span></span><br></pre></td></tr></table></figure>\n<blockquote>\n<ul>\n<li>jvm的内部实现会把上面的代码生成一个private的age和对应的getter、setter方法。</li>\n</ul>\n</blockquote>\n<p><a href=\"//xn--Person-9m7iglt94k.xn--scalaPerson-4p8ql2gnhl86d119cmvjiib868q6hgws9k7u8a\">//建一个Person.scala文件把上面的Person代码放进去</a>。在命令行中执行以下编译代码</p>\n<pre><code>scalac Person.scala\n</code></pre>\n<p>//反编译</p>\n<pre><code>javap -private Person\n</code></pre>\n<p>可以看到输出的结果，表明jvm的内部实现会把上面的代码生成一个private的age和对应的getter、setter方法。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Compiled from <span class=\"string\">\"Person.scala\"</span></span><br><span class=\"line\">public class Person &#123;</span><br><span class=\"line\">  private int age;</span><br><span class=\"line\">  public int age();//getter</span><br><span class=\"line\">  public void age_<span class=\"variable\">$eq</span>(int);//setter ，java中不允许使用等号做为方法名，使用了“<span class=\"variable\">$eq</span>”替代。</span><br><span class=\"line\">  public Person();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>如果字段是私有的，getter和setter也是私有的。</li>\n<li>如果字段是val的，只有getter被自动生成。(val已经不能修改，所以没必要提供setter)</li>\n<li>如果将字段声明为private[this]，就不会再有getter和setter生成。</li>\n</ul>\n<p>总结</p>\n<ul>\n<li>var的成员变量自动生成一个getter和setter</li>\n<li>val的成员变量自动生成一个getter</li>\n<li>scala中不能生成只有setter的成员变量</li>\n</ul>\n<h3 id=\"对象私有字段\"><a class=\"markdownIt-Anchor\" href=\"#对象私有字段\"></a> 对象私有字段</h3>\n<p>和java一样，一个对象的方法内可以访问的其他任何该类对象的私有字段。（类私有字段）</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Counter</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">var</span> value = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">increment</span></span>() &#123; value += <span class=\"number\">1</span> &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">isLess</span></span>(other : <span class=\"type\">Counter</span>) = value &lt; other.value</span><br><span class=\"line\">    <span class=\"comment\">//可以访问另一个对象的私有字段</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>同时在scala中，权限可以控制的更细。如果字段加上private[this]修饰，则不能跨对象访问私有字段。（对象私有字段，SmallTalk等语言中也有对象级私有）</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span>[<span class=\"keyword\">this</span>] <span class=\"keyword\">var</span> value = <span class=\"number\">0</span> <span class=\"comment\">//只能自己用</span></span><br></pre></td></tr></table></figure>\n<p>private[this]中的this也可以换成自己的类名，或者外部类的类名（只有这两种选择，其他的会在编译期报错）。表示只能指定的类或者伴生对象（对象那章会讲）来调用。</p>\n<h3 id=\"bean属性\"><a class=\"markdownIt-Anchor\" href=\"#bean属性\"></a> Bean属性</h3>\n<p>由于scala的默认生成的getter和setter和java中的规范不同（java bean是getXXX和setXXX），为了解决一些需要这种规范的场景，scala提供了兼容的注解来@BeanProperty。这样会同时生成两种风格的getter和setter.</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> scala.beans.<span class=\"type\">BeanProperty</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@BeanProperty</span> <span class=\"keyword\">var</span> name: <span class=\"type\">String</span> = _</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 将自动生成以下四个方法：</span></span><br><span class=\"line\"><span class=\"comment\">// name: String</span></span><br><span class=\"line\"><span class=\"comment\">// name_ = (newValue: String): Unit</span></span><br><span class=\"line\"><span class=\"comment\">// getName(): String</span></span><br><span class=\"line\"><span class=\"comment\">// setName(newValue: String): Unit</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"辅助构造器\"><a class=\"markdownIt-Anchor\" href=\"#辅助构造器\"></a> 辅助构造器</h3>\n<p>scala中的构造函数分主辅。辅助的构造器和java基本相同，区别于：</p>\n<blockquote>\n<ul>\n<li>辅助构造器名为this。（修改类名变得更容易了）</li>\n<li>辅助构造器方法内的第一行，必须调用其他主、辅助构造器。</li>\n</ul>\n</blockquote>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span></span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">var</span> name = <span class=\"string\">\"\"</span></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">var</span> age = <span class=\"number\">0</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">this</span></span>(name:<span class=\"type\">String</span>)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>() <span class=\"comment\">//调用主构造器</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.name = name</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">this</span></span>(name:<span class=\"type\">String</span>, age:<span class=\"type\">Int</span>)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>(name) <span class=\"comment\">// 调用前一个辅助构造器</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.age = age</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"主构造器\"><a class=\"markdownIt-Anchor\" href=\"#主构造器\"></a> 主构造器</h3>\n<p>主构造器在类名之后直接定义，如果类名后什么也不写，像java一样会默认提供一个无参的主构造器。</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span>(<span class=\"params\">val name: <span class=\"type\">String</span>, val age: <span class=\"type\">Int</span></span>)</span></span><br></pre></td></tr></table></figure>\n<p>以上语句换成java代码如下（始觉大道至简！）</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String name;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> age;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Person</span><span class=\"params\">(String name, <span class=\"keyword\">int</span> age)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.age = age;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getName</span><span class=\"params\">()</span></span>&#123; <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.name; &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">getAge</span><span class=\"params\">()</span></span>&#123; <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.age &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setName</span><span class=\"params\">(String name)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setAge</span><span class=\"params\">(<span class=\"keyword\">int</span> age)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.age = age;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>直接写在类体中的执行语句，会在主构造器中执行。</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span>(<span class=\"params\">val name: <span class=\"type\">String</span>, val age: <span class=\"type\">Int</span></span>) </span>&#123;</span><br><span class=\"line\">    println(<span class=\"string\">\"主构造器被调用！\"</span>)</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">desc</span> </span>= name + <span class=\"string\">\" is \"</span> + age + <span class=\"string\">\" years old \"</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">val</span> person = <span class=\"keyword\">new</span> <span class=\"type\">Person</span>(<span class=\"string\">\"allon\"</span>, <span class=\"number\">29</span>)</span><br><span class=\"line\">println(per desc)</span><br><span class=\"line\"><span class=\"comment\">//输出</span></span><br><span class=\"line\"><span class=\"comment\">// 主构造器被调用！</span></span><br><span class=\"line\"><span class=\"comment\">// allon is 29 years old</span></span><br></pre></td></tr></table></figure>\n<p>常见的初始化配置文件等操作，就可以在类体中直接操作，因为它会做为主构造器中的一部分被执行。</p>\n<p>主构造器中的参数实际是字段，它同样可以使用一些关键字来修饰。val\\var\\private\\private[String]。也可以完全不加修饰关键字。</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span>(<span class=\"params\">name: <span class=\"type\">String</span>, age:<span class=\"type\">Int</span></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">desc</span> </span>= name + <span class=\"string\">\" is \"</span> + age + <span class=\"string\">\" years old \"</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>以上主构造器的参数如果在该类内部方法中被使用了，它就相当于private[String]的效果，会自动升级为字段。如果没有被使用过，它就只是一个普通的主构造器中可以使用的参数而已。</p>\n<p>也可以让主构造器变成private的。这样只能通过辅助构造器来创建Person对象了。</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span> <span class=\"title\">private</span>(<span class=\"params\">val name: <span class=\"type\">String</span>, val age: <span class=\"type\">Int</span></span>)</span></span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>可以把类看作一个函数，主构造器参数就是这个函数的参数，那么类的内部任何位置当然可以使用该参数。只是当方法内部使用它时，它就会自动升级为字段而已。</p>\n</blockquote>\n<h3 id=\"内部类\"><a class=\"markdownIt-Anchor\" href=\"#内部类\"></a> 内部类</h3>\n<p>在scala中，几乎可以随意嵌套语法结构。函数中可以定义函数，类中可以定义类。</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> collection.mutable.<span class=\"type\">ArrayBuffer</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Network</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Member</span></span></span><br><span class=\"line\"><span class=\"class\">    </span></span><br><span class=\"line\"><span class=\"class\">    <span class=\"title\">pirvate</span> <span class=\"title\">val</span> <span class=\"title\">members</span> </span>= <span class=\"keyword\">new</span> <span class=\"type\">ArrayBuffer</span>[<span class=\"type\">Member</span>]</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">join</span></span>(m:<span class=\"type\">Member</span>) = &#123;</span><br><span class=\"line\">        members += m</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">val</span> chatter =  <span class=\"keyword\">new</span> <span class=\"type\">Network</span></span><br><span class=\"line\"><span class=\"keyword\">val</span> myFace = <span class=\"keyword\">new</span> <span class=\"type\">Network</span></span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>在java中，内部类从属于外部类，scala中内部类从属于外部类对象。就像上面的代码中，myFace.Member和chatter.Member是两个不同的类。</p>\n</blockquote>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> chatter =  <span class=\"keyword\">new</span> <span class=\"type\">Network</span></span><br><span class=\"line\"><span class=\"keyword\">val</span> myFace = <span class=\"keyword\">new</span> <span class=\"type\">Network</span></span><br><span class=\"line\"><span class=\"keyword\">val</span> chatterMember = <span class=\"keyword\">new</span> chatter.<span class=\"type\">Member</span></span><br><span class=\"line\"><span class=\"keyword\">val</span> myFaceMember = <span class=\"keyword\">new</span> myFace.<span class=\"type\">Member</span></span><br><span class=\"line\"></span><br><span class=\"line\">chatter.join(chatterMember)</span><br><span class=\"line\">chatter.join(myFaceMember) <span class=\"comment\">//这里会报错，因为myFace.Member和chatter.Member是两个不同的类，members的泛型冲突了。</span></span><br></pre></td></tr></table></figure>\n<p>如果想解决以上问题，可以在到定义处把Member换成Netwok#Member。</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">val</span> members = <span class=\"keyword\">new</span> <span class=\"type\">ArrayBuffer</span>[<span class=\"type\">Network</span>#<span class=\"type\">Member</span>]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">join</span></span>(m: <span class=\"type\">Network</span>#<span class=\"type\">Member</span>) = &#123;</span><br><span class=\"line\">  members += m</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Network#Member的含义是，“任何Network的Member”。这种方式叫类型投影。后面也会讲到类型投影。</p>\n<h3 id=\"重命名外部类this引用\"><a class=\"markdownIt-Anchor\" href=\"#重命名外部类this引用\"></a> 重命名外部类this引用</h3>\n<p>和java一样，在内部类中，可以通过“外部类.this”的方式来访问外部类的this引用。同时，在scala中你也可以为这个引用定义一个别名。</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Network</span>(<span class=\"params\">val name: <span class=\"type\">String</span></span>) </span>&#123;</span><br><span class=\"line\">  outer =&gt; <span class=\"comment\">//outer指向的是Network.this。可以用任何合法名来定义它，self在内部类中可能会引发岐义。</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Member</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">desc</span> </span>= outer.name</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"Chapter-06-对象","catalog":true,"date":"2015-06-22T09:21:29.000Z","header-img":"/img/04.jpg","_content":"\n## Chapter-06-对象\n\n对象 object\n\n---\n\n### 单例对象\nscala中没有静态方法和字段。只要的功效可以用object语法来实现。(object定义其实就是具体某个类的单例)\n\n```scala\nobject Accounts {\n    private var lastNumber = 0\n    def newUniqueNumber() = { lastNumber += 1; lastNumber }\n}\n\nAccounts.newUniqueNumber\n// 1\nAccounts.newUniqueNumber\n// 2\n```\n对象也可以继承其他类和特质（类似接口）。但是不能定义自己的构造函数。\n### 伴生对象\n在java中会有既有成员方法又有静态方法的类。在scala中，可以用伴生对象来达到目的。\n\n```scala\nclass Account {\n    val id = Account.newUniqueNumber() //访问伴生对象的私有方法\n}\n\nobject Accout { // 伴生对象\n    private var lastNumber = 0\n    private def newUniqueNumber() = { lastNumber += 1; lastNumber }\n}\n```\n如果类和其伴生对象在同一个源文件中，它们可以互相访问对方的private特性。\n\n在调用伴生对象方法时，要Account.newUniqueNumber()，不能直接写newUniqueNumber()。\n\n### 继承类或特质的对象\n\n\n```scala\nabstract class UndoableAction(val description: String) {\n    def undo(): Unit\n    def redo(): Unit\n}\n\nobject DoNothingAction extends UndoableAction(\"Do nothing\"){\n    override def undo() {}\n    override def undo() {}\n}\n\nval actions = Map(\"open\" -> DoNothingAction, \"save\" -> DoNothingAction) //value使用DoNothingAction对象\n```\n\n### apply方法\napply方法被定义在伴生对象中，定义之后会可以像如下代码一样使用它：\n\n\n```scala\nclass Account private (val id: Int, initBalance: Double) {\n    private var balance = initBalance\n}\n\nobject Account { //伴生对象\n    def apply(initBalance: Double) = new Account(1986, initBalance)\n}\n\nval acct = Account(1000.0) //实际调用的是apply方法，等价于Account.apply(1000.0)\n```\n\n伴生对象以下格式，apply方法会被调用，一般它会返回一个伴生对象所对应类的对象：\n\n> *对象名(参数1,参数2...,参数N)*\n\n\n```scala\nArray(\"Mary\", \"had\", \"a\", \"little\", \"lamb\")\n//等价于\nArray.apply(\"Mary\", \"had\", \"a\", \"little\", \"lamb\")\n\nArray(100)\n//返回一个只有一个元素的Int数组\nnew Array(100)\n//返回一个有100个null元素的Array[Nothing]\n```\n\n### 应用对象\nscala中的main方法写到一个对象里。方法类型为Array[String] => Unit:\n\n```scala\nobject Hello {\n    def main(args: Array[String]) {\n        println(\"Hello, World!\")\n    }\n}\n```\n也可以继承App特质，\n\n```scala\nobject Hello extends App{\n    println(\"Hello, World!\")\n}\n\n//在EPFL中运行 Hello.main(null)\n```\n如果需要命令行参数，可以通过args属性得到，\n\n```scala\nobject Hello extends App{\n    if (args.length > 0) {\n        println(\"Hello, \" + args(0))\n    } else\n        println(\"Hello, World!\")\n}\n\n//创建Hello.scala把上面代码拷贝进去\n//scalac Hello.scala\n//scala  -Dscala.time Hello Fred\n//输出以下内容（-Dscala.time是运行时间）：\n//  Hello, World!\n//  [total 49ms] \n```\n\n### 枚举\nscala中没有枚举类型。标准库里提供了一个Enumeration类，可以产出枚举。\n\n```scala\nobject Color extends Enumeration {\n    val Red, Yellow, Green = Value\n    /*\n    相当于以下代码\n    val Red = Value\n    val Yellow = Value\n    val Green = Value\n    */\n}\n```\nValue是一对伴生的类和对象。每个Value对象有自己的ID和名称。可以手动设置。\n\n```scala\nobject Color extends Enumeration {\n    val Red = Value(0, \"Stop\")\n    val Yellow = Value(10) // 名称为“Yellow”\n    val Green = Value(\"Go\") // ID为11\n}\n\nColor.Red\n//Color.Value = Stop\nColor.Green.id\n//Int = 11\nColor.values\n//Color.ValueSet = Color.ValueSet(Stop, Yellow, Go)\n//可用for(c <- Color.values)来遍历这个set\n```\n\n* 如果没有手动设置枚举名称默认为变量名。\n* 如果没有手动设置枚举ID默认为前一个加1，从零开始。\n\n如果不想使用对象名调用枚举，可以import一下。就可以只简写了。\n\n```scala\nimport Color._\nRed\n//Color.Value = Stop\n```\n枚举的类型是Color.Value而不是Color。可以用type起个别名，给Color.Value起个别名Color.Color，再使用import Color._ 。这样看起来就好像枚举的类型是Color，而实际上在使用的是Color.Color。（真拗口）\n\n```scala\nimport color._\n\nobject Color extends Enumeration {\n    type Color = Value\n    val Red, Yellow, Green = Value\n}\n\ndef doWhat(color: Color) = {//实际上是Color.Color\n    ...\n}\n```\n可以用ID或者名称来进行定位，以下两行代码输出都是Color.Red对象：\n\n```scala\nColor(0) //将调用Color.apply\n//返回 Color.Value = Stop\nColor.withName(\"Yellow\")\n//返回 Color.Value = Yellow\n```\n\n\n","source":"_posts/Chapter-06-对象.md","raw":"---\ntitle: 'Chapter-06-对象'\ncatalog: true\ndate: 2015-06-22 17:21:29\nheader-img: \"/img/04.jpg\"\ntags: \"scala\"\n---\n\n## Chapter-06-对象\n\n对象 object\n\n---\n\n### 单例对象\nscala中没有静态方法和字段。只要的功效可以用object语法来实现。(object定义其实就是具体某个类的单例)\n\n```scala\nobject Accounts {\n    private var lastNumber = 0\n    def newUniqueNumber() = { lastNumber += 1; lastNumber }\n}\n\nAccounts.newUniqueNumber\n// 1\nAccounts.newUniqueNumber\n// 2\n```\n对象也可以继承其他类和特质（类似接口）。但是不能定义自己的构造函数。\n### 伴生对象\n在java中会有既有成员方法又有静态方法的类。在scala中，可以用伴生对象来达到目的。\n\n```scala\nclass Account {\n    val id = Account.newUniqueNumber() //访问伴生对象的私有方法\n}\n\nobject Accout { // 伴生对象\n    private var lastNumber = 0\n    private def newUniqueNumber() = { lastNumber += 1; lastNumber }\n}\n```\n如果类和其伴生对象在同一个源文件中，它们可以互相访问对方的private特性。\n\n在调用伴生对象方法时，要Account.newUniqueNumber()，不能直接写newUniqueNumber()。\n\n### 继承类或特质的对象\n\n\n```scala\nabstract class UndoableAction(val description: String) {\n    def undo(): Unit\n    def redo(): Unit\n}\n\nobject DoNothingAction extends UndoableAction(\"Do nothing\"){\n    override def undo() {}\n    override def undo() {}\n}\n\nval actions = Map(\"open\" -> DoNothingAction, \"save\" -> DoNothingAction) //value使用DoNothingAction对象\n```\n\n### apply方法\napply方法被定义在伴生对象中，定义之后会可以像如下代码一样使用它：\n\n\n```scala\nclass Account private (val id: Int, initBalance: Double) {\n    private var balance = initBalance\n}\n\nobject Account { //伴生对象\n    def apply(initBalance: Double) = new Account(1986, initBalance)\n}\n\nval acct = Account(1000.0) //实际调用的是apply方法，等价于Account.apply(1000.0)\n```\n\n伴生对象以下格式，apply方法会被调用，一般它会返回一个伴生对象所对应类的对象：\n\n> *对象名(参数1,参数2...,参数N)*\n\n\n```scala\nArray(\"Mary\", \"had\", \"a\", \"little\", \"lamb\")\n//等价于\nArray.apply(\"Mary\", \"had\", \"a\", \"little\", \"lamb\")\n\nArray(100)\n//返回一个只有一个元素的Int数组\nnew Array(100)\n//返回一个有100个null元素的Array[Nothing]\n```\n\n### 应用对象\nscala中的main方法写到一个对象里。方法类型为Array[String] => Unit:\n\n```scala\nobject Hello {\n    def main(args: Array[String]) {\n        println(\"Hello, World!\")\n    }\n}\n```\n也可以继承App特质，\n\n```scala\nobject Hello extends App{\n    println(\"Hello, World!\")\n}\n\n//在EPFL中运行 Hello.main(null)\n```\n如果需要命令行参数，可以通过args属性得到，\n\n```scala\nobject Hello extends App{\n    if (args.length > 0) {\n        println(\"Hello, \" + args(0))\n    } else\n        println(\"Hello, World!\")\n}\n\n//创建Hello.scala把上面代码拷贝进去\n//scalac Hello.scala\n//scala  -Dscala.time Hello Fred\n//输出以下内容（-Dscala.time是运行时间）：\n//  Hello, World!\n//  [total 49ms] \n```\n\n### 枚举\nscala中没有枚举类型。标准库里提供了一个Enumeration类，可以产出枚举。\n\n```scala\nobject Color extends Enumeration {\n    val Red, Yellow, Green = Value\n    /*\n    相当于以下代码\n    val Red = Value\n    val Yellow = Value\n    val Green = Value\n    */\n}\n```\nValue是一对伴生的类和对象。每个Value对象有自己的ID和名称。可以手动设置。\n\n```scala\nobject Color extends Enumeration {\n    val Red = Value(0, \"Stop\")\n    val Yellow = Value(10) // 名称为“Yellow”\n    val Green = Value(\"Go\") // ID为11\n}\n\nColor.Red\n//Color.Value = Stop\nColor.Green.id\n//Int = 11\nColor.values\n//Color.ValueSet = Color.ValueSet(Stop, Yellow, Go)\n//可用for(c <- Color.values)来遍历这个set\n```\n\n* 如果没有手动设置枚举名称默认为变量名。\n* 如果没有手动设置枚举ID默认为前一个加1，从零开始。\n\n如果不想使用对象名调用枚举，可以import一下。就可以只简写了。\n\n```scala\nimport Color._\nRed\n//Color.Value = Stop\n```\n枚举的类型是Color.Value而不是Color。可以用type起个别名，给Color.Value起个别名Color.Color，再使用import Color._ 。这样看起来就好像枚举的类型是Color，而实际上在使用的是Color.Color。（真拗口）\n\n```scala\nimport color._\n\nobject Color extends Enumeration {\n    type Color = Value\n    val Red, Yellow, Green = Value\n}\n\ndef doWhat(color: Color) = {//实际上是Color.Color\n    ...\n}\n```\n可以用ID或者名称来进行定位，以下两行代码输出都是Color.Red对象：\n\n```scala\nColor(0) //将调用Color.apply\n//返回 Color.Value = Stop\nColor.withName(\"Yellow\")\n//返回 Color.Value = Yellow\n```\n\n\n","slug":"Chapter-06-对象","published":1,"updated":"2017-11-25T06:28:50.496Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjahvvnx8000bpv4n8grop8gy","content":"<h2><span id=\"chapter-06-对象\"> Chapter-06-对象</span></h2>\n<p>对象 object</p>\n<hr>\n<h3><span id=\"单例对象\"> 单例对象</span></h3>\n<p>scala中没有静态方法和字段。只要的功效可以用object语法来实现。(object定义其实就是具体某个类的单例)</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">object</span> <span class=\"title\">Accounts</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">var</span> lastNumber = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">newUniqueNumber</span></span>() = &#123; lastNumber += <span class=\"number\">1</span>; lastNumber &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">Accounts</span>.newUniqueNumber</span><br><span class=\"line\"><span class=\"comment\">// 1</span></span><br><span class=\"line\"><span class=\"type\">Accounts</span>.newUniqueNumber</span><br><span class=\"line\"><span class=\"comment\">// 2</span></span><br></pre></td></tr></table></figure>\n<p>对象也可以继承其他类和特质（类似接口）。但是不能定义自己的构造函数。</p>\n<h3><span id=\"伴生对象\"> 伴生对象</span></h3>\n<p>在java中会有既有成员方法又有静态方法的类。在scala中，可以用伴生对象来达到目的。</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Account</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">val</span> id = <span class=\"type\">Account</span>.newUniqueNumber() <span class=\"comment\">//访问伴生对象的私有方法</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">object</span> <span class=\"title\">Accout</span> </span>&#123; <span class=\"comment\">// 伴生对象</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">var</span> lastNumber = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">newUniqueNumber</span></span>() = &#123; lastNumber += <span class=\"number\">1</span>; lastNumber &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如果类和其伴生对象在同一个源文件中，它们可以互相访问对方的private特性。</p>\n<p>在调用伴生对象方法时，要Account.newUniqueNumber()，不能直接写newUniqueNumber()。</p>\n<h3><span id=\"继承类或特质的对象\"> 继承类或特质的对象</span></h3>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">UndoableAction</span>(<span class=\"params\">val description: <span class=\"type\">String</span></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">undo</span></span>(): <span class=\"type\">Unit</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">redo</span></span>(): <span class=\"type\">Unit</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">object</span> <span class=\"title\">DoNothingAction</span> <span class=\"keyword\">extends</span> <span class=\"title\">UndoableAction</span>(<span class=\"params\">\"<span class=\"type\">Do</span> nothing\"</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">undo</span></span>() &#123;&#125;</span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">undo</span></span>() &#123;&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">val</span> actions = <span class=\"type\">Map</span>(<span class=\"string\">\"open\"</span> -&gt; <span class=\"type\">DoNothingAction</span>, <span class=\"string\">\"save\"</span> -&gt; <span class=\"type\">DoNothingAction</span>) <span class=\"comment\">//value使用DoNothingAction对象</span></span><br></pre></td></tr></table></figure>\n<h3><span id=\"apply方法\"> apply方法</span></h3>\n<p>apply方法被定义在伴生对象中，定义之后会可以像如下代码一样使用它：</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Account</span> <span class=\"title\">private</span> (<span class=\"params\">val id: <span class=\"type\">Int</span>, initBalance: <span class=\"type\">Double</span></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">var</span> balance = initBalance</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">object</span> <span class=\"title\">Account</span> </span>&#123; <span class=\"comment\">//伴生对象</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">apply</span></span>(initBalance: <span class=\"type\">Double</span>) = <span class=\"keyword\">new</span> <span class=\"type\">Account</span>(<span class=\"number\">1986</span>, initBalance)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">val</span> acct = <span class=\"type\">Account</span>(<span class=\"number\">1000.0</span>) <span class=\"comment\">//实际调用的是apply方法，等价于Account.apply(1000.0)</span></span><br></pre></td></tr></table></figure>\n<p>伴生对象以下格式，apply方法会被调用，一般它会返回一个伴生对象所对应类的对象：</p>\n<blockquote>\n<p><em>对象名(参数1,参数2…,参数N)</em></p>\n</blockquote>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">Array</span>(<span class=\"string\">\"Mary\"</span>, <span class=\"string\">\"had\"</span>, <span class=\"string\">\"a\"</span>, <span class=\"string\">\"little\"</span>, <span class=\"string\">\"lamb\"</span>)</span><br><span class=\"line\"><span class=\"comment\">//等价于</span></span><br><span class=\"line\"><span class=\"type\">Array</span>.apply(<span class=\"string\">\"Mary\"</span>, <span class=\"string\">\"had\"</span>, <span class=\"string\">\"a\"</span>, <span class=\"string\">\"little\"</span>, <span class=\"string\">\"lamb\"</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">Array</span>(<span class=\"number\">100</span>)</span><br><span class=\"line\"><span class=\"comment\">//返回一个只有一个元素的Int数组</span></span><br><span class=\"line\"><span class=\"keyword\">new</span> <span class=\"type\">Array</span>(<span class=\"number\">100</span>)</span><br><span class=\"line\"><span class=\"comment\">//返回一个有100个null元素的Array[Nothing]</span></span><br></pre></td></tr></table></figure>\n<h3><span id=\"应用对象\"> 应用对象</span></h3>\n<p>scala中的main方法写到一个对象里。方法类型为Array[String] =&gt; Unit:</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">object</span> <span class=\"title\">Hello</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">main</span></span>(args: <span class=\"type\">Array</span>[<span class=\"type\">String</span>]) &#123;</span><br><span class=\"line\">        println(<span class=\"string\">\"Hello, World!\"</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>也可以继承App特质，</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">object</span> <span class=\"title\">Hello</span> <span class=\"keyword\">extends</span> <span class=\"title\">App</span></span>&#123;</span><br><span class=\"line\">    println(<span class=\"string\">\"Hello, World!\"</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//在EPFL中运行 Hello.main(null)</span></span><br></pre></td></tr></table></figure>\n<p>如果需要命令行参数，可以通过args属性得到，</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">object</span> <span class=\"title\">Hello</span> <span class=\"keyword\">extends</span> <span class=\"title\">App</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (args.length &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        println(<span class=\"string\">\"Hello, \"</span> + args(<span class=\"number\">0</span>))</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span></span><br><span class=\"line\">        println(<span class=\"string\">\"Hello, World!\"</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//创建Hello.scala把上面代码拷贝进去</span></span><br><span class=\"line\"><span class=\"comment\">//scalac Hello.scala</span></span><br><span class=\"line\"><span class=\"comment\">//scala  -Dscala.time Hello Fred</span></span><br><span class=\"line\"><span class=\"comment\">//输出以下内容（-Dscala.time是运行时间）：</span></span><br><span class=\"line\"><span class=\"comment\">//  Hello, World!</span></span><br><span class=\"line\"><span class=\"comment\">//  [total 49ms]</span></span><br></pre></td></tr></table></figure>\n<h3><span id=\"枚举\"> 枚举</span></h3>\n<p>scala中没有枚举类型。标准库里提供了一个Enumeration类，可以产出枚举。</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">object</span> <span class=\"title\">Color</span> <span class=\"keyword\">extends</span> <span class=\"title\">Enumeration</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">val</span> <span class=\"type\">Red</span>, <span class=\"type\">Yellow</span>, <span class=\"type\">Green</span> = <span class=\"type\">Value</span></span><br><span class=\"line\">    <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">    相当于以下代码</span></span><br><span class=\"line\"><span class=\"comment\">    val Red = Value</span></span><br><span class=\"line\"><span class=\"comment\">    val Yellow = Value</span></span><br><span class=\"line\"><span class=\"comment\">    val Green = Value</span></span><br><span class=\"line\"><span class=\"comment\">    */</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Value是一对伴生的类和对象。每个Value对象有自己的ID和名称。可以手动设置。</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">object</span> <span class=\"title\">Color</span> <span class=\"keyword\">extends</span> <span class=\"title\">Enumeration</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">val</span> <span class=\"type\">Red</span> = <span class=\"type\">Value</span>(<span class=\"number\">0</span>, <span class=\"string\">\"Stop\"</span>)</span><br><span class=\"line\">    <span class=\"keyword\">val</span> <span class=\"type\">Yellow</span> = <span class=\"type\">Value</span>(<span class=\"number\">10</span>) <span class=\"comment\">// 名称为“Yellow”</span></span><br><span class=\"line\">    <span class=\"keyword\">val</span> <span class=\"type\">Green</span> = <span class=\"type\">Value</span>(<span class=\"string\">\"Go\"</span>) <span class=\"comment\">// ID为11</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">Color</span>.<span class=\"type\">Red</span></span><br><span class=\"line\"><span class=\"comment\">//Color.Value = Stop</span></span><br><span class=\"line\"><span class=\"type\">Color</span>.<span class=\"type\">Green</span>.id</span><br><span class=\"line\"><span class=\"comment\">//Int = 11</span></span><br><span class=\"line\"><span class=\"type\">Color</span>.values</span><br><span class=\"line\"><span class=\"comment\">//Color.ValueSet = Color.ValueSet(Stop, Yellow, Go)</span></span><br><span class=\"line\"><span class=\"comment\">//可用for(c &lt;- Color.values)来遍历这个set</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>如果没有手动设置枚举名称默认为变量名。</li>\n<li>如果没有手动设置枚举ID默认为前一个加1，从零开始。</li>\n</ul>\n<p>如果不想使用对象名调用枚举，可以import一下。就可以只简写了。</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"type\">Color</span>._</span><br><span class=\"line\"><span class=\"type\">Red</span></span><br><span class=\"line\"><span class=\"comment\">//Color.Value = Stop</span></span><br></pre></td></tr></table></figure>\n<p>枚举的类型是Color.Value而不是Color。可以用type起个别名，给Color.Value起个别名Color.Color，再使用import Color._ 。这样看起来就好像枚举的类型是Color，而实际上在使用的是Color.Color。（真拗口）</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> color._</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">object</span> <span class=\"title\">Color</span> <span class=\"keyword\">extends</span> <span class=\"title\">Enumeration</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">type</span> <span class=\"title\">Color</span> </span>= <span class=\"type\">Value</span></span><br><span class=\"line\">    <span class=\"keyword\">val</span> <span class=\"type\">Red</span>, <span class=\"type\">Yellow</span>, <span class=\"type\">Green</span> = <span class=\"type\">Value</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">doWhat</span></span>(color: <span class=\"type\">Color</span>) = &#123;<span class=\"comment\">//实际上是Color.Color</span></span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>可以用ID或者名称来进行定位，以下两行代码输出都是Color.Red对象：</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">Color</span>(<span class=\"number\">0</span>) <span class=\"comment\">//将调用Color.apply</span></span><br><span class=\"line\"><span class=\"comment\">//返回 Color.Value = Stop</span></span><br><span class=\"line\"><span class=\"type\">Color</span>.withName(<span class=\"string\">\"Yellow\"</span>)</span><br><span class=\"line\"><span class=\"comment\">//返回 Color.Value = Yellow</span></span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"chapter-06-对象\"><a class=\"markdownIt-Anchor\" href=\"#chapter-06-对象\"></a> Chapter-06-对象</h2>\n<p>对象 object</p>\n<hr>\n<h3 id=\"单例对象\"><a class=\"markdownIt-Anchor\" href=\"#单例对象\"></a> 单例对象</h3>\n<p>scala中没有静态方法和字段。只要的功效可以用object语法来实现。(object定义其实就是具体某个类的单例)</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">object</span> <span class=\"title\">Accounts</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">var</span> lastNumber = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">newUniqueNumber</span></span>() = &#123; lastNumber += <span class=\"number\">1</span>; lastNumber &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">Accounts</span>.newUniqueNumber</span><br><span class=\"line\"><span class=\"comment\">// 1</span></span><br><span class=\"line\"><span class=\"type\">Accounts</span>.newUniqueNumber</span><br><span class=\"line\"><span class=\"comment\">// 2</span></span><br></pre></td></tr></table></figure>\n<p>对象也可以继承其他类和特质（类似接口）。但是不能定义自己的构造函数。</p>\n<h3 id=\"伴生对象\"><a class=\"markdownIt-Anchor\" href=\"#伴生对象\"></a> 伴生对象</h3>\n<p>在java中会有既有成员方法又有静态方法的类。在scala中，可以用伴生对象来达到目的。</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Account</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">val</span> id = <span class=\"type\">Account</span>.newUniqueNumber() <span class=\"comment\">//访问伴生对象的私有方法</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">object</span> <span class=\"title\">Accout</span> </span>&#123; <span class=\"comment\">// 伴生对象</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">var</span> lastNumber = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">newUniqueNumber</span></span>() = &#123; lastNumber += <span class=\"number\">1</span>; lastNumber &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如果类和其伴生对象在同一个源文件中，它们可以互相访问对方的private特性。</p>\n<p>在调用伴生对象方法时，要Account.newUniqueNumber()，不能直接写newUniqueNumber()。</p>\n<h3 id=\"继承类或特质的对象\"><a class=\"markdownIt-Anchor\" href=\"#继承类或特质的对象\"></a> 继承类或特质的对象</h3>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">UndoableAction</span>(<span class=\"params\">val description: <span class=\"type\">String</span></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">undo</span></span>(): <span class=\"type\">Unit</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">redo</span></span>(): <span class=\"type\">Unit</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">object</span> <span class=\"title\">DoNothingAction</span> <span class=\"keyword\">extends</span> <span class=\"title\">UndoableAction</span>(<span class=\"params\">\"<span class=\"type\">Do</span> nothing\"</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">undo</span></span>() &#123;&#125;</span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">undo</span></span>() &#123;&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">val</span> actions = <span class=\"type\">Map</span>(<span class=\"string\">\"open\"</span> -&gt; <span class=\"type\">DoNothingAction</span>, <span class=\"string\">\"save\"</span> -&gt; <span class=\"type\">DoNothingAction</span>) <span class=\"comment\">//value使用DoNothingAction对象</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"apply方法\"><a class=\"markdownIt-Anchor\" href=\"#apply方法\"></a> apply方法</h3>\n<p>apply方法被定义在伴生对象中，定义之后会可以像如下代码一样使用它：</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Account</span> <span class=\"title\">private</span> (<span class=\"params\">val id: <span class=\"type\">Int</span>, initBalance: <span class=\"type\">Double</span></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">var</span> balance = initBalance</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">object</span> <span class=\"title\">Account</span> </span>&#123; <span class=\"comment\">//伴生对象</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">apply</span></span>(initBalance: <span class=\"type\">Double</span>) = <span class=\"keyword\">new</span> <span class=\"type\">Account</span>(<span class=\"number\">1986</span>, initBalance)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">val</span> acct = <span class=\"type\">Account</span>(<span class=\"number\">1000.0</span>) <span class=\"comment\">//实际调用的是apply方法，等价于Account.apply(1000.0)</span></span><br></pre></td></tr></table></figure>\n<p>伴生对象以下格式，apply方法会被调用，一般它会返回一个伴生对象所对应类的对象：</p>\n<blockquote>\n<p><em>对象名(参数1,参数2…,参数N)</em></p>\n</blockquote>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">Array</span>(<span class=\"string\">\"Mary\"</span>, <span class=\"string\">\"had\"</span>, <span class=\"string\">\"a\"</span>, <span class=\"string\">\"little\"</span>, <span class=\"string\">\"lamb\"</span>)</span><br><span class=\"line\"><span class=\"comment\">//等价于</span></span><br><span class=\"line\"><span class=\"type\">Array</span>.apply(<span class=\"string\">\"Mary\"</span>, <span class=\"string\">\"had\"</span>, <span class=\"string\">\"a\"</span>, <span class=\"string\">\"little\"</span>, <span class=\"string\">\"lamb\"</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">Array</span>(<span class=\"number\">100</span>)</span><br><span class=\"line\"><span class=\"comment\">//返回一个只有一个元素的Int数组</span></span><br><span class=\"line\"><span class=\"keyword\">new</span> <span class=\"type\">Array</span>(<span class=\"number\">100</span>)</span><br><span class=\"line\"><span class=\"comment\">//返回一个有100个null元素的Array[Nothing]</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"应用对象\"><a class=\"markdownIt-Anchor\" href=\"#应用对象\"></a> 应用对象</h3>\n<p>scala中的main方法写到一个对象里。方法类型为Array[String] =&gt; Unit:</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">object</span> <span class=\"title\">Hello</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">main</span></span>(args: <span class=\"type\">Array</span>[<span class=\"type\">String</span>]) &#123;</span><br><span class=\"line\">        println(<span class=\"string\">\"Hello, World!\"</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>也可以继承App特质，</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">object</span> <span class=\"title\">Hello</span> <span class=\"keyword\">extends</span> <span class=\"title\">App</span></span>&#123;</span><br><span class=\"line\">    println(<span class=\"string\">\"Hello, World!\"</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//在EPFL中运行 Hello.main(null)</span></span><br></pre></td></tr></table></figure>\n<p>如果需要命令行参数，可以通过args属性得到，</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">object</span> <span class=\"title\">Hello</span> <span class=\"keyword\">extends</span> <span class=\"title\">App</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (args.length &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        println(<span class=\"string\">\"Hello, \"</span> + args(<span class=\"number\">0</span>))</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span></span><br><span class=\"line\">        println(<span class=\"string\">\"Hello, World!\"</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//创建Hello.scala把上面代码拷贝进去</span></span><br><span class=\"line\"><span class=\"comment\">//scalac Hello.scala</span></span><br><span class=\"line\"><span class=\"comment\">//scala  -Dscala.time Hello Fred</span></span><br><span class=\"line\"><span class=\"comment\">//输出以下内容（-Dscala.time是运行时间）：</span></span><br><span class=\"line\"><span class=\"comment\">//  Hello, World!</span></span><br><span class=\"line\"><span class=\"comment\">//  [total 49ms]</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"枚举\"><a class=\"markdownIt-Anchor\" href=\"#枚举\"></a> 枚举</h3>\n<p>scala中没有枚举类型。标准库里提供了一个Enumeration类，可以产出枚举。</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">object</span> <span class=\"title\">Color</span> <span class=\"keyword\">extends</span> <span class=\"title\">Enumeration</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">val</span> <span class=\"type\">Red</span>, <span class=\"type\">Yellow</span>, <span class=\"type\">Green</span> = <span class=\"type\">Value</span></span><br><span class=\"line\">    <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">    相当于以下代码</span></span><br><span class=\"line\"><span class=\"comment\">    val Red = Value</span></span><br><span class=\"line\"><span class=\"comment\">    val Yellow = Value</span></span><br><span class=\"line\"><span class=\"comment\">    val Green = Value</span></span><br><span class=\"line\"><span class=\"comment\">    */</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Value是一对伴生的类和对象。每个Value对象有自己的ID和名称。可以手动设置。</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">object</span> <span class=\"title\">Color</span> <span class=\"keyword\">extends</span> <span class=\"title\">Enumeration</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">val</span> <span class=\"type\">Red</span> = <span class=\"type\">Value</span>(<span class=\"number\">0</span>, <span class=\"string\">\"Stop\"</span>)</span><br><span class=\"line\">    <span class=\"keyword\">val</span> <span class=\"type\">Yellow</span> = <span class=\"type\">Value</span>(<span class=\"number\">10</span>) <span class=\"comment\">// 名称为“Yellow”</span></span><br><span class=\"line\">    <span class=\"keyword\">val</span> <span class=\"type\">Green</span> = <span class=\"type\">Value</span>(<span class=\"string\">\"Go\"</span>) <span class=\"comment\">// ID为11</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">Color</span>.<span class=\"type\">Red</span></span><br><span class=\"line\"><span class=\"comment\">//Color.Value = Stop</span></span><br><span class=\"line\"><span class=\"type\">Color</span>.<span class=\"type\">Green</span>.id</span><br><span class=\"line\"><span class=\"comment\">//Int = 11</span></span><br><span class=\"line\"><span class=\"type\">Color</span>.values</span><br><span class=\"line\"><span class=\"comment\">//Color.ValueSet = Color.ValueSet(Stop, Yellow, Go)</span></span><br><span class=\"line\"><span class=\"comment\">//可用for(c &lt;- Color.values)来遍历这个set</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>如果没有手动设置枚举名称默认为变量名。</li>\n<li>如果没有手动设置枚举ID默认为前一个加1，从零开始。</li>\n</ul>\n<p>如果不想使用对象名调用枚举，可以import一下。就可以只简写了。</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"type\">Color</span>._</span><br><span class=\"line\"><span class=\"type\">Red</span></span><br><span class=\"line\"><span class=\"comment\">//Color.Value = Stop</span></span><br></pre></td></tr></table></figure>\n<p>枚举的类型是Color.Value而不是Color。可以用type起个别名，给Color.Value起个别名Color.Color，再使用import Color._ 。这样看起来就好像枚举的类型是Color，而实际上在使用的是Color.Color。（真拗口）</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> color._</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">object</span> <span class=\"title\">Color</span> <span class=\"keyword\">extends</span> <span class=\"title\">Enumeration</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">type</span> <span class=\"title\">Color</span> </span>= <span class=\"type\">Value</span></span><br><span class=\"line\">    <span class=\"keyword\">val</span> <span class=\"type\">Red</span>, <span class=\"type\">Yellow</span>, <span class=\"type\">Green</span> = <span class=\"type\">Value</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">doWhat</span></span>(color: <span class=\"type\">Color</span>) = &#123;<span class=\"comment\">//实际上是Color.Color</span></span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>可以用ID或者名称来进行定位，以下两行代码输出都是Color.Red对象：</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">Color</span>(<span class=\"number\">0</span>) <span class=\"comment\">//将调用Color.apply</span></span><br><span class=\"line\"><span class=\"comment\">//返回 Color.Value = Stop</span></span><br><span class=\"line\"><span class=\"type\">Color</span>.withName(<span class=\"string\">\"Yellow\"</span>)</span><br><span class=\"line\"><span class=\"comment\">//返回 Color.Value = Yellow</span></span><br></pre></td></tr></table></figure>\n"},{"title":"Chapter-07-包和引入","catalog":true,"date":"2015-06-22T09:21:29.000Z","header-img":"/img/04.jpg","_content":"\n## Chapter-07-包和引入\n\n包 引入 import package\n\n---\n\n### 包\nscala中的包和C++的命名空间和java中的包概念是相同的，只不过它和目录没有直接关系，是一个虚拟的关系，在代码中定义。\n\n```scala\npackage com {\n  package horstmann {\n    package  impatient {\n      class Employee\n    }\n  }\n}\n```\n\n* scala的包和目录不是强一致的，Employee完全可以不放在com/horstmann/impatient/这个目录下。\n* 包可以定义在任何源文件中。\n* 如果在相同或不同的源文件中定义了完全相同的冲突内容，会在编译时报“重复定义”的错误。\n\n### 包的作用域\n与java不同的是，scala的子包在以下代码方式时，不用import就有使用父包作用域的权力。\n\n```scala\npackage com {\n  package horstmann {\n\n    object Util{\n      def printObj(obj:Any) = println(obj.toString)\n    }\n\n    package  impatient {\n      class Employee(name:String){\n        override def toString = name\n      }\n      object Employee {\n        Util.printObj(new Employee(\"allon\")) // 注意Util是父包中的对象。不需要写成com.horstmann.Util。\n      }\n    }\n  }\n}\n```\nscala中的包路径是相对的\n\n```scala\npackage com {\n  package horstmann {\n    package  util{\n      object Properties {\n        def printObj(obj:Any) = println(obj.toString)\n      }\n    }\n\n    package  impatient {\n      class Employee(name:String){\n        override def toString = name\n      }\n      object Employee {\n        def apply(): Unit ={\n          util.Properties.printObj(new Employee(\"allon\")) //不能直接使用Properties而要使用util.Properties。\n        }\n      }\n    }\n  }\n}\n```\n以上代码访问Properties可以使用\n1. util.Peroperties\n2. com.horstmann.util.Peroperties\n3. 定义绝对路径_root_.com.horstmann.util.Peroperties\n4. 如果想使用的是scala标准库中的util.Peroperties会出现冲突，最好写全路径scala.util.Peroperties\n\n### 文件顶部定义包\n如果把包语句写成像java一样的串，作用域就会和java类似了。\n\n```scala\npackage com.horstmann {\n    object UtilA\n}\n\npackage com.horstmann.impatient {\n    object UtilB\n    class Employee {\n        //在这里com和com.horstmann作用域的成员是不可见的。\n        UtilA //错误，不可见\n        UtilB //可见\n    }\n}\n```\nscala也可以在文件顶部定义包\n\n```scala\npackage com.horstmann.impatient\npackage people\nclass Person\n// 这等价于\npackage com.horstmann.impatient {\n    package people {\n        class Person\n    }\n}\n```\n### 包对象\n包里可以定义类、对象和特质，但是因为jvm的局限不能定义函数。为了解决这个问题，引入了包对象的概念。\n\n每个包都可以定义一个和它同名的包对象。（有些像伴生对象）\n\n```scala\npackage com.horstmann.impatient\n\npackage object people {\n    val defaultName = \"allon\"\n}\n\npackage people {\n    package people {\n        class Person(val name:String = defaultName) //使用的是包对象中的默认值。这里的defaultName不用写全路径，因为它们在同一个包中，外部使用时可以com.horstmann.impatient.people.defaultName来使用。\n    }\n}\n```\n在jvm中，包对象被编译成package.class，并置于相应的包下。一般可以把包对象放到com/horstmann/impatient/people/package.scala。\n\n### 包的可见性及import\n可以指定字段在哪些父包中可见\n\n```scala\nclass Person(private[horstmann] val name:String = defaultName)\n```\n\n#### import\n\n```scala\nimport java.awt._\n//等价于java中的java.awt.*\n```\n在scala中完全可以定义com.horstmann.impatient.*.people，但是这么干等于在坑人。\n\nimport的语句在scala中可以放在任何地方。并不一定要文件顶部。\n\n```scala\nclass Manager {\n    import scala.collection.mutable._\n    val subordinates = new ArrayBuffer[Employee]\n}\n```\n#### import时的重命名和部分引入\n\n```scala\nimport java.util.{HashMap => JavaHashMap} //重命名为JavaHashMap，这样可以避免一些冲突。\nimport java.awt.{Color, Font} \n//只引入Color和Font\nimport java.util.{HashMap => _, _} \n//HashMap => _ 表示隐藏掉HashMap，第二个下划线表示通配符全部。这个import整个含义是：除了HashMap都引入。\n```\n\n#### 隐式import\n就是scala“偷偷”的帮我们已经引入了scala开头的包。因而我们在使用scala开头的包时，我们才可以省略掉“scala”。\n\n```scala\nimport scala.collection.mutable._\n//因为偷偷引入了scala包，所以也可以省略\"scala\"，从而和下面的import等价\nimport collection.mutable._\n```\n\n\n","source":"_posts/Chapter-07-包和引入.md","raw":"---\ntitle: 'Chapter-07-包和引入'\ncatalog: true\ndate: 2015-06-22 17:21:29\nheader-img: \"/img/04.jpg\"\ntags: \"scala\"\n---\n\n## Chapter-07-包和引入\n\n包 引入 import package\n\n---\n\n### 包\nscala中的包和C++的命名空间和java中的包概念是相同的，只不过它和目录没有直接关系，是一个虚拟的关系，在代码中定义。\n\n```scala\npackage com {\n  package horstmann {\n    package  impatient {\n      class Employee\n    }\n  }\n}\n```\n\n* scala的包和目录不是强一致的，Employee完全可以不放在com/horstmann/impatient/这个目录下。\n* 包可以定义在任何源文件中。\n* 如果在相同或不同的源文件中定义了完全相同的冲突内容，会在编译时报“重复定义”的错误。\n\n### 包的作用域\n与java不同的是，scala的子包在以下代码方式时，不用import就有使用父包作用域的权力。\n\n```scala\npackage com {\n  package horstmann {\n\n    object Util{\n      def printObj(obj:Any) = println(obj.toString)\n    }\n\n    package  impatient {\n      class Employee(name:String){\n        override def toString = name\n      }\n      object Employee {\n        Util.printObj(new Employee(\"allon\")) // 注意Util是父包中的对象。不需要写成com.horstmann.Util。\n      }\n    }\n  }\n}\n```\nscala中的包路径是相对的\n\n```scala\npackage com {\n  package horstmann {\n    package  util{\n      object Properties {\n        def printObj(obj:Any) = println(obj.toString)\n      }\n    }\n\n    package  impatient {\n      class Employee(name:String){\n        override def toString = name\n      }\n      object Employee {\n        def apply(): Unit ={\n          util.Properties.printObj(new Employee(\"allon\")) //不能直接使用Properties而要使用util.Properties。\n        }\n      }\n    }\n  }\n}\n```\n以上代码访问Properties可以使用\n1. util.Peroperties\n2. com.horstmann.util.Peroperties\n3. 定义绝对路径_root_.com.horstmann.util.Peroperties\n4. 如果想使用的是scala标准库中的util.Peroperties会出现冲突，最好写全路径scala.util.Peroperties\n\n### 文件顶部定义包\n如果把包语句写成像java一样的串，作用域就会和java类似了。\n\n```scala\npackage com.horstmann {\n    object UtilA\n}\n\npackage com.horstmann.impatient {\n    object UtilB\n    class Employee {\n        //在这里com和com.horstmann作用域的成员是不可见的。\n        UtilA //错误，不可见\n        UtilB //可见\n    }\n}\n```\nscala也可以在文件顶部定义包\n\n```scala\npackage com.horstmann.impatient\npackage people\nclass Person\n// 这等价于\npackage com.horstmann.impatient {\n    package people {\n        class Person\n    }\n}\n```\n### 包对象\n包里可以定义类、对象和特质，但是因为jvm的局限不能定义函数。为了解决这个问题，引入了包对象的概念。\n\n每个包都可以定义一个和它同名的包对象。（有些像伴生对象）\n\n```scala\npackage com.horstmann.impatient\n\npackage object people {\n    val defaultName = \"allon\"\n}\n\npackage people {\n    package people {\n        class Person(val name:String = defaultName) //使用的是包对象中的默认值。这里的defaultName不用写全路径，因为它们在同一个包中，外部使用时可以com.horstmann.impatient.people.defaultName来使用。\n    }\n}\n```\n在jvm中，包对象被编译成package.class，并置于相应的包下。一般可以把包对象放到com/horstmann/impatient/people/package.scala。\n\n### 包的可见性及import\n可以指定字段在哪些父包中可见\n\n```scala\nclass Person(private[horstmann] val name:String = defaultName)\n```\n\n#### import\n\n```scala\nimport java.awt._\n//等价于java中的java.awt.*\n```\n在scala中完全可以定义com.horstmann.impatient.*.people，但是这么干等于在坑人。\n\nimport的语句在scala中可以放在任何地方。并不一定要文件顶部。\n\n```scala\nclass Manager {\n    import scala.collection.mutable._\n    val subordinates = new ArrayBuffer[Employee]\n}\n```\n#### import时的重命名和部分引入\n\n```scala\nimport java.util.{HashMap => JavaHashMap} //重命名为JavaHashMap，这样可以避免一些冲突。\nimport java.awt.{Color, Font} \n//只引入Color和Font\nimport java.util.{HashMap => _, _} \n//HashMap => _ 表示隐藏掉HashMap，第二个下划线表示通配符全部。这个import整个含义是：除了HashMap都引入。\n```\n\n#### 隐式import\n就是scala“偷偷”的帮我们已经引入了scala开头的包。因而我们在使用scala开头的包时，我们才可以省略掉“scala”。\n\n```scala\nimport scala.collection.mutable._\n//因为偷偷引入了scala包，所以也可以省略\"scala\"，从而和下面的import等价\nimport collection.mutable._\n```\n\n\n","slug":"Chapter-07-包和引入","published":1,"updated":"2017-11-25T06:28:50.496Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjahvvnxa000dpv4nohkiyqvx","content":"<h2><span id=\"chapter-07-包和引入\"> Chapter-07-包和引入</span></h2>\n<p>包 引入 import package</p>\n<hr>\n<h3><span id=\"包\"> 包</span></h3>\n<p>scala中的包和C++的命名空间和java中的包概念是相同的，只不过它和目录没有直接关系，是一个虚拟的关系，在代码中定义。</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com &#123;</span><br><span class=\"line\">  <span class=\"keyword\">package</span> horstmann &#123;</span><br><span class=\"line\">    <span class=\"keyword\">package</span>  impatient &#123;</span><br><span class=\"line\">      <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Employee</span></span></span><br><span class=\"line\"><span class=\"class\">    &#125;</span></span><br><span class=\"line\"><span class=\"class\">  &#125;</span></span><br><span class=\"line\"><span class=\"class\">&#125;</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>scala的包和目录不是强一致的，Employee完全可以不放在com/horstmann/impatient/这个目录下。</li>\n<li>包可以定义在任何源文件中。</li>\n<li>如果在相同或不同的源文件中定义了完全相同的冲突内容，会在编译时报“重复定义”的错误。</li>\n</ul>\n<h3><span id=\"包的作用域\"> 包的作用域</span></h3>\n<p>与java不同的是，scala的子包在以下代码方式时，不用import就有使用父包作用域的权力。</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com &#123;</span><br><span class=\"line\">  <span class=\"keyword\">package</span> horstmann &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">object</span> <span class=\"title\">Util</span></span>&#123;</span><br><span class=\"line\">      <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">printObj</span></span>(obj:<span class=\"type\">Any</span>) = println(obj.toString)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">package</span>  impatient &#123;</span><br><span class=\"line\">      <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Employee</span>(<span class=\"params\">name:<span class=\"type\">String</span></span>)</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">toString</span> </span>= name</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"class\"><span class=\"keyword\">object</span> <span class=\"title\">Employee</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"type\">Util</span>.printObj(<span class=\"keyword\">new</span> <span class=\"type\">Employee</span>(<span class=\"string\">\"allon\"</span>)) <span class=\"comment\">// 注意Util是父包中的对象。不需要写成com.horstmann.Util。</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>scala中的包路径是相对的</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com &#123;</span><br><span class=\"line\">  <span class=\"keyword\">package</span> horstmann &#123;</span><br><span class=\"line\">    <span class=\"keyword\">package</span>  util&#123;</span><br><span class=\"line\">      <span class=\"class\"><span class=\"keyword\">object</span> <span class=\"title\">Properties</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">printObj</span></span>(obj:<span class=\"type\">Any</span>) = println(obj.toString)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">package</span>  impatient &#123;</span><br><span class=\"line\">      <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Employee</span>(<span class=\"params\">name:<span class=\"type\">String</span></span>)</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">toString</span> </span>= name</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"class\"><span class=\"keyword\">object</span> <span class=\"title\">Employee</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">apply</span></span>(): <span class=\"type\">Unit</span> =&#123;</span><br><span class=\"line\">          util.<span class=\"type\">Properties</span>.printObj(<span class=\"keyword\">new</span> <span class=\"type\">Employee</span>(<span class=\"string\">\"allon\"</span>)) <span class=\"comment\">//不能直接使用Properties而要使用util.Properties。</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>以上代码访问Properties可以使用</p>\n<ol>\n<li>util.Peroperties</li>\n<li>com.horstmann.util.Peroperties</li>\n<li>定义绝对路径_root_.com.horstmann.util.Peroperties</li>\n<li>如果想使用的是scala标准库中的util.Peroperties会出现冲突，最好写全路径scala.util.Peroperties</li>\n</ol>\n<h3><span id=\"文件顶部定义包\"> 文件顶部定义包</span></h3>\n<p>如果把包语句写成像java一样的串，作用域就会和java类似了。</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.horstmann &#123;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">object</span> <span class=\"title\">UtilA</span></span></span><br><span class=\"line\"><span class=\"class\">&#125;</span></span><br><span class=\"line\"><span class=\"class\"></span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">package</span> <span class=\"title\">com</span>.<span class=\"title\">horstmann</span>.<span class=\"title\">impatient</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">object</span> <span class=\"title\">UtilB</span></span></span><br><span class=\"line\"><span class=\"class\">    <span class=\"title\">class</span> <span class=\"title\">Employee</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//在这里com和com.horstmann作用域的成员是不可见的。</span></span><br><span class=\"line\">        <span class=\"type\">UtilA</span> <span class=\"comment\">//错误，不可见</span></span><br><span class=\"line\">        <span class=\"type\">UtilB</span> <span class=\"comment\">//可见</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>scala也可以在文件顶部定义包</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.horstmann.impatient</span><br><span class=\"line\"><span class=\"keyword\">package</span> people</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span></span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">//</span> <span class=\"title\">这等价于</span></span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">package</span> <span class=\"title\">com</span>.<span class=\"title\">horstmann</span>.<span class=\"title\">impatient</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">package</span> people &#123;</span><br><span class=\"line\">        <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span></span></span><br><span class=\"line\"><span class=\"class\">    &#125;</span></span><br><span class=\"line\"><span class=\"class\">&#125;</span></span><br></pre></td></tr></table></figure>\n<h3><span id=\"包对象\"> 包对象</span></h3>\n<p>包里可以定义类、对象和特质，但是因为jvm的局限不能定义函数。为了解决这个问题，引入了包对象的概念。</p>\n<p>每个包都可以定义一个和它同名的包对象。（有些像伴生对象）</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.horstmann.impatient</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">package</span> <span class=\"class\"><span class=\"keyword\">object</span> <span class=\"title\">people</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">val</span> defaultName = <span class=\"string\">\"allon\"</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">package</span> people &#123;</span><br><span class=\"line\">    <span class=\"keyword\">package</span> people &#123;</span><br><span class=\"line\">        <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span>(<span class=\"params\">val name:<span class=\"type\">String</span> = defaultName</span>) <span class=\"title\">//使用的是包对象中的默认值。这里的defaultName不用写全路径，因为它们在同一个包中，外部使用时可以com</span>.<span class=\"title\">horstmann</span>.<span class=\"title\">impatient</span>.<span class=\"title\">people</span>.<span class=\"title\">defaultName来使用。</span></span></span><br><span class=\"line\"><span class=\"class\">    &#125;</span></span><br><span class=\"line\"><span class=\"class\">&#125;</span></span><br></pre></td></tr></table></figure>\n<p>在jvm中，包对象被编译成package.class，并置于相应的包下。一般可以把包对象放到com/horstmann/impatient/people/package.scala。</p>\n<h3><span id=\"包的可见性及import\"> 包的可见性及import</span></h3>\n<p>可以指定字段在哪些父包中可见</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span>(<span class=\"params\">private[horstmann] val name:<span class=\"type\">String</span> = defaultName</span>)</span></span><br></pre></td></tr></table></figure>\n<h4><span id=\"import\"> import</span></h4>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.awt._</span><br><span class=\"line\"><span class=\"comment\">//等价于java中的java.awt.*</span></span><br></pre></td></tr></table></figure>\n<p>在scala中完全可以定义com.horstmann.impatient.*.people，但是这么干等于在坑人。</p>\n<p>import的语句在scala中可以放在任何地方。并不一定要文件顶部。</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Manager</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">import</span> scala.collection.mutable._</span><br><span class=\"line\">    <span class=\"keyword\">val</span> subordinates = <span class=\"keyword\">new</span> <span class=\"type\">ArrayBuffer</span>[<span class=\"type\">Employee</span>]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4><span id=\"import时的重命名和部分引入\"> import时的重命名和部分引入</span></h4>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.util.&#123;<span class=\"type\">HashMap</span> =&gt; <span class=\"type\">JavaHashMap</span>&#125; <span class=\"comment\">//重命名为JavaHashMap，这样可以避免一些冲突。</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.awt.&#123;<span class=\"type\">Color</span>, <span class=\"type\">Font</span>&#125; </span><br><span class=\"line\"><span class=\"comment\">//只引入Color和Font</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.&#123;<span class=\"type\">HashMap</span> =&gt; _, _&#125; </span><br><span class=\"line\"><span class=\"comment\">//HashMap =&gt; _ 表示隐藏掉HashMap，第二个下划线表示通配符全部。这个import整个含义是：除了HashMap都引入。</span></span><br></pre></td></tr></table></figure>\n<h4><span id=\"隐式import\"> 隐式import</span></h4>\n<p>就是scala“偷偷”的帮我们已经引入了scala开头的包。因而我们在使用scala开头的包时，我们才可以省略掉“scala”。</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> scala.collection.mutable._</span><br><span class=\"line\"><span class=\"comment\">//因为偷偷引入了scala包，所以也可以省略\"scala\"，从而和下面的import等价</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> collection.mutable._</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"chapter-07-包和引入\"><a class=\"markdownIt-Anchor\" href=\"#chapter-07-包和引入\"></a> Chapter-07-包和引入</h2>\n<p>包 引入 import package</p>\n<hr>\n<h3 id=\"包\"><a class=\"markdownIt-Anchor\" href=\"#包\"></a> 包</h3>\n<p>scala中的包和C++的命名空间和java中的包概念是相同的，只不过它和目录没有直接关系，是一个虚拟的关系，在代码中定义。</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com &#123;</span><br><span class=\"line\">  <span class=\"keyword\">package</span> horstmann &#123;</span><br><span class=\"line\">    <span class=\"keyword\">package</span>  impatient &#123;</span><br><span class=\"line\">      <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Employee</span></span></span><br><span class=\"line\"><span class=\"class\">    &#125;</span></span><br><span class=\"line\"><span class=\"class\">  &#125;</span></span><br><span class=\"line\"><span class=\"class\">&#125;</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>scala的包和目录不是强一致的，Employee完全可以不放在com/horstmann/impatient/这个目录下。</li>\n<li>包可以定义在任何源文件中。</li>\n<li>如果在相同或不同的源文件中定义了完全相同的冲突内容，会在编译时报“重复定义”的错误。</li>\n</ul>\n<h3 id=\"包的作用域\"><a class=\"markdownIt-Anchor\" href=\"#包的作用域\"></a> 包的作用域</h3>\n<p>与java不同的是，scala的子包在以下代码方式时，不用import就有使用父包作用域的权力。</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com &#123;</span><br><span class=\"line\">  <span class=\"keyword\">package</span> horstmann &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">object</span> <span class=\"title\">Util</span></span>&#123;</span><br><span class=\"line\">      <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">printObj</span></span>(obj:<span class=\"type\">Any</span>) = println(obj.toString)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">package</span>  impatient &#123;</span><br><span class=\"line\">      <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Employee</span>(<span class=\"params\">name:<span class=\"type\">String</span></span>)</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">toString</span> </span>= name</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"class\"><span class=\"keyword\">object</span> <span class=\"title\">Employee</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"type\">Util</span>.printObj(<span class=\"keyword\">new</span> <span class=\"type\">Employee</span>(<span class=\"string\">\"allon\"</span>)) <span class=\"comment\">// 注意Util是父包中的对象。不需要写成com.horstmann.Util。</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>scala中的包路径是相对的</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com &#123;</span><br><span class=\"line\">  <span class=\"keyword\">package</span> horstmann &#123;</span><br><span class=\"line\">    <span class=\"keyword\">package</span>  util&#123;</span><br><span class=\"line\">      <span class=\"class\"><span class=\"keyword\">object</span> <span class=\"title\">Properties</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">printObj</span></span>(obj:<span class=\"type\">Any</span>) = println(obj.toString)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">package</span>  impatient &#123;</span><br><span class=\"line\">      <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Employee</span>(<span class=\"params\">name:<span class=\"type\">String</span></span>)</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">toString</span> </span>= name</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"class\"><span class=\"keyword\">object</span> <span class=\"title\">Employee</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">apply</span></span>(): <span class=\"type\">Unit</span> =&#123;</span><br><span class=\"line\">          util.<span class=\"type\">Properties</span>.printObj(<span class=\"keyword\">new</span> <span class=\"type\">Employee</span>(<span class=\"string\">\"allon\"</span>)) <span class=\"comment\">//不能直接使用Properties而要使用util.Properties。</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>以上代码访问Properties可以使用</p>\n<ol>\n<li>util.Peroperties</li>\n<li>com.horstmann.util.Peroperties</li>\n<li>定义绝对路径_root_.com.horstmann.util.Peroperties</li>\n<li>如果想使用的是scala标准库中的util.Peroperties会出现冲突，最好写全路径scala.util.Peroperties</li>\n</ol>\n<h3 id=\"文件顶部定义包\"><a class=\"markdownIt-Anchor\" href=\"#文件顶部定义包\"></a> 文件顶部定义包</h3>\n<p>如果把包语句写成像java一样的串，作用域就会和java类似了。</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.horstmann &#123;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">object</span> <span class=\"title\">UtilA</span></span></span><br><span class=\"line\"><span class=\"class\">&#125;</span></span><br><span class=\"line\"><span class=\"class\"></span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">package</span> <span class=\"title\">com</span>.<span class=\"title\">horstmann</span>.<span class=\"title\">impatient</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">object</span> <span class=\"title\">UtilB</span></span></span><br><span class=\"line\"><span class=\"class\">    <span class=\"title\">class</span> <span class=\"title\">Employee</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//在这里com和com.horstmann作用域的成员是不可见的。</span></span><br><span class=\"line\">        <span class=\"type\">UtilA</span> <span class=\"comment\">//错误，不可见</span></span><br><span class=\"line\">        <span class=\"type\">UtilB</span> <span class=\"comment\">//可见</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>scala也可以在文件顶部定义包</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.horstmann.impatient</span><br><span class=\"line\"><span class=\"keyword\">package</span> people</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span></span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">//</span> <span class=\"title\">这等价于</span></span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">package</span> <span class=\"title\">com</span>.<span class=\"title\">horstmann</span>.<span class=\"title\">impatient</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">package</span> people &#123;</span><br><span class=\"line\">        <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span></span></span><br><span class=\"line\"><span class=\"class\">    &#125;</span></span><br><span class=\"line\"><span class=\"class\">&#125;</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"包对象\"><a class=\"markdownIt-Anchor\" href=\"#包对象\"></a> 包对象</h3>\n<p>包里可以定义类、对象和特质，但是因为jvm的局限不能定义函数。为了解决这个问题，引入了包对象的概念。</p>\n<p>每个包都可以定义一个和它同名的包对象。（有些像伴生对象）</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.horstmann.impatient</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">package</span> <span class=\"class\"><span class=\"keyword\">object</span> <span class=\"title\">people</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">val</span> defaultName = <span class=\"string\">\"allon\"</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">package</span> people &#123;</span><br><span class=\"line\">    <span class=\"keyword\">package</span> people &#123;</span><br><span class=\"line\">        <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span>(<span class=\"params\">val name:<span class=\"type\">String</span> = defaultName</span>) <span class=\"title\">//使用的是包对象中的默认值。这里的defaultName不用写全路径，因为它们在同一个包中，外部使用时可以com</span>.<span class=\"title\">horstmann</span>.<span class=\"title\">impatient</span>.<span class=\"title\">people</span>.<span class=\"title\">defaultName来使用。</span></span></span><br><span class=\"line\"><span class=\"class\">    &#125;</span></span><br><span class=\"line\"><span class=\"class\">&#125;</span></span><br></pre></td></tr></table></figure>\n<p>在jvm中，包对象被编译成package.class，并置于相应的包下。一般可以把包对象放到com/horstmann/impatient/people/package.scala。</p>\n<h3 id=\"包的可见性及import\"><a class=\"markdownIt-Anchor\" href=\"#包的可见性及import\"></a> 包的可见性及import</h3>\n<p>可以指定字段在哪些父包中可见</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span>(<span class=\"params\">private[horstmann] val name:<span class=\"type\">String</span> = defaultName</span>)</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"import\"><a class=\"markdownIt-Anchor\" href=\"#import\"></a> import</h4>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.awt._</span><br><span class=\"line\"><span class=\"comment\">//等价于java中的java.awt.*</span></span><br></pre></td></tr></table></figure>\n<p>在scala中完全可以定义com.horstmann.impatient.*.people，但是这么干等于在坑人。</p>\n<p>import的语句在scala中可以放在任何地方。并不一定要文件顶部。</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Manager</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">import</span> scala.collection.mutable._</span><br><span class=\"line\">    <span class=\"keyword\">val</span> subordinates = <span class=\"keyword\">new</span> <span class=\"type\">ArrayBuffer</span>[<span class=\"type\">Employee</span>]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"import时的重命名和部分引入\"><a class=\"markdownIt-Anchor\" href=\"#import时的重命名和部分引入\"></a> import时的重命名和部分引入</h4>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.util.&#123;<span class=\"type\">HashMap</span> =&gt; <span class=\"type\">JavaHashMap</span>&#125; <span class=\"comment\">//重命名为JavaHashMap，这样可以避免一些冲突。</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.awt.&#123;<span class=\"type\">Color</span>, <span class=\"type\">Font</span>&#125; </span><br><span class=\"line\"><span class=\"comment\">//只引入Color和Font</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.&#123;<span class=\"type\">HashMap</span> =&gt; _, _&#125; </span><br><span class=\"line\"><span class=\"comment\">//HashMap =&gt; _ 表示隐藏掉HashMap，第二个下划线表示通配符全部。这个import整个含义是：除了HashMap都引入。</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"隐式import\"><a class=\"markdownIt-Anchor\" href=\"#隐式import\"></a> 隐式import</h4>\n<p>就是scala“偷偷”的帮我们已经引入了scala开头的包。因而我们在使用scala开头的包时，我们才可以省略掉“scala”。</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> scala.collection.mutable._</span><br><span class=\"line\"><span class=\"comment\">//因为偷偷引入了scala包，所以也可以省略\"scala\"，从而和下面的import等价</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> collection.mutable._</span><br></pre></td></tr></table></figure>\n"},{"title":"Chapter-08-继承","catalog":true,"date":"2015-06-22T09:21:29.000Z","header-img":"/img/04.jpg","_content":"\n## Chapter-08-继承\n\nextends 继承\n\n---\n\n### 继承类\n\n```scala\nclass Employee extends Person {\n    var salary = 0.0\n}\n```\n和java不同的是，java中的final是不可变的。而scala中的final var是可以修改的，只是不能被继承。final val才相当于java的final。\n\n```scala\nclass Person {\n  val a = 1\n  final val b = 2\n}\n\nclass Employee extends Person{\n    override val a = 11 //可以继承，同时在子类中可以修改\n    override val b = 12 //错误，b是final不能继承\n}\n```\n\n### 重写方法\n在java中override注解的形式使用的，在scala中如果要复写，必须使用override修饰。\n\n    java中没有强制使用override的原因是，如果父类总修改就会出现问题。假如有Person父类，Student子类。Student类有个id属性，父类没有。这时不需要写override修饰。而后来父类突然加了一个也叫id的属性，这时子类属性上没有override。如果强制子类override修饰，子类就会报错。从而影响到别人。这也是为什么java采用注解的方式。\n    \n在scala中，调用父类方法和java相同，使用super关键字：\n\n```scala\nclass Employee extends Person {\n    override def toString = super.toString\n}\n```\n\n### 类型检查和转换\nisInstanceOf用来检查对象是否属于某个类或子类，如果返回true可以再使用asInstanceOf把这个对象转成对应的类对象。\n\n```scala\nobject Employee extends App{\n  val e = Employee()\n  val e2 = Employee\n\n  if(e.isInstanceOf[Employee]){\n    val s  = e.asInstanceOf[Employee]\n    println(s)\n  }\n\n  if(e2.isInstanceOf[Employee]) { // object对象不属于它的伴生类\n    println(\"e2\")\n  }else {\n    println(\"e2 is not Employee class object \")\n  }\n\n  def apply() = new Employee\n\n}\n\nclass Employee extends Person {\n  var salary = 0.0\n  var name  = \"allon\"\n  override def toString: String = name + \" \" + salary\n}\n\nclass Person\n\n//运行 Employee 输出：\n//allon 0.0\n//e2 is not Employee class object \n```\n由第二行输出也可以看出。单例对象不是用new关键字实例化的，所以没机会传递给它实例化参数。每个单例对象都被实现为虚拟类(synthetic class)的实例。\n\n如果想测试一个引用指向的是一个Employee而不是它的子类，\n\n```scala\nif (p.getClass  == classOf[Employee])\n```\n\n### 调用父类构造器\n在scala中不能用super的关键字来调用父类构造器\n\n```scala\nclass Employee(name:String,age:Int,val salary:Double) extends Person(name,age)\n```\n\n在java中，上述代码如下：\n\n```java\npublic class Employee extends Person { // Java\n    private double salary;\n    public Employee(String name, int age, double salary) {\n        super(name, age);\n        this.salary = salary;\n    }\n}\n```\n\n如果scala继承的是一个java类，它的主构造器必须调用java父类的一个构造方法。\n\n```scala\nclass Square(x: Int, y: Int, width: Int) extends java.awt.Rectangle(x, y, width, width)\n```\n\n### 重写字段\n\n>* def只能重写另一个def\n>* val只能重写另一个val或者不带参数的def\n>* var只能重写另一个抽象的var\n\n    由于var只能重写抽象的var，那么父类如果定义了一个非抽象的，子类就没办法重写了。\n    \n### 匿名类\n\n```scala \nval alien = new Person(\"Fred\"){\n    def greeting = \"Greetings, Earthling! My name is Fred.\"\n}\n// alien: Person{def greeting: String}\n```\n\n可以做为参数来定义：\n\n```scala\ndef meet(p: Person{def greeting: String}){\n    println(p.name + \"says: \" + p.greeting)\n}\n```\n\n### 抽象类和字段\n子类重写父类的抽象方法时，不强制使用override。\n\n```scala\nabstract class Person {\n    val id: Int\n    //没有初始化 一个抽象的有getter的字段\n    var name: String\n    //抽象的，getter\\setter俱全的字段\n}\n\nval fred = new Person {\n    val id = 1729\n    var name = \"Fred\"\n}\n```\n\n### 构造顺序和提前定义\n\n```scala \nclass Creature {\n  val range: Int = 10\n  val env: Array[Int] = new Array[Int](range)\n}\n\nclass Ant extends Creature {\n  override val range = 2\n}\n\nval ant = new Ant\nprintln(ant.env.length)\n//打印 0\n```\n以上代码打印0的原因是因为如下过程：\n1. 在new Ant的时候会先调父类构造方法，Creature的默认主构造器是Creature()。直接在默认的主构造方法中初始化range和env。\n2. 当env被初始化时，它的参数range实际上是在调用子类的range()，而这时子类还没有完成初始化，子类的range字段没值。子类的range()只能返回Int的默认值0。\n3. 等range有值了，一切都晚了，env已经初始化完成，长度为0。\n4. 简而言之，先调父类构造器，父类构造器内部又调的是子类方法，而子类还没来得及初始化。\n\n可以将子类的字段设为final或者将父类的字段设为lazy。可解决以上问题，或者将range字段设先于父类的初始化字段。\n\n```scala\nclass Ant extends { override val range = 2 } with Creature\n//这里要用with关键字\n```\n-Xcheckinit可以用来调试构造顺序问题，未初始化字段被访问的时候它会抛出异常。\n\n```bash\nscalac -Xcheckinit MyTest.scala\nscala MyTest\n#输出\nscala.UninitializedFieldError: Uninitialized field: MyTest8.scala: 15\n        at Ant.range(MyTest8.scala:15)\n        at Creature.<init>(MyTest8.scala:11)\n        at Ant.<init>(MyTest8.scala:14)\n        at MyTest9$.delayedEndpoint$MyTest9$1(MyTest8.scala:5)\n        ...  \n```\n\n### Scala继承层级\n\n* 和java中基本类型对应的类、Unit类型。都是继承自AnyVal。AnyVal是空的，只是一个继承体系的合龙标记。\n* 所有其他的类都是继承自AnyRef。相当于java中的Object类。有wait和notify/notifyAll等方法。同时还提供了一个synchronized方法，等同java中的synchronized代码块。\n\n```scala\naccount.synchronized { account.balance += amount }\n```\n\n![Scala类的继承关系][1]\n\n* 而AnyRef和AnyVal都是Any类的子类。isInstanceOf、asInstanceOf和一些判断相等和哈希的方法在Any类。\n* 如图，scala的类都是实现了ScalaObject这个空接口。\n* 同时，Null类型只有一个唯一的值null。根据图中关系，Null是不能赋值给一个AnyVal子类的变量的。比如val v:Int = null是不可以的。\n* Nothing是没有实例的，主要应用在泛型中做为一个标记，表示任何类型。如List[Nothing]表示list中可以放任何Nothing子类型。\n\n### 对象相等判断\nAnyRef有两个判等方法，eq和equals。eq判断两引用是否指向同一个对象。默认equals会直接调用eq.当想自定义比较时，要复写equals和hashCode。\n\n\n  [1]: http://7xop3k.com1.z0.glb.clouddn.com/20151127120544.jpg\n\n\n","source":"_posts/Chapter-08-继承.md","raw":"---\ntitle: 'Chapter-08-继承'\ncatalog: true\ndate: 2015-06-22 17:21:29\nheader-img: \"/img/04.jpg\"\ntags: \"scala\"\n---\n\n## Chapter-08-继承\n\nextends 继承\n\n---\n\n### 继承类\n\n```scala\nclass Employee extends Person {\n    var salary = 0.0\n}\n```\n和java不同的是，java中的final是不可变的。而scala中的final var是可以修改的，只是不能被继承。final val才相当于java的final。\n\n```scala\nclass Person {\n  val a = 1\n  final val b = 2\n}\n\nclass Employee extends Person{\n    override val a = 11 //可以继承，同时在子类中可以修改\n    override val b = 12 //错误，b是final不能继承\n}\n```\n\n### 重写方法\n在java中override注解的形式使用的，在scala中如果要复写，必须使用override修饰。\n\n    java中没有强制使用override的原因是，如果父类总修改就会出现问题。假如有Person父类，Student子类。Student类有个id属性，父类没有。这时不需要写override修饰。而后来父类突然加了一个也叫id的属性，这时子类属性上没有override。如果强制子类override修饰，子类就会报错。从而影响到别人。这也是为什么java采用注解的方式。\n    \n在scala中，调用父类方法和java相同，使用super关键字：\n\n```scala\nclass Employee extends Person {\n    override def toString = super.toString\n}\n```\n\n### 类型检查和转换\nisInstanceOf用来检查对象是否属于某个类或子类，如果返回true可以再使用asInstanceOf把这个对象转成对应的类对象。\n\n```scala\nobject Employee extends App{\n  val e = Employee()\n  val e2 = Employee\n\n  if(e.isInstanceOf[Employee]){\n    val s  = e.asInstanceOf[Employee]\n    println(s)\n  }\n\n  if(e2.isInstanceOf[Employee]) { // object对象不属于它的伴生类\n    println(\"e2\")\n  }else {\n    println(\"e2 is not Employee class object \")\n  }\n\n  def apply() = new Employee\n\n}\n\nclass Employee extends Person {\n  var salary = 0.0\n  var name  = \"allon\"\n  override def toString: String = name + \" \" + salary\n}\n\nclass Person\n\n//运行 Employee 输出：\n//allon 0.0\n//e2 is not Employee class object \n```\n由第二行输出也可以看出。单例对象不是用new关键字实例化的，所以没机会传递给它实例化参数。每个单例对象都被实现为虚拟类(synthetic class)的实例。\n\n如果想测试一个引用指向的是一个Employee而不是它的子类，\n\n```scala\nif (p.getClass  == classOf[Employee])\n```\n\n### 调用父类构造器\n在scala中不能用super的关键字来调用父类构造器\n\n```scala\nclass Employee(name:String,age:Int,val salary:Double) extends Person(name,age)\n```\n\n在java中，上述代码如下：\n\n```java\npublic class Employee extends Person { // Java\n    private double salary;\n    public Employee(String name, int age, double salary) {\n        super(name, age);\n        this.salary = salary;\n    }\n}\n```\n\n如果scala继承的是一个java类，它的主构造器必须调用java父类的一个构造方法。\n\n```scala\nclass Square(x: Int, y: Int, width: Int) extends java.awt.Rectangle(x, y, width, width)\n```\n\n### 重写字段\n\n>* def只能重写另一个def\n>* val只能重写另一个val或者不带参数的def\n>* var只能重写另一个抽象的var\n\n    由于var只能重写抽象的var，那么父类如果定义了一个非抽象的，子类就没办法重写了。\n    \n### 匿名类\n\n```scala \nval alien = new Person(\"Fred\"){\n    def greeting = \"Greetings, Earthling! My name is Fred.\"\n}\n// alien: Person{def greeting: String}\n```\n\n可以做为参数来定义：\n\n```scala\ndef meet(p: Person{def greeting: String}){\n    println(p.name + \"says: \" + p.greeting)\n}\n```\n\n### 抽象类和字段\n子类重写父类的抽象方法时，不强制使用override。\n\n```scala\nabstract class Person {\n    val id: Int\n    //没有初始化 一个抽象的有getter的字段\n    var name: String\n    //抽象的，getter\\setter俱全的字段\n}\n\nval fred = new Person {\n    val id = 1729\n    var name = \"Fred\"\n}\n```\n\n### 构造顺序和提前定义\n\n```scala \nclass Creature {\n  val range: Int = 10\n  val env: Array[Int] = new Array[Int](range)\n}\n\nclass Ant extends Creature {\n  override val range = 2\n}\n\nval ant = new Ant\nprintln(ant.env.length)\n//打印 0\n```\n以上代码打印0的原因是因为如下过程：\n1. 在new Ant的时候会先调父类构造方法，Creature的默认主构造器是Creature()。直接在默认的主构造方法中初始化range和env。\n2. 当env被初始化时，它的参数range实际上是在调用子类的range()，而这时子类还没有完成初始化，子类的range字段没值。子类的range()只能返回Int的默认值0。\n3. 等range有值了，一切都晚了，env已经初始化完成，长度为0。\n4. 简而言之，先调父类构造器，父类构造器内部又调的是子类方法，而子类还没来得及初始化。\n\n可以将子类的字段设为final或者将父类的字段设为lazy。可解决以上问题，或者将range字段设先于父类的初始化字段。\n\n```scala\nclass Ant extends { override val range = 2 } with Creature\n//这里要用with关键字\n```\n-Xcheckinit可以用来调试构造顺序问题，未初始化字段被访问的时候它会抛出异常。\n\n```bash\nscalac -Xcheckinit MyTest.scala\nscala MyTest\n#输出\nscala.UninitializedFieldError: Uninitialized field: MyTest8.scala: 15\n        at Ant.range(MyTest8.scala:15)\n        at Creature.<init>(MyTest8.scala:11)\n        at Ant.<init>(MyTest8.scala:14)\n        at MyTest9$.delayedEndpoint$MyTest9$1(MyTest8.scala:5)\n        ...  \n```\n\n### Scala继承层级\n\n* 和java中基本类型对应的类、Unit类型。都是继承自AnyVal。AnyVal是空的，只是一个继承体系的合龙标记。\n* 所有其他的类都是继承自AnyRef。相当于java中的Object类。有wait和notify/notifyAll等方法。同时还提供了一个synchronized方法，等同java中的synchronized代码块。\n\n```scala\naccount.synchronized { account.balance += amount }\n```\n\n![Scala类的继承关系][1]\n\n* 而AnyRef和AnyVal都是Any类的子类。isInstanceOf、asInstanceOf和一些判断相等和哈希的方法在Any类。\n* 如图，scala的类都是实现了ScalaObject这个空接口。\n* 同时，Null类型只有一个唯一的值null。根据图中关系，Null是不能赋值给一个AnyVal子类的变量的。比如val v:Int = null是不可以的。\n* Nothing是没有实例的，主要应用在泛型中做为一个标记，表示任何类型。如List[Nothing]表示list中可以放任何Nothing子类型。\n\n### 对象相等判断\nAnyRef有两个判等方法，eq和equals。eq判断两引用是否指向同一个对象。默认equals会直接调用eq.当想自定义比较时，要复写equals和hashCode。\n\n\n  [1]: http://7xop3k.com1.z0.glb.clouddn.com/20151127120544.jpg\n\n\n","slug":"Chapter-08-继承","published":1,"updated":"2017-11-25T06:28:50.496Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjahvvnxe000gpv4nlarlj7ed","content":"<h2><span id=\"chapter-08-继承\"> Chapter-08-继承</span></h2>\n<p>extends 继承</p>\n<hr>\n<h3><span id=\"继承类\"> 继承类</span></h3>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Employee</span> <span class=\"keyword\">extends</span> <span class=\"title\">Person</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> salary = <span class=\"number\">0.0</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>和java不同的是，java中的final是不可变的。而scala中的final var是可以修改的，只是不能被继承。final val才相当于java的final。</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">val</span> a = <span class=\"number\">1</span></span><br><span class=\"line\">  <span class=\"keyword\">final</span> <span class=\"keyword\">val</span> b = <span class=\"number\">2</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Employee</span> <span class=\"keyword\">extends</span> <span class=\"title\">Person</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"keyword\">val</span> a = <span class=\"number\">11</span> <span class=\"comment\">//可以继承，同时在子类中可以修改</span></span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"keyword\">val</span> b = <span class=\"number\">12</span> <span class=\"comment\">//错误，b是final不能继承</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3><span id=\"重写方法\"> 重写方法</span></h3>\n<p>在java中override注解的形式使用的，在scala中如果要复写，必须使用override修饰。</p>\n<pre><code>java中没有强制使用override的原因是，如果父类总修改就会出现问题。假如有Person父类，Student子类。Student类有个id属性，父类没有。这时不需要写override修饰。而后来父类突然加了一个也叫id的属性，这时子类属性上没有override。如果强制子类override修饰，子类就会报错。从而影响到别人。这也是为什么java采用注解的方式。\n</code></pre>\n<p>在scala中，调用父类方法和java相同，使用super关键字：</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Employee</span> <span class=\"keyword\">extends</span> <span class=\"title\">Person</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">toString</span> </span>= <span class=\"keyword\">super</span>.toString</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3><span id=\"类型检查和转换\"> 类型检查和转换</span></h3>\n<p>isInstanceOf用来检查对象是否属于某个类或子类，如果返回true可以再使用asInstanceOf把这个对象转成对应的类对象。</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">object</span> <span class=\"title\">Employee</span> <span class=\"keyword\">extends</span> <span class=\"title\">App</span></span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">val</span> e = <span class=\"type\">Employee</span>()</span><br><span class=\"line\">  <span class=\"keyword\">val</span> e2 = <span class=\"type\">Employee</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span>(e.isInstanceOf[<span class=\"type\">Employee</span>])&#123;</span><br><span class=\"line\">    <span class=\"keyword\">val</span> s  = e.asInstanceOf[<span class=\"type\">Employee</span>]</span><br><span class=\"line\">    println(s)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span>(e2.isInstanceOf[<span class=\"type\">Employee</span>]) &#123; <span class=\"comment\">// object对象不属于它的伴生类</span></span><br><span class=\"line\">    println(<span class=\"string\">\"e2\"</span>)</span><br><span class=\"line\">  &#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    println(<span class=\"string\">\"e2 is not Employee class object \"</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">apply</span></span>() = <span class=\"keyword\">new</span> <span class=\"type\">Employee</span></span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Employee</span> <span class=\"keyword\">extends</span> <span class=\"title\">Person</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> salary = <span class=\"number\">0.0</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> name  = <span class=\"string\">\"allon\"</span></span><br><span class=\"line\">  <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">toString</span></span>: <span class=\"type\">String</span> = name + <span class=\"string\">\" \"</span> + salary</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span></span></span><br><span class=\"line\"><span class=\"class\"></span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">//运行</span> <span class=\"title\">Employee</span> <span class=\"title\">输出：</span></span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">//allon</span> 0.0</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">//e2</span> <span class=\"title\">is</span> <span class=\"title\">not</span> <span class=\"title\">Employee</span> <span class=\"title\">class</span> <span class=\"title\">object</span></span></span><br></pre></td></tr></table></figure>\n<p>由第二行输出也可以看出。单例对象不是用new关键字实例化的，所以没机会传递给它实例化参数。每个单例对象都被实现为虚拟类(synthetic class)的实例。</p>\n<p>如果想测试一个引用指向的是一个Employee而不是它的子类，</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (p.getClass  == classOf[<span class=\"type\">Employee</span>])</span><br></pre></td></tr></table></figure>\n<h3><span id=\"调用父类构造器\"> 调用父类构造器</span></h3>\n<p>在scala中不能用super的关键字来调用父类构造器</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Employee</span>(<span class=\"params\">name:<span class=\"type\">String</span>,age:<span class=\"type\">Int</span>,val salary:<span class=\"type\">Double</span></span>) <span class=\"keyword\">extends</span> <span class=\"title\">Person</span>(<span class=\"params\">name,age</span>)</span></span><br></pre></td></tr></table></figure>\n<p>在java中，上述代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Employee</span> <span class=\"keyword\">extends</span> <span class=\"title\">Person</span> </span>&#123; <span class=\"comment\">// Java</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">double</span> salary;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Employee</span><span class=\"params\">(String name, <span class=\"keyword\">int</span> age, <span class=\"keyword\">double</span> salary)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>(name, age);</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.salary = salary;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如果scala继承的是一个java类，它的主构造器必须调用java父类的一个构造方法。</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Square</span>(<span class=\"params\">x: <span class=\"type\">Int</span>, y: <span class=\"type\">Int</span>, width: <span class=\"type\">Int</span></span>) <span class=\"keyword\">extends</span> <span class=\"title\">java</span>.<span class=\"title\">awt</span>.<span class=\"title\">Rectangle</span>(<span class=\"params\">x, y, width, width</span>)</span></span><br></pre></td></tr></table></figure>\n<h3><span id=\"重写字段\"> 重写字段</span></h3>\n<blockquote>\n<ul>\n<li>def只能重写另一个def</li>\n<li>val只能重写另一个val或者不带参数的def</li>\n<li>var只能重写另一个抽象的var</li>\n</ul>\n</blockquote>\n<pre><code>由于var只能重写抽象的var，那么父类如果定义了一个非抽象的，子类就没办法重写了。\n</code></pre>\n<h3><span id=\"匿名类\"> 匿名类</span></h3>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> alien = <span class=\"keyword\">new</span> <span class=\"type\">Person</span>(<span class=\"string\">\"Fred\"</span>)&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">greeting</span> </span>= <span class=\"string\">\"Greetings, Earthling! My name is Fred.\"</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// alien: Person&#123;def greeting: String&#125;</span></span><br></pre></td></tr></table></figure>\n<p>可以做为参数来定义：</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">meet</span></span>(p: <span class=\"type\">Person</span>&#123;<span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">greeting</span></span>: <span class=\"type\">String</span>&#125;)&#123;</span><br><span class=\"line\">    println(p.name + <span class=\"string\">\"says: \"</span> + p.greeting)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3><span id=\"抽象类和字段\"> 抽象类和字段</span></h3>\n<p>子类重写父类的抽象方法时，不强制使用override。</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">val</span> id: <span class=\"type\">Int</span></span><br><span class=\"line\">    <span class=\"comment\">//没有初始化 一个抽象的有getter的字段</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> name: <span class=\"type\">String</span></span><br><span class=\"line\">    <span class=\"comment\">//抽象的，getter\\setter俱全的字段</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">val</span> fred = <span class=\"keyword\">new</span> <span class=\"type\">Person</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">val</span> id = <span class=\"number\">1729</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> name = <span class=\"string\">\"Fred\"</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3><span id=\"构造顺序和提前定义\"> 构造顺序和提前定义</span></h3>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Creature</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">val</span> range: <span class=\"type\">Int</span> = <span class=\"number\">10</span></span><br><span class=\"line\">  <span class=\"keyword\">val</span> env: <span class=\"type\">Array</span>[<span class=\"type\">Int</span>] = <span class=\"keyword\">new</span> <span class=\"type\">Array</span>[<span class=\"type\">Int</span>](range)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Ant</span> <span class=\"keyword\">extends</span> <span class=\"title\">Creature</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">override</span> <span class=\"keyword\">val</span> range = <span class=\"number\">2</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">val</span> ant = <span class=\"keyword\">new</span> <span class=\"type\">Ant</span></span><br><span class=\"line\">println(ant.env.length)</span><br><span class=\"line\"><span class=\"comment\">//打印 0</span></span><br></pre></td></tr></table></figure>\n<p>以上代码打印0的原因是因为如下过程：</p>\n<ol>\n<li>在new Ant的时候会先调父类构造方法，Creature的默认主构造器是Creature()。直接在默认的主构造方法中初始化range和env。</li>\n<li>当env被初始化时，它的参数range实际上是在调用子类的range()，而这时子类还没有完成初始化，子类的range字段没值。子类的range()只能返回Int的默认值0。</li>\n<li>等range有值了，一切都晚了，env已经初始化完成，长度为0。</li>\n<li>简而言之，先调父类构造器，父类构造器内部又调的是子类方法，而子类还没来得及初始化。</li>\n</ol>\n<p>可以将子类的字段设为final或者将父类的字段设为lazy。可解决以上问题，或者将range字段设先于父类的初始化字段。</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Ant</span> <span class=\"keyword\">extends</span> </span>&#123; <span class=\"keyword\">override</span> <span class=\"keyword\">val</span> range = <span class=\"number\">2</span> &#125; <span class=\"keyword\">with</span> <span class=\"type\">Creature</span></span><br><span class=\"line\"><span class=\"comment\">//这里要用with关键字</span></span><br></pre></td></tr></table></figure>\n<p>-Xcheckinit可以用来调试构造顺序问题，未初始化字段被访问的时候它会抛出异常。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">scalac -Xcheckinit MyTest.scala</span><br><span class=\"line\">scala MyTest</span><br><span class=\"line\"><span class=\"comment\">#输出</span></span><br><span class=\"line\">scala.UninitializedFieldError: Uninitialized field: MyTest8.scala: 15</span><br><span class=\"line\">        at Ant.range(MyTest8.scala:15)</span><br><span class=\"line\">        at Creature.&lt;init&gt;(MyTest8.scala:11)</span><br><span class=\"line\">        at Ant.&lt;init&gt;(MyTest8.scala:14)</span><br><span class=\"line\">        at MyTest9$.delayedEndpoint<span class=\"variable\">$MyTest9</span><span class=\"variable\">$1</span>(MyTest8.scala:5)</span><br><span class=\"line\">        ...</span><br></pre></td></tr></table></figure>\n<h3><span id=\"scala继承层级\"> Scala继承层级</span></h3>\n<ul>\n<li>和java中基本类型对应的类、Unit类型。都是继承自AnyVal。AnyVal是空的，只是一个继承体系的合龙标记。</li>\n<li>所有其他的类都是继承自AnyRef。相当于java中的Object类。有wait和notify/notifyAll等方法。同时还提供了一个synchronized方法，等同java中的synchronized代码块。</li>\n</ul>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">account.synchronized &#123; account.balance += amount &#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"http://7xop3k.com1.z0.glb.clouddn.com/20151127120544.jpg\" alt=\"Scala类的继承关系\"></p>\n<ul>\n<li>而AnyRef和AnyVal都是Any类的子类。isInstanceOf、asInstanceOf和一些判断相等和哈希的方法在Any类。</li>\n<li>如图，scala的类都是实现了ScalaObject这个空接口。</li>\n<li>同时，Null类型只有一个唯一的值null。根据图中关系，Null是不能赋值给一个AnyVal子类的变量的。比如val v:Int = null是不可以的。</li>\n<li>Nothing是没有实例的，主要应用在泛型中做为一个标记，表示任何类型。如List[Nothing]表示list中可以放任何Nothing子类型。</li>\n</ul>\n<h3><span id=\"对象相等判断\"> 对象相等判断</span></h3>\n<p>AnyRef有两个判等方法，eq和equals。eq判断两引用是否指向同一个对象。默认equals会直接调用eq.当想自定义比较时，要复写equals和hashCode。</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"chapter-08-继承\"><a class=\"markdownIt-Anchor\" href=\"#chapter-08-继承\"></a> Chapter-08-继承</h2>\n<p>extends 继承</p>\n<hr>\n<h3 id=\"继承类\"><a class=\"markdownIt-Anchor\" href=\"#继承类\"></a> 继承类</h3>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Employee</span> <span class=\"keyword\">extends</span> <span class=\"title\">Person</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> salary = <span class=\"number\">0.0</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>和java不同的是，java中的final是不可变的。而scala中的final var是可以修改的，只是不能被继承。final val才相当于java的final。</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">val</span> a = <span class=\"number\">1</span></span><br><span class=\"line\">  <span class=\"keyword\">final</span> <span class=\"keyword\">val</span> b = <span class=\"number\">2</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Employee</span> <span class=\"keyword\">extends</span> <span class=\"title\">Person</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"keyword\">val</span> a = <span class=\"number\">11</span> <span class=\"comment\">//可以继承，同时在子类中可以修改</span></span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"keyword\">val</span> b = <span class=\"number\">12</span> <span class=\"comment\">//错误，b是final不能继承</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"重写方法\"><a class=\"markdownIt-Anchor\" href=\"#重写方法\"></a> 重写方法</h3>\n<p>在java中override注解的形式使用的，在scala中如果要复写，必须使用override修饰。</p>\n<pre><code>java中没有强制使用override的原因是，如果父类总修改就会出现问题。假如有Person父类，Student子类。Student类有个id属性，父类没有。这时不需要写override修饰。而后来父类突然加了一个也叫id的属性，这时子类属性上没有override。如果强制子类override修饰，子类就会报错。从而影响到别人。这也是为什么java采用注解的方式。\n</code></pre>\n<p>在scala中，调用父类方法和java相同，使用super关键字：</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Employee</span> <span class=\"keyword\">extends</span> <span class=\"title\">Person</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">toString</span> </span>= <span class=\"keyword\">super</span>.toString</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"类型检查和转换\"><a class=\"markdownIt-Anchor\" href=\"#类型检查和转换\"></a> 类型检查和转换</h3>\n<p>isInstanceOf用来检查对象是否属于某个类或子类，如果返回true可以再使用asInstanceOf把这个对象转成对应的类对象。</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">object</span> <span class=\"title\">Employee</span> <span class=\"keyword\">extends</span> <span class=\"title\">App</span></span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">val</span> e = <span class=\"type\">Employee</span>()</span><br><span class=\"line\">  <span class=\"keyword\">val</span> e2 = <span class=\"type\">Employee</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span>(e.isInstanceOf[<span class=\"type\">Employee</span>])&#123;</span><br><span class=\"line\">    <span class=\"keyword\">val</span> s  = e.asInstanceOf[<span class=\"type\">Employee</span>]</span><br><span class=\"line\">    println(s)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span>(e2.isInstanceOf[<span class=\"type\">Employee</span>]) &#123; <span class=\"comment\">// object对象不属于它的伴生类</span></span><br><span class=\"line\">    println(<span class=\"string\">\"e2\"</span>)</span><br><span class=\"line\">  &#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    println(<span class=\"string\">\"e2 is not Employee class object \"</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">apply</span></span>() = <span class=\"keyword\">new</span> <span class=\"type\">Employee</span></span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Employee</span> <span class=\"keyword\">extends</span> <span class=\"title\">Person</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> salary = <span class=\"number\">0.0</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> name  = <span class=\"string\">\"allon\"</span></span><br><span class=\"line\">  <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">toString</span></span>: <span class=\"type\">String</span> = name + <span class=\"string\">\" \"</span> + salary</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span></span></span><br><span class=\"line\"><span class=\"class\"></span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">//运行</span> <span class=\"title\">Employee</span> <span class=\"title\">输出：</span></span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">//allon</span> 0.0</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">//e2</span> <span class=\"title\">is</span> <span class=\"title\">not</span> <span class=\"title\">Employee</span> <span class=\"title\">class</span> <span class=\"title\">object</span></span></span><br></pre></td></tr></table></figure>\n<p>由第二行输出也可以看出。单例对象不是用new关键字实例化的，所以没机会传递给它实例化参数。每个单例对象都被实现为虚拟类(synthetic class)的实例。</p>\n<p>如果想测试一个引用指向的是一个Employee而不是它的子类，</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (p.getClass  == classOf[<span class=\"type\">Employee</span>])</span><br></pre></td></tr></table></figure>\n<h3 id=\"调用父类构造器\"><a class=\"markdownIt-Anchor\" href=\"#调用父类构造器\"></a> 调用父类构造器</h3>\n<p>在scala中不能用super的关键字来调用父类构造器</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Employee</span>(<span class=\"params\">name:<span class=\"type\">String</span>,age:<span class=\"type\">Int</span>,val salary:<span class=\"type\">Double</span></span>) <span class=\"keyword\">extends</span> <span class=\"title\">Person</span>(<span class=\"params\">name,age</span>)</span></span><br></pre></td></tr></table></figure>\n<p>在java中，上述代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Employee</span> <span class=\"keyword\">extends</span> <span class=\"title\">Person</span> </span>&#123; <span class=\"comment\">// Java</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">double</span> salary;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Employee</span><span class=\"params\">(String name, <span class=\"keyword\">int</span> age, <span class=\"keyword\">double</span> salary)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>(name, age);</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.salary = salary;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如果scala继承的是一个java类，它的主构造器必须调用java父类的一个构造方法。</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Square</span>(<span class=\"params\">x: <span class=\"type\">Int</span>, y: <span class=\"type\">Int</span>, width: <span class=\"type\">Int</span></span>) <span class=\"keyword\">extends</span> <span class=\"title\">java</span>.<span class=\"title\">awt</span>.<span class=\"title\">Rectangle</span>(<span class=\"params\">x, y, width, width</span>)</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"重写字段\"><a class=\"markdownIt-Anchor\" href=\"#重写字段\"></a> 重写字段</h3>\n<blockquote>\n<ul>\n<li>def只能重写另一个def</li>\n<li>val只能重写另一个val或者不带参数的def</li>\n<li>var只能重写另一个抽象的var</li>\n</ul>\n</blockquote>\n<pre><code>由于var只能重写抽象的var，那么父类如果定义了一个非抽象的，子类就没办法重写了。\n</code></pre>\n<h3 id=\"匿名类\"><a class=\"markdownIt-Anchor\" href=\"#匿名类\"></a> 匿名类</h3>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> alien = <span class=\"keyword\">new</span> <span class=\"type\">Person</span>(<span class=\"string\">\"Fred\"</span>)&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">greeting</span> </span>= <span class=\"string\">\"Greetings, Earthling! My name is Fred.\"</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// alien: Person&#123;def greeting: String&#125;</span></span><br></pre></td></tr></table></figure>\n<p>可以做为参数来定义：</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">meet</span></span>(p: <span class=\"type\">Person</span>&#123;<span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">greeting</span></span>: <span class=\"type\">String</span>&#125;)&#123;</span><br><span class=\"line\">    println(p.name + <span class=\"string\">\"says: \"</span> + p.greeting)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"抽象类和字段\"><a class=\"markdownIt-Anchor\" href=\"#抽象类和字段\"></a> 抽象类和字段</h3>\n<p>子类重写父类的抽象方法时，不强制使用override。</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">val</span> id: <span class=\"type\">Int</span></span><br><span class=\"line\">    <span class=\"comment\">//没有初始化 一个抽象的有getter的字段</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> name: <span class=\"type\">String</span></span><br><span class=\"line\">    <span class=\"comment\">//抽象的，getter\\setter俱全的字段</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">val</span> fred = <span class=\"keyword\">new</span> <span class=\"type\">Person</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">val</span> id = <span class=\"number\">1729</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> name = <span class=\"string\">\"Fred\"</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"构造顺序和提前定义\"><a class=\"markdownIt-Anchor\" href=\"#构造顺序和提前定义\"></a> 构造顺序和提前定义</h3>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Creature</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">val</span> range: <span class=\"type\">Int</span> = <span class=\"number\">10</span></span><br><span class=\"line\">  <span class=\"keyword\">val</span> env: <span class=\"type\">Array</span>[<span class=\"type\">Int</span>] = <span class=\"keyword\">new</span> <span class=\"type\">Array</span>[<span class=\"type\">Int</span>](range)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Ant</span> <span class=\"keyword\">extends</span> <span class=\"title\">Creature</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">override</span> <span class=\"keyword\">val</span> range = <span class=\"number\">2</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">val</span> ant = <span class=\"keyword\">new</span> <span class=\"type\">Ant</span></span><br><span class=\"line\">println(ant.env.length)</span><br><span class=\"line\"><span class=\"comment\">//打印 0</span></span><br></pre></td></tr></table></figure>\n<p>以上代码打印0的原因是因为如下过程：</p>\n<ol>\n<li>在new Ant的时候会先调父类构造方法，Creature的默认主构造器是Creature()。直接在默认的主构造方法中初始化range和env。</li>\n<li>当env被初始化时，它的参数range实际上是在调用子类的range()，而这时子类还没有完成初始化，子类的range字段没值。子类的range()只能返回Int的默认值0。</li>\n<li>等range有值了，一切都晚了，env已经初始化完成，长度为0。</li>\n<li>简而言之，先调父类构造器，父类构造器内部又调的是子类方法，而子类还没来得及初始化。</li>\n</ol>\n<p>可以将子类的字段设为final或者将父类的字段设为lazy。可解决以上问题，或者将range字段设先于父类的初始化字段。</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Ant</span> <span class=\"keyword\">extends</span> </span>&#123; <span class=\"keyword\">override</span> <span class=\"keyword\">val</span> range = <span class=\"number\">2</span> &#125; <span class=\"keyword\">with</span> <span class=\"type\">Creature</span></span><br><span class=\"line\"><span class=\"comment\">//这里要用with关键字</span></span><br></pre></td></tr></table></figure>\n<p>-Xcheckinit可以用来调试构造顺序问题，未初始化字段被访问的时候它会抛出异常。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">scalac -Xcheckinit MyTest.scala</span><br><span class=\"line\">scala MyTest</span><br><span class=\"line\"><span class=\"comment\">#输出</span></span><br><span class=\"line\">scala.UninitializedFieldError: Uninitialized field: MyTest8.scala: 15</span><br><span class=\"line\">        at Ant.range(MyTest8.scala:15)</span><br><span class=\"line\">        at Creature.&lt;init&gt;(MyTest8.scala:11)</span><br><span class=\"line\">        at Ant.&lt;init&gt;(MyTest8.scala:14)</span><br><span class=\"line\">        at MyTest9$.delayedEndpoint<span class=\"variable\">$MyTest9</span><span class=\"variable\">$1</span>(MyTest8.scala:5)</span><br><span class=\"line\">        ...</span><br></pre></td></tr></table></figure>\n<h3 id=\"scala继承层级\"><a class=\"markdownIt-Anchor\" href=\"#scala继承层级\"></a> Scala继承层级</h3>\n<ul>\n<li>和java中基本类型对应的类、Unit类型。都是继承自AnyVal。AnyVal是空的，只是一个继承体系的合龙标记。</li>\n<li>所有其他的类都是继承自AnyRef。相当于java中的Object类。有wait和notify/notifyAll等方法。同时还提供了一个synchronized方法，等同java中的synchronized代码块。</li>\n</ul>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">account.synchronized &#123; account.balance += amount &#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"http://7xop3k.com1.z0.glb.clouddn.com/20151127120544.jpg\" alt=\"Scala类的继承关系\"></p>\n<ul>\n<li>而AnyRef和AnyVal都是Any类的子类。isInstanceOf、asInstanceOf和一些判断相等和哈希的方法在Any类。</li>\n<li>如图，scala的类都是实现了ScalaObject这个空接口。</li>\n<li>同时，Null类型只有一个唯一的值null。根据图中关系，Null是不能赋值给一个AnyVal子类的变量的。比如val v:Int = null是不可以的。</li>\n<li>Nothing是没有实例的，主要应用在泛型中做为一个标记，表示任何类型。如List[Nothing]表示list中可以放任何Nothing子类型。</li>\n</ul>\n<h3 id=\"对象相等判断\"><a class=\"markdownIt-Anchor\" href=\"#对象相等判断\"></a> 对象相等判断</h3>\n<p>AnyRef有两个判等方法，eq和equals。eq判断两引用是否指向同一个对象。默认equals会直接调用eq.当想自定义比较时，要复写equals和hashCode。</p>\n"},{"title":"Chapter-09-文件和正则表达式","catalog":true,"date":"2015-06-22T09:21:29.000Z","header-img":"/img/04.jpg","_content":"\n## Chapter-09-文件和正则表达式\n\nfile 文件 正则表达式 Regular expression\n\n---\n\n### 读取行\n\n```scala\nimport scala.io.Source\nval source = Source.fromFile(\"myfile.txt\", \"UTF-8\")\nval iterator = source.getLines //获取Iterator[String]\nfor(l <- iterator) println(l) //直接打印\nval lines = iterator.toArray //通过Iterator获取数组\nval lines = iterator.toBuffer //通过Iterator获取数组\n```\n或者更简单粗暴的处理方式：把整个文件放到一个大字符串中\n\n```scala\nsource.mkString\nsource.close //用完要关掉\n```\n### 读取字符\n\n```scala\nfor(c <- source) println(c)\n```\n如果只是想查看下一个字符是什么，但是先不处理它。可以用source的buffered方法。然后再用head方法查看下一个字符。\n\n```scala\nval source = Source.fromFile(\"myfile.txt\", \"UTF-8\")\nval iterator = source.buffered\n\nwhile (iterator.hasNext) {\n    if (iterator.head 判断条件) \n        ...\n    else\n        ...\n}\n\nsource.close()\n```\n### 读取词和数字\n\n```scala\nval tokens = source.mkString.split(\"\\\\S+\")\nval numbers = for (w <- tokens) yield w.toDouble\n//或\nval numbers = tokens.map(_.toDouble)\n```\n从控制台读取\n\n```scala\nprint(\"How old are you? \")\nval age = readInt()\n```\n\n### 从URL或其他源读取\n\n```scala\nval source1 = Source.fromURL(\"http://www.baidu.com\", \"UTF-8\")\n//需要提前知道对方页面的字符集，可以从http头里拿到\nval source2 = Source.fromString(\"Hello, world!\")\n//这个东西有什么鸟用...\n```\n### 读取二进制文件\nscala里没有字节流读取文件的方法，要使用java类库。\n\n```scala\nval file = new File(filename)\nval in = new FileInputStream(file)\nval bytes = new Array[Byte](file.length.toInt)\nin.read(bytes)\nin.close()\n```\n### 写入文件和访问目录\nscala中没有写入和访问目录的api，需要借助java的写入文件api。\n\n### 序列化\n\n```scala\n@SerialVersionUID(42L) class Person extends Serializable\n//如果能接受默认UID，也可以省略掉@SerialVersionUID注解\nval fred = new Person\nimport java.io._\nval out = new ObjectOutputStream(new FileOutputStream(\"/tmp/test.obj\"))\nout.writeObject(fred)\nout.close()\n//序列化完成\nval in = new ObjectInputStream(new FileInputStream(\"/tmp/test.obj\"))\nval savedFred = in.readObject().asInstanceOf[Person]\n//反序列化\n```\n    scala的集合类默认都是可序列化的。可以放心使用它们做要序列化对象的成员变量。\n\n### 进程控制-执行shell\nscala中执行shell非常简单\n\n```scala\nimport sys.process._\n\"ls\" ! //执行ls命令，如果执行成功表达式的值为0，否则为非0。\n```\n如果使用!!而不是！的话，会以字符串的形式返回输\n出：\n\n```scala\nval result = \"ls\" !!\n```\n同时，还可以使用管道，用#|操作符实现：\n\n```scala\n\"ls\" #| \"grep scala\" ! \n```\n**在执行shell的过程中，实际上scala把叹号前面的字符串做了隐式转换，偷偷转换成了ProcessBuilder对象，叹号再执行ProcessBuilder对象。**\n\n#### 重定向\n\n```scala\nimport java.io.File\n\"ls\" #> new File(\"output.txt\") ! //输出到文件\n\"ls\" #>> new File(\"output.txt\") ! //追加输出到文件\n\"grep scala\" #< new File(\"output.txt\") ! //文件做为输入\nimport java.net.URL \n\"grep scala\" #< new URL(\"http://www.scala-lang.org/api/current/#package\") ! //url做为输入\n```\n进程控制支持很多熟悉的shell操作符，| > >> < && || ,使用时只要给它们的前面加个#即可。\n\n如果需要要不同的目录运行，或者使用不同的环境变量，可以用Process对象的apply方法来构造ProcessBuilder。三个参数分别为命令、执行目录、一些元组用来设置环境变量。\n\n```scala\nval p = Process(\"ls\" , new File(\"d:/\"), (\"LANG\", \"en_US\"))\np !\n```\n### 正则表达式\n从一个字符串到正则表达式对象，只需调用String类的r方法即可：\n\n```scala \nval numPattern = \"[0-9]+\".r\n```\n如果正则表达式中有反斜杠、引号的话，可以使用\"\"\"...\"\"\"\n\n```scala\nval wsnumwsPattern = \"\"\"\\s+[0-9]+\\s+\"\"\".r\n```\nfindAllIn返回所有匹配的迭代器。\n\n```scala\nfor (matchStr <- numPattern.findAllIn(\"99 bottles, 98 bottles\"))\n//或者转成数组再处理\nval matches = numPattern.findAllIn(\"99 bottles, 98 bottles\").toArray\n//Array(99, 98)\n```\n要找到首个匹配项，可使用findFirstIn,得到一个Option[String]的结果。\n\n也可以使用模式匹配：\n\n```scala\nval numitemPattern = \"([0-9]+) ([a-z]+)\".r\nval numitemPattern(num, item) = \"99 bottles\"\n//num: String = 99\n//item: String = bottles\n```\n如果想从多个匹配项中提取分组内容，可以使用for:\n\n```scala\nfor (numitemPattern(num, item) <- numitemPattern.findAllIn(\"99 bottles, 98 bottles\"))\nprintln(\"num:\" + num + \", item:\" + item)\n//num:99, item:bottles\n//num:98, item:bottles\n```\n\n\n","source":"_posts/Chapter-09-文件和正则表达式.md","raw":"---\ntitle: 'Chapter-09-文件和正则表达式'\ncatalog: true\ndate: 2015-06-22 17:21:29\nheader-img: \"/img/04.jpg\"\ntags: \"scala\"\n---\n\n## Chapter-09-文件和正则表达式\n\nfile 文件 正则表达式 Regular expression\n\n---\n\n### 读取行\n\n```scala\nimport scala.io.Source\nval source = Source.fromFile(\"myfile.txt\", \"UTF-8\")\nval iterator = source.getLines //获取Iterator[String]\nfor(l <- iterator) println(l) //直接打印\nval lines = iterator.toArray //通过Iterator获取数组\nval lines = iterator.toBuffer //通过Iterator获取数组\n```\n或者更简单粗暴的处理方式：把整个文件放到一个大字符串中\n\n```scala\nsource.mkString\nsource.close //用完要关掉\n```\n### 读取字符\n\n```scala\nfor(c <- source) println(c)\n```\n如果只是想查看下一个字符是什么，但是先不处理它。可以用source的buffered方法。然后再用head方法查看下一个字符。\n\n```scala\nval source = Source.fromFile(\"myfile.txt\", \"UTF-8\")\nval iterator = source.buffered\n\nwhile (iterator.hasNext) {\n    if (iterator.head 判断条件) \n        ...\n    else\n        ...\n}\n\nsource.close()\n```\n### 读取词和数字\n\n```scala\nval tokens = source.mkString.split(\"\\\\S+\")\nval numbers = for (w <- tokens) yield w.toDouble\n//或\nval numbers = tokens.map(_.toDouble)\n```\n从控制台读取\n\n```scala\nprint(\"How old are you? \")\nval age = readInt()\n```\n\n### 从URL或其他源读取\n\n```scala\nval source1 = Source.fromURL(\"http://www.baidu.com\", \"UTF-8\")\n//需要提前知道对方页面的字符集，可以从http头里拿到\nval source2 = Source.fromString(\"Hello, world!\")\n//这个东西有什么鸟用...\n```\n### 读取二进制文件\nscala里没有字节流读取文件的方法，要使用java类库。\n\n```scala\nval file = new File(filename)\nval in = new FileInputStream(file)\nval bytes = new Array[Byte](file.length.toInt)\nin.read(bytes)\nin.close()\n```\n### 写入文件和访问目录\nscala中没有写入和访问目录的api，需要借助java的写入文件api。\n\n### 序列化\n\n```scala\n@SerialVersionUID(42L) class Person extends Serializable\n//如果能接受默认UID，也可以省略掉@SerialVersionUID注解\nval fred = new Person\nimport java.io._\nval out = new ObjectOutputStream(new FileOutputStream(\"/tmp/test.obj\"))\nout.writeObject(fred)\nout.close()\n//序列化完成\nval in = new ObjectInputStream(new FileInputStream(\"/tmp/test.obj\"))\nval savedFred = in.readObject().asInstanceOf[Person]\n//反序列化\n```\n    scala的集合类默认都是可序列化的。可以放心使用它们做要序列化对象的成员变量。\n\n### 进程控制-执行shell\nscala中执行shell非常简单\n\n```scala\nimport sys.process._\n\"ls\" ! //执行ls命令，如果执行成功表达式的值为0，否则为非0。\n```\n如果使用!!而不是！的话，会以字符串的形式返回输\n出：\n\n```scala\nval result = \"ls\" !!\n```\n同时，还可以使用管道，用#|操作符实现：\n\n```scala\n\"ls\" #| \"grep scala\" ! \n```\n**在执行shell的过程中，实际上scala把叹号前面的字符串做了隐式转换，偷偷转换成了ProcessBuilder对象，叹号再执行ProcessBuilder对象。**\n\n#### 重定向\n\n```scala\nimport java.io.File\n\"ls\" #> new File(\"output.txt\") ! //输出到文件\n\"ls\" #>> new File(\"output.txt\") ! //追加输出到文件\n\"grep scala\" #< new File(\"output.txt\") ! //文件做为输入\nimport java.net.URL \n\"grep scala\" #< new URL(\"http://www.scala-lang.org/api/current/#package\") ! //url做为输入\n```\n进程控制支持很多熟悉的shell操作符，| > >> < && || ,使用时只要给它们的前面加个#即可。\n\n如果需要要不同的目录运行，或者使用不同的环境变量，可以用Process对象的apply方法来构造ProcessBuilder。三个参数分别为命令、执行目录、一些元组用来设置环境变量。\n\n```scala\nval p = Process(\"ls\" , new File(\"d:/\"), (\"LANG\", \"en_US\"))\np !\n```\n### 正则表达式\n从一个字符串到正则表达式对象，只需调用String类的r方法即可：\n\n```scala \nval numPattern = \"[0-9]+\".r\n```\n如果正则表达式中有反斜杠、引号的话，可以使用\"\"\"...\"\"\"\n\n```scala\nval wsnumwsPattern = \"\"\"\\s+[0-9]+\\s+\"\"\".r\n```\nfindAllIn返回所有匹配的迭代器。\n\n```scala\nfor (matchStr <- numPattern.findAllIn(\"99 bottles, 98 bottles\"))\n//或者转成数组再处理\nval matches = numPattern.findAllIn(\"99 bottles, 98 bottles\").toArray\n//Array(99, 98)\n```\n要找到首个匹配项，可使用findFirstIn,得到一个Option[String]的结果。\n\n也可以使用模式匹配：\n\n```scala\nval numitemPattern = \"([0-9]+) ([a-z]+)\".r\nval numitemPattern(num, item) = \"99 bottles\"\n//num: String = 99\n//item: String = bottles\n```\n如果想从多个匹配项中提取分组内容，可以使用for:\n\n```scala\nfor (numitemPattern(num, item) <- numitemPattern.findAllIn(\"99 bottles, 98 bottles\"))\nprintln(\"num:\" + num + \", item:\" + item)\n//num:99, item:bottles\n//num:98, item:bottles\n```\n\n\n","slug":"Chapter-09-文件和正则表达式","published":1,"updated":"2017-11-25T06:28:50.496Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjahvvnxi000ipv4necm1naqp","content":"<h2><span id=\"chapter-09-文件和正则表达式\"> Chapter-09-文件和正则表达式</span></h2>\n<p>file 文件 正则表达式 Regular expression</p>\n<hr>\n<h3><span id=\"读取行\"> 读取行</span></h3>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> scala.io.<span class=\"type\">Source</span></span><br><span class=\"line\"><span class=\"keyword\">val</span> source = <span class=\"type\">Source</span>.fromFile(<span class=\"string\">\"myfile.txt\"</span>, <span class=\"string\">\"UTF-8\"</span>)</span><br><span class=\"line\"><span class=\"keyword\">val</span> iterator = source.getLines <span class=\"comment\">//获取Iterator[String]</span></span><br><span class=\"line\"><span class=\"keyword\">for</span>(l &lt;- iterator) println(l) <span class=\"comment\">//直接打印</span></span><br><span class=\"line\"><span class=\"keyword\">val</span> lines = iterator.toArray <span class=\"comment\">//通过Iterator获取数组</span></span><br><span class=\"line\"><span class=\"keyword\">val</span> lines = iterator.toBuffer <span class=\"comment\">//通过Iterator获取数组</span></span><br></pre></td></tr></table></figure>\n<p>或者更简单粗暴的处理方式：把整个文件放到一个大字符串中</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">source.mkString</span><br><span class=\"line\">source.close <span class=\"comment\">//用完要关掉</span></span><br></pre></td></tr></table></figure>\n<h3><span id=\"读取字符\"> 读取字符</span></h3>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span>(c &lt;- source) println(c)</span><br></pre></td></tr></table></figure>\n<p>如果只是想查看下一个字符是什么，但是先不处理它。可以用source的buffered方法。然后再用head方法查看下一个字符。</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> source = <span class=\"type\">Source</span>.fromFile(<span class=\"string\">\"myfile.txt\"</span>, <span class=\"string\">\"UTF-8\"</span>)</span><br><span class=\"line\"><span class=\"keyword\">val</span> iterator = source.buffered</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">while</span> (iterator.hasNext) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (iterator.head 判断条件) </span><br><span class=\"line\">        ...</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">        ...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">source.close()</span><br></pre></td></tr></table></figure>\n<h3><span id=\"读取词和数字\"> 读取词和数字</span></h3>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> tokens = source.mkString.split(<span class=\"string\">\"\\\\S+\"</span>)</span><br><span class=\"line\"><span class=\"keyword\">val</span> numbers = <span class=\"keyword\">for</span> (w &lt;- tokens) <span class=\"keyword\">yield</span> w.toDouble</span><br><span class=\"line\"><span class=\"comment\">//或</span></span><br><span class=\"line\"><span class=\"keyword\">val</span> numbers = tokens.map(_.toDouble)</span><br></pre></td></tr></table></figure>\n<p>从控制台读取</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">print(<span class=\"string\">\"How old are you? \"</span>)</span><br><span class=\"line\"><span class=\"keyword\">val</span> age = readInt()</span><br></pre></td></tr></table></figure>\n<h3><span id=\"从url或其他源读取\"> 从URL或其他源读取</span></h3>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> source1 = <span class=\"type\">Source</span>.fromURL(<span class=\"string\">\"http://www.baidu.com\"</span>, <span class=\"string\">\"UTF-8\"</span>)</span><br><span class=\"line\"><span class=\"comment\">//需要提前知道对方页面的字符集，可以从http头里拿到</span></span><br><span class=\"line\"><span class=\"keyword\">val</span> source2 = <span class=\"type\">Source</span>.fromString(<span class=\"string\">\"Hello, world!\"</span>)</span><br><span class=\"line\"><span class=\"comment\">//这个东西有什么鸟用...</span></span><br></pre></td></tr></table></figure>\n<h3><span id=\"读取二进制文件\"> 读取二进制文件</span></h3>\n<p>scala里没有字节流读取文件的方法，要使用java类库。</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> file = <span class=\"keyword\">new</span> <span class=\"type\">File</span>(filename)</span><br><span class=\"line\"><span class=\"keyword\">val</span> in = <span class=\"keyword\">new</span> <span class=\"type\">FileInputStream</span>(file)</span><br><span class=\"line\"><span class=\"keyword\">val</span> bytes = <span class=\"keyword\">new</span> <span class=\"type\">Array</span>[<span class=\"type\">Byte</span>](file.length.toInt)</span><br><span class=\"line\">in.read(bytes)</span><br><span class=\"line\">in.close()</span><br></pre></td></tr></table></figure>\n<h3><span id=\"写入文件和访问目录\"> 写入文件和访问目录</span></h3>\n<p>scala中没有写入和访问目录的api，需要借助java的写入文件api。</p>\n<h3><span id=\"序列化\"> 序列化</span></h3>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@SerialVersionUID</span>(<span class=\"number\">42</span>L) <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span> <span class=\"keyword\">extends</span> <span class=\"title\">Serializable</span></span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">//如果能接受默认UID，也可以省略掉@SerialVersionUID注解</span></span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">val</span> <span class=\"title\">fred</span> </span>= <span class=\"keyword\">new</span> <span class=\"type\">Person</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.io._</span><br><span class=\"line\"><span class=\"keyword\">val</span> out = <span class=\"keyword\">new</span> <span class=\"type\">ObjectOutputStream</span>(<span class=\"keyword\">new</span> <span class=\"type\">FileOutputStream</span>(<span class=\"string\">\"/tmp/test.obj\"</span>))</span><br><span class=\"line\">out.writeObject(fred)</span><br><span class=\"line\">out.close()</span><br><span class=\"line\"><span class=\"comment\">//序列化完成</span></span><br><span class=\"line\"><span class=\"keyword\">val</span> in = <span class=\"keyword\">new</span> <span class=\"type\">ObjectInputStream</span>(<span class=\"keyword\">new</span> <span class=\"type\">FileInputStream</span>(<span class=\"string\">\"/tmp/test.obj\"</span>))</span><br><span class=\"line\"><span class=\"keyword\">val</span> savedFred = in.readObject().asInstanceOf[<span class=\"type\">Person</span>]</span><br><span class=\"line\"><span class=\"comment\">//反序列化</span></span><br></pre></td></tr></table></figure>\n<pre><code>scala的集合类默认都是可序列化的。可以放心使用它们做要序列化对象的成员变量。\n</code></pre>\n<h3><span id=\"进程控制-执行shell\"> 进程控制-执行shell</span></h3>\n<p>scala中执行shell非常简单</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> sys.process._</span><br><span class=\"line\"><span class=\"string\">\"ls\"</span> ! <span class=\"comment\">//执行ls命令，如果执行成功表达式的值为0，否则为非0。</span></span><br></pre></td></tr></table></figure>\n<p>如果使用!!而不是！的话，会以字符串的形式返回输<br>\n出：</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> result = <span class=\"string\">\"ls\"</span> !!</span><br></pre></td></tr></table></figure>\n<p>同时，还可以使用管道，用#|操作符实现：</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">\"ls\"</span> #| <span class=\"string\">\"grep scala\"</span> !</span><br></pre></td></tr></table></figure>\n<p><strong>在执行shell的过程中，实际上scala把叹号前面的字符串做了隐式转换，偷偷转换成了ProcessBuilder对象，叹号再执行ProcessBuilder对象。</strong></p>\n<h4><span id=\"重定向\"> 重定向</span></h4>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.io.<span class=\"type\">File</span></span><br><span class=\"line\"><span class=\"string\">\"ls\"</span> #&gt; <span class=\"keyword\">new</span> <span class=\"type\">File</span>(<span class=\"string\">\"output.txt\"</span>) ! <span class=\"comment\">//输出到文件</span></span><br><span class=\"line\"><span class=\"string\">\"ls\"</span> #&gt;&gt; <span class=\"keyword\">new</span> <span class=\"type\">File</span>(<span class=\"string\">\"output.txt\"</span>) ! <span class=\"comment\">//追加输出到文件</span></span><br><span class=\"line\"><span class=\"string\">\"grep scala\"</span> #&lt; <span class=\"keyword\">new</span> <span class=\"type\">File</span>(<span class=\"string\">\"output.txt\"</span>) ! <span class=\"comment\">//文件做为输入</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.net.<span class=\"type\">URL</span> </span><br><span class=\"line\"><span class=\"string\">\"grep scala\"</span> #&lt; <span class=\"keyword\">new</span> <span class=\"type\">URL</span>(<span class=\"string\">\"http://www.scala-lang.org/api/current/#package\"</span>) ! <span class=\"comment\">//url做为输入</span></span><br></pre></td></tr></table></figure>\n<p>进程控制支持很多熟悉的shell操作符，| &gt; &gt;&gt; &lt; &amp;&amp; || ,使用时只要给它们的前面加个#即可。</p>\n<p>如果需要要不同的目录运行，或者使用不同的环境变量，可以用Process对象的apply方法来构造ProcessBuilder。三个参数分别为命令、执行目录、一些元组用来设置环境变量。</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> p = <span class=\"type\">Process</span>(<span class=\"string\">\"ls\"</span> , <span class=\"keyword\">new</span> <span class=\"type\">File</span>(<span class=\"string\">\"d:/\"</span>), (<span class=\"string\">\"LANG\"</span>, <span class=\"string\">\"en_US\"</span>))</span><br><span class=\"line\">p !</span><br></pre></td></tr></table></figure>\n<h3><span id=\"正则表达式\"> 正则表达式</span></h3>\n<p>从一个字符串到正则表达式对象，只需调用String类的r方法即可：</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> numPattern = <span class=\"string\">\"[0-9]+\"</span>.r</span><br></pre></td></tr></table></figure>\n<p>如果正则表达式中有反斜杠、引号的话，可以使用&quot;&quot;&quot;…&quot;&quot;&quot;</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> wsnumwsPattern = <span class=\"string\">\"\"</span><span class=\"string\">\"\\s+[0-9]+\\s+\"</span><span class=\"string\">\"\"</span>.r</span><br></pre></td></tr></table></figure>\n<p>findAllIn返回所有匹配的迭代器。</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (matchStr &lt;- numPattern.findAllIn(<span class=\"string\">\"99 bottles, 98 bottles\"</span>))</span><br><span class=\"line\"><span class=\"comment\">//或者转成数组再处理</span></span><br><span class=\"line\"><span class=\"keyword\">val</span> matches = numPattern.findAllIn(<span class=\"string\">\"99 bottles, 98 bottles\"</span>).toArray</span><br><span class=\"line\"><span class=\"comment\">//Array(99, 98)</span></span><br></pre></td></tr></table></figure>\n<p>要找到首个匹配项，可使用findFirstIn,得到一个Option[String]的结果。</p>\n<p>也可以使用模式匹配：</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> numitemPattern = <span class=\"string\">\"([0-9]+) ([a-z]+)\"</span>.r</span><br><span class=\"line\"><span class=\"keyword\">val</span> numitemPattern(num, item) = <span class=\"string\">\"99 bottles\"</span></span><br><span class=\"line\"><span class=\"comment\">//num: String = 99</span></span><br><span class=\"line\"><span class=\"comment\">//item: String = bottles</span></span><br></pre></td></tr></table></figure>\n<p>如果想从多个匹配项中提取分组内容，可以使用for:</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (numitemPattern(num, item) &lt;- numitemPattern.findAllIn(<span class=\"string\">\"99 bottles, 98 bottles\"</span>))</span><br><span class=\"line\">println(<span class=\"string\">\"num:\"</span> + num + <span class=\"string\">\", item:\"</span> + item)</span><br><span class=\"line\"><span class=\"comment\">//num:99, item:bottles</span></span><br><span class=\"line\"><span class=\"comment\">//num:98, item:bottles</span></span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"chapter-09-文件和正则表达式\"><a class=\"markdownIt-Anchor\" href=\"#chapter-09-文件和正则表达式\"></a> Chapter-09-文件和正则表达式</h2>\n<p>file 文件 正则表达式 Regular expression</p>\n<hr>\n<h3 id=\"读取行\"><a class=\"markdownIt-Anchor\" href=\"#读取行\"></a> 读取行</h3>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> scala.io.<span class=\"type\">Source</span></span><br><span class=\"line\"><span class=\"keyword\">val</span> source = <span class=\"type\">Source</span>.fromFile(<span class=\"string\">\"myfile.txt\"</span>, <span class=\"string\">\"UTF-8\"</span>)</span><br><span class=\"line\"><span class=\"keyword\">val</span> iterator = source.getLines <span class=\"comment\">//获取Iterator[String]</span></span><br><span class=\"line\"><span class=\"keyword\">for</span>(l &lt;- iterator) println(l) <span class=\"comment\">//直接打印</span></span><br><span class=\"line\"><span class=\"keyword\">val</span> lines = iterator.toArray <span class=\"comment\">//通过Iterator获取数组</span></span><br><span class=\"line\"><span class=\"keyword\">val</span> lines = iterator.toBuffer <span class=\"comment\">//通过Iterator获取数组</span></span><br></pre></td></tr></table></figure>\n<p>或者更简单粗暴的处理方式：把整个文件放到一个大字符串中</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">source.mkString</span><br><span class=\"line\">source.close <span class=\"comment\">//用完要关掉</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"读取字符\"><a class=\"markdownIt-Anchor\" href=\"#读取字符\"></a> 读取字符</h3>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span>(c &lt;- source) println(c)</span><br></pre></td></tr></table></figure>\n<p>如果只是想查看下一个字符是什么，但是先不处理它。可以用source的buffered方法。然后再用head方法查看下一个字符。</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> source = <span class=\"type\">Source</span>.fromFile(<span class=\"string\">\"myfile.txt\"</span>, <span class=\"string\">\"UTF-8\"</span>)</span><br><span class=\"line\"><span class=\"keyword\">val</span> iterator = source.buffered</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">while</span> (iterator.hasNext) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (iterator.head 判断条件) </span><br><span class=\"line\">        ...</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">        ...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">source.close()</span><br></pre></td></tr></table></figure>\n<h3 id=\"读取词和数字\"><a class=\"markdownIt-Anchor\" href=\"#读取词和数字\"></a> 读取词和数字</h3>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> tokens = source.mkString.split(<span class=\"string\">\"\\\\S+\"</span>)</span><br><span class=\"line\"><span class=\"keyword\">val</span> numbers = <span class=\"keyword\">for</span> (w &lt;- tokens) <span class=\"keyword\">yield</span> w.toDouble</span><br><span class=\"line\"><span class=\"comment\">//或</span></span><br><span class=\"line\"><span class=\"keyword\">val</span> numbers = tokens.map(_.toDouble)</span><br></pre></td></tr></table></figure>\n<p>从控制台读取</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">print(<span class=\"string\">\"How old are you? \"</span>)</span><br><span class=\"line\"><span class=\"keyword\">val</span> age = readInt()</span><br></pre></td></tr></table></figure>\n<h3 id=\"从url或其他源读取\"><a class=\"markdownIt-Anchor\" href=\"#从url或其他源读取\"></a> 从URL或其他源读取</h3>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> source1 = <span class=\"type\">Source</span>.fromURL(<span class=\"string\">\"http://www.baidu.com\"</span>, <span class=\"string\">\"UTF-8\"</span>)</span><br><span class=\"line\"><span class=\"comment\">//需要提前知道对方页面的字符集，可以从http头里拿到</span></span><br><span class=\"line\"><span class=\"keyword\">val</span> source2 = <span class=\"type\">Source</span>.fromString(<span class=\"string\">\"Hello, world!\"</span>)</span><br><span class=\"line\"><span class=\"comment\">//这个东西有什么鸟用...</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"读取二进制文件\"><a class=\"markdownIt-Anchor\" href=\"#读取二进制文件\"></a> 读取二进制文件</h3>\n<p>scala里没有字节流读取文件的方法，要使用java类库。</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> file = <span class=\"keyword\">new</span> <span class=\"type\">File</span>(filename)</span><br><span class=\"line\"><span class=\"keyword\">val</span> in = <span class=\"keyword\">new</span> <span class=\"type\">FileInputStream</span>(file)</span><br><span class=\"line\"><span class=\"keyword\">val</span> bytes = <span class=\"keyword\">new</span> <span class=\"type\">Array</span>[<span class=\"type\">Byte</span>](file.length.toInt)</span><br><span class=\"line\">in.read(bytes)</span><br><span class=\"line\">in.close()</span><br></pre></td></tr></table></figure>\n<h3 id=\"写入文件和访问目录\"><a class=\"markdownIt-Anchor\" href=\"#写入文件和访问目录\"></a> 写入文件和访问目录</h3>\n<p>scala中没有写入和访问目录的api，需要借助java的写入文件api。</p>\n<h3 id=\"序列化\"><a class=\"markdownIt-Anchor\" href=\"#序列化\"></a> 序列化</h3>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@SerialVersionUID</span>(<span class=\"number\">42</span>L) <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span> <span class=\"keyword\">extends</span> <span class=\"title\">Serializable</span></span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">//如果能接受默认UID，也可以省略掉@SerialVersionUID注解</span></span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">val</span> <span class=\"title\">fred</span> </span>= <span class=\"keyword\">new</span> <span class=\"type\">Person</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.io._</span><br><span class=\"line\"><span class=\"keyword\">val</span> out = <span class=\"keyword\">new</span> <span class=\"type\">ObjectOutputStream</span>(<span class=\"keyword\">new</span> <span class=\"type\">FileOutputStream</span>(<span class=\"string\">\"/tmp/test.obj\"</span>))</span><br><span class=\"line\">out.writeObject(fred)</span><br><span class=\"line\">out.close()</span><br><span class=\"line\"><span class=\"comment\">//序列化完成</span></span><br><span class=\"line\"><span class=\"keyword\">val</span> in = <span class=\"keyword\">new</span> <span class=\"type\">ObjectInputStream</span>(<span class=\"keyword\">new</span> <span class=\"type\">FileInputStream</span>(<span class=\"string\">\"/tmp/test.obj\"</span>))</span><br><span class=\"line\"><span class=\"keyword\">val</span> savedFred = in.readObject().asInstanceOf[<span class=\"type\">Person</span>]</span><br><span class=\"line\"><span class=\"comment\">//反序列化</span></span><br></pre></td></tr></table></figure>\n<pre><code>scala的集合类默认都是可序列化的。可以放心使用它们做要序列化对象的成员变量。\n</code></pre>\n<h3 id=\"进程控制-执行shell\"><a class=\"markdownIt-Anchor\" href=\"#进程控制-执行shell\"></a> 进程控制-执行shell</h3>\n<p>scala中执行shell非常简单</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> sys.process._</span><br><span class=\"line\"><span class=\"string\">\"ls\"</span> ! <span class=\"comment\">//执行ls命令，如果执行成功表达式的值为0，否则为非0。</span></span><br></pre></td></tr></table></figure>\n<p>如果使用!!而不是！的话，会以字符串的形式返回输<br>\n出：</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> result = <span class=\"string\">\"ls\"</span> !!</span><br></pre></td></tr></table></figure>\n<p>同时，还可以使用管道，用#|操作符实现：</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">\"ls\"</span> #| <span class=\"string\">\"grep scala\"</span> !</span><br></pre></td></tr></table></figure>\n<p><strong>在执行shell的过程中，实际上scala把叹号前面的字符串做了隐式转换，偷偷转换成了ProcessBuilder对象，叹号再执行ProcessBuilder对象。</strong></p>\n<h4 id=\"重定向\"><a class=\"markdownIt-Anchor\" href=\"#重定向\"></a> 重定向</h4>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.io.<span class=\"type\">File</span></span><br><span class=\"line\"><span class=\"string\">\"ls\"</span> #&gt; <span class=\"keyword\">new</span> <span class=\"type\">File</span>(<span class=\"string\">\"output.txt\"</span>) ! <span class=\"comment\">//输出到文件</span></span><br><span class=\"line\"><span class=\"string\">\"ls\"</span> #&gt;&gt; <span class=\"keyword\">new</span> <span class=\"type\">File</span>(<span class=\"string\">\"output.txt\"</span>) ! <span class=\"comment\">//追加输出到文件</span></span><br><span class=\"line\"><span class=\"string\">\"grep scala\"</span> #&lt; <span class=\"keyword\">new</span> <span class=\"type\">File</span>(<span class=\"string\">\"output.txt\"</span>) ! <span class=\"comment\">//文件做为输入</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.net.<span class=\"type\">URL</span> </span><br><span class=\"line\"><span class=\"string\">\"grep scala\"</span> #&lt; <span class=\"keyword\">new</span> <span class=\"type\">URL</span>(<span class=\"string\">\"http://www.scala-lang.org/api/current/#package\"</span>) ! <span class=\"comment\">//url做为输入</span></span><br></pre></td></tr></table></figure>\n<p>进程控制支持很多熟悉的shell操作符，| &gt; &gt;&gt; &lt; &amp;&amp; || ,使用时只要给它们的前面加个#即可。</p>\n<p>如果需要要不同的目录运行，或者使用不同的环境变量，可以用Process对象的apply方法来构造ProcessBuilder。三个参数分别为命令、执行目录、一些元组用来设置环境变量。</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> p = <span class=\"type\">Process</span>(<span class=\"string\">\"ls\"</span> , <span class=\"keyword\">new</span> <span class=\"type\">File</span>(<span class=\"string\">\"d:/\"</span>), (<span class=\"string\">\"LANG\"</span>, <span class=\"string\">\"en_US\"</span>))</span><br><span class=\"line\">p !</span><br></pre></td></tr></table></figure>\n<h3 id=\"正则表达式\"><a class=\"markdownIt-Anchor\" href=\"#正则表达式\"></a> 正则表达式</h3>\n<p>从一个字符串到正则表达式对象，只需调用String类的r方法即可：</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> numPattern = <span class=\"string\">\"[0-9]+\"</span>.r</span><br></pre></td></tr></table></figure>\n<p>如果正则表达式中有反斜杠、引号的话，可以使用&quot;&quot;&quot;…&quot;&quot;&quot;</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> wsnumwsPattern = <span class=\"string\">\"\"</span><span class=\"string\">\"\\s+[0-9]+\\s+\"</span><span class=\"string\">\"\"</span>.r</span><br></pre></td></tr></table></figure>\n<p>findAllIn返回所有匹配的迭代器。</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (matchStr &lt;- numPattern.findAllIn(<span class=\"string\">\"99 bottles, 98 bottles\"</span>))</span><br><span class=\"line\"><span class=\"comment\">//或者转成数组再处理</span></span><br><span class=\"line\"><span class=\"keyword\">val</span> matches = numPattern.findAllIn(<span class=\"string\">\"99 bottles, 98 bottles\"</span>).toArray</span><br><span class=\"line\"><span class=\"comment\">//Array(99, 98)</span></span><br></pre></td></tr></table></figure>\n<p>要找到首个匹配项，可使用findFirstIn,得到一个Option[String]的结果。</p>\n<p>也可以使用模式匹配：</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> numitemPattern = <span class=\"string\">\"([0-9]+) ([a-z]+)\"</span>.r</span><br><span class=\"line\"><span class=\"keyword\">val</span> numitemPattern(num, item) = <span class=\"string\">\"99 bottles\"</span></span><br><span class=\"line\"><span class=\"comment\">//num: String = 99</span></span><br><span class=\"line\"><span class=\"comment\">//item: String = bottles</span></span><br></pre></td></tr></table></figure>\n<p>如果想从多个匹配项中提取分组内容，可以使用for:</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (numitemPattern(num, item) &lt;- numitemPattern.findAllIn(<span class=\"string\">\"99 bottles, 98 bottles\"</span>))</span><br><span class=\"line\">println(<span class=\"string\">\"num:\"</span> + num + <span class=\"string\">\", item:\"</span> + item)</span><br><span class=\"line\"><span class=\"comment\">//num:99, item:bottles</span></span><br><span class=\"line\"><span class=\"comment\">//num:98, item:bottles</span></span><br></pre></td></tr></table></figure>\n"},{"title":"Chapter-10-特质","catalog":true,"date":"2015-06-22T09:21:29.000Z","header-img":"/img/04.jpg","_content":"\n## Chapter-10-特质\n\n特质 trait 接口 interface \n\n---\n\n### 当做接口使用的特质\n特质的部分功能和java中的接口十分类似。例如：\n\n```scala\ntrait Logger {\n    def log(msg: String) //这个是抽象方法，不要写abstract，特质中默认未实现的方法就是抽象的。\n}\n\nclass ConsoleLogger extends Logger { // 实现Logger。用extends，不是implements\n    def log(msg: String) { println(msg) } // 不需要写override \n}\n```\n如果要实现多个特质，可以用with关键字来串联：\n\n```scala\nclass ConsoleLogger extends Logger with Cloneable with Serializable // 所有的java接口都可以做为scala的特质使用，scala中同样只能有一个父类，但是可以实现多个特质。\n```\n    上面这行代码要解读为Logger with Cloneable with Serializable是一个整体，然后再由ConsoleLogger类继承。\n\n---\n\n### 带有具体实现的特质\n在scala中，特质是可以有实现的。\n\n```scala\ntrait Logger {\n    def log(msg: String) { println(msg) }\n}\n\nclass SavingsAccount extends Logger {\n    def withdraw(amount: Double) {\n        log(\"Insufficeient funds\") // 使用特质中的方法\n    }\n}\n```\n让特质有具体实现有一个弊端，就是特质修改，子类要重新编译。\n\n---\n\n### 使用特质的对象\n\n```scala\nval acct = new SavingsAccount with Logger\nacct.withdraw(1.0)\n// Insufficeient funds\n```\n\n---\n\n### 特质继承顺序\n\n```scala\n//父特质\ntrait Logger {\n  def log(msg: String) {\n    println(\"Logger.log\")\n    println(msg)\n  }\n}\n\n//给日志加时间戳\ntrait TimestampLogger extends Logger {\n  override def log(msg: String) {\n    println(\"TimestampLogger.log\")\n    super.log(new java.util.Date() + \" \" + msg)\n  }\n}\n\n//截断日志\ntrait ShortLogger extends Logger {\n  val maxLength = 15\n\n  // 特质中的字段，下面会讲\n  override def log(msg: String) {\n    println(\"ShortLogger.log\")\n    super.log(if (msg.length <= maxLength) msg else msg.substring(0, maxLength - 3) + \"...\")\n  }\n}\n\nclass SavingsAccount\n\nobject MyTest10 extends App {\n  val acct = new SavingsAccount with TimestampLogger with ShortLogger\n  val acct2 = new SavingsAccount with ShortLogger with TimestampLogger\n  acct.log(\"1234567890123456\")\n  println()\n  acct2.log(\"1234567890123456\")\n}\n// 输出：\n// ShortLogger.log\n// TimestampLogger.log\n// Logger.log\n// Tue Dec 01 10:38:35 CST 2015 123456789012...\n//\n// TimestampLogger.log\n// ShortLogger.log\n// Logger.log\n// Tue Dec 01 1...\n```\n上面代码已经可以看出端倪，当对象使用一串特质时，调用顺序是从后到前（从右至左）的。逐层调用时，如果当前特质的左边没有特质了，那么它的super就会调用自己的父特质。\n\n* spuer的调用关系，取决于特质的顺序。\n* 如果要指定调用父类特质可以：super[TimestampLogger].log(...)。但是只能指定自己的直接父类特质。\n\n以下代码是等价的：\n```scala\nval acct = new SavingsAccount with Logger with TimestampLogger with ShortLogger\n//等价于\nval acct = new SavingsAccount with TimestampLogger with ShortLogger\n```\n\n---\n\n### 在特质中使用抽象方法\n如果在子特质中使用super，而父特质中的方法为抽象方法时，子特质对应的方法要加上override和abstract\n\n```scala\ntrait Logger {\n    def log(msg: String) // 这是个抽象方法\n}\nabstract override def log() {\n    super.log(...)\n}\n```\n\n---\n\n### 模板方法\n\n```scala\ntrait Logger {\n  def log(msg: String)\n  def info(msg: String) { log(\"INFO: \" + msg) }\n  def warn(msg: String) { log(\"WARN: \" + msg) }\n  def error(msg: String) { log(\"ERROR: \" + msg) }\n}\n\nclass SavingsAccount extends Logger {\n  override def log(msg: String) = { println(msg) }\n}\n\nval acct = new SavingsAccount\nacct.error(\"oh my god!\")\n```\n\n---\n\n### 特质中的具体字段\nscala中的特质，字段如果有初始化值就是具体的，反之则为抽象。\n特质中的具体字段不会被子类继承，而只是被简单的添加进去。\n\n```scala\ntrait ShortLogger extends Logger {\n    val maxLength = 15 //具体字段\n}\n\nclass Account {\n    var balance = 0.0\n}\n\nclass SavingsAccount extends Account with ShortLogger {\n    var interest = 0.0\n}\n```\n\n\n    | balance   |  -> 父类对象\n    -------------\n    | interest  |  -> 子类字段\n    | maxLength |  -> 子类字段\n\n具体的特质字段，可以视为是一个装配指令，表示任何混入该字段的子类，都自动拷贝该字段给自己。\n\n---\n\n### 特质中的抽象字段\n\n特质中的未初始化的字段都是抽象的，子类必须重写，但是不用加override关键字。\n\n---\n\n### 特质构造顺序\n特质也有构造器，由字段的初始化和其他语句组成。\n\n```scala\ntrait FileLogger extends Logger {\n    val out = new PrintWriter(\"app.log\") //构造器的一部分\n    out.println(\"# \" + new Date().toString) //同样是物质构造器的一部分\n    def log(msg: String) {...} //不属于构造器的一部分\n}\n```\n构造顺序如下：\n\n* 对象首先调用父类构造器。\n* 特质构造器在父类构造器之后、类构造器之前执行。\n* 特质构造顺序和调用顺序相反，由左至右。\n* 每个特质中，父特质先构造。\n* 如果多个特质共有一个父特质，那么这个父特质在已经构造的情况下，不会再次构造。\n* 所有特质构造器完成，子类再构造。\n\n```scala\nclass SavingsAccount extends Account with FileLogger with ShortLogger\n```\n构造顺序\n1. Account // 对象首先调用父类构造器。\n2. Logger // 每个特质中，父特质先构造。\n3. FileLogger // 对象首先调用父类构造器。\n4. ShortLogger // 特质构造顺序和调用顺序相反，由左至右。\n5. SavingsAccount // 所有特质构造器完成，子类再构造。\n\n同样是之前的例子，调用顺序和初始化顺序放到一起打印：\n\n```scala\n//父特质\ntrait Logger {\n  println(\"Logger init\")\n\n  def log(msg: String) {\n    println(\"Logger.log\")\n    println(msg)\n  }\n}\n\n//给日志加时间戳\ntrait TimestampLogger extends Logger {\n  println(\"TimestampLogger init\")\n\n  override def log(msg: String) {\n    println(\"TimestampLogger.log\")\n    super.log(new java.util.Date() + \" \" + msg)\n  }\n}\n\n//截断日志\ntrait ShortLogger extends Logger {\n  println(\"ShortLogger init\")\n\n  val maxLength = 15\n\n  // 特质中的字段，下面会讲\n  override def log(msg: String) {\n    println(\"ShortLogger.log\")\n    super.log(if (msg.length <= maxLength) msg else msg.substring(0, maxLength - 3) + \"...\")\n  }\n}\n\n\nclass Account {\n  println(\"Account init\")\n}\n\nclass SavingsAccount extends Account with TimestampLogger with ShortLogger\n\nobject MyTest10 extends App {\n  val acct = new SavingsAccount\n  println(\"初始化顺序打印完成！下面开始打印调用顺序：\")\n  acct.log(\"1234567890123456\")\n}\n\n// 输出\n// Account init\n// Logger init\n// TimestampLogger init\n// ShortLogger init\n// 初始化顺序打印完成！下面开始打印调用顺序：\n// ShortLogger.log\n// TimestampLogger.log\n// Logger.log\n```\n可见第一轮全部先初始化，第二轮开始调用。顺序正好相反。\n\n线性化是描述某个类型的所有父类型的规范，定义：\n如果C extends C1 with C2 with ... Cn，则 lin(C) = C >> lin(Cn) >> ... >> lin(C2) >> lin(C1)\n“>>”表示串联并去掉重复项，右侧胜出。\n线性化顺序就是之前所说的super调用顺序。\n\n---\n\n### 初始化特质中的字段\n特质不能有构造参数，每个特质都有一个无参的构造函数。\n    \n    缺少构造参数是特质和类的唯一差别\n\n由于特质是无参构造，而且先于子类构造，那么如果想在常规构造之前初始化一些字段时，可以：\n\n```scala\nval acct = new { val filename = \"myapp.log\" } with FileLogger with ShortLogger\n//如果在类中实现\nclass SavingsAccount extends { val filename = \"myapp.log\" } with FileLogger with ShortLogger\n```\n也可以使用lazy值，只是效率不是很高。\n\n---\n\n继承类的特质\n类也可以被特质继承（变态啊）。若如此，该类也将自动成为该特质子类的父类。\n\n```scala\ntrait LoggedException extends Exception with Logger {\n  def log() { log(getMessage()) }\n}\n\nclass UnhappyException extends LoggedException {\n  override def getMessage() = \"arggh\"\n}\n```\n\n\n    | Exception |   | LoggedException |\n            ↖           ↗ \n          | UnhappyException |\n\n如果子类已经有一个父类，那么该父类必须是那个特质父类的子类。\n\n---\n\n### 自身类型\n当特质继承类时，编译器会把所有该特质的子类都认这个类为父类。scala还有另一套机制可以保证这一点：自身类型（self type）。\n定义如下：\n\n```scala\nthis: 类型 =>\n```\n例：\n\n```scala\ntrait LoggedException extends Logger {\n  this: Exception => def log() { log(getMessage()) }\n}\n\nclass UnhappyException extends Exception with LoggedException{\n  override def getMessage() = \"arggh\"\n}\n```\nLoggedException类这样就只能被Exception的子类继承。\n后面会更详细介绍这里自身类型。\n\n* 自身类型就是强制要求一些类型必须是某些类的子类。\n* 还有一种结构类型是强制要求一些类具有种个方法，属于一种轻量的接口。\n\n### 特质的背后\n特质会被翻译成jvm的类和接口。\n\n* 没有具体实现的特质，会直接翻译成java中的接口。\n* 有具体实现的方法scala会帮我们创建一个伴生类，该类用静态方法来存方法。\n* 这些伴生类不会有任何字段，对应的字段用getter和setter方法来表示。\n* 如果特质继承了某个父类，则伴生类不会继承这个父类。这个父类会被所有实现该特质的子类继承。\n\n\n","source":"_posts/Chapter-10-特质.md","raw":"---\ntitle: 'Chapter-10-特质'\ncatalog: true\ndate: 2015-06-22 17:21:29\nheader-img: \"/img/04.jpg\"\ntags: \"scala\"\n---\n\n## Chapter-10-特质\n\n特质 trait 接口 interface \n\n---\n\n### 当做接口使用的特质\n特质的部分功能和java中的接口十分类似。例如：\n\n```scala\ntrait Logger {\n    def log(msg: String) //这个是抽象方法，不要写abstract，特质中默认未实现的方法就是抽象的。\n}\n\nclass ConsoleLogger extends Logger { // 实现Logger。用extends，不是implements\n    def log(msg: String) { println(msg) } // 不需要写override \n}\n```\n如果要实现多个特质，可以用with关键字来串联：\n\n```scala\nclass ConsoleLogger extends Logger with Cloneable with Serializable // 所有的java接口都可以做为scala的特质使用，scala中同样只能有一个父类，但是可以实现多个特质。\n```\n    上面这行代码要解读为Logger with Cloneable with Serializable是一个整体，然后再由ConsoleLogger类继承。\n\n---\n\n### 带有具体实现的特质\n在scala中，特质是可以有实现的。\n\n```scala\ntrait Logger {\n    def log(msg: String) { println(msg) }\n}\n\nclass SavingsAccount extends Logger {\n    def withdraw(amount: Double) {\n        log(\"Insufficeient funds\") // 使用特质中的方法\n    }\n}\n```\n让特质有具体实现有一个弊端，就是特质修改，子类要重新编译。\n\n---\n\n### 使用特质的对象\n\n```scala\nval acct = new SavingsAccount with Logger\nacct.withdraw(1.0)\n// Insufficeient funds\n```\n\n---\n\n### 特质继承顺序\n\n```scala\n//父特质\ntrait Logger {\n  def log(msg: String) {\n    println(\"Logger.log\")\n    println(msg)\n  }\n}\n\n//给日志加时间戳\ntrait TimestampLogger extends Logger {\n  override def log(msg: String) {\n    println(\"TimestampLogger.log\")\n    super.log(new java.util.Date() + \" \" + msg)\n  }\n}\n\n//截断日志\ntrait ShortLogger extends Logger {\n  val maxLength = 15\n\n  // 特质中的字段，下面会讲\n  override def log(msg: String) {\n    println(\"ShortLogger.log\")\n    super.log(if (msg.length <= maxLength) msg else msg.substring(0, maxLength - 3) + \"...\")\n  }\n}\n\nclass SavingsAccount\n\nobject MyTest10 extends App {\n  val acct = new SavingsAccount with TimestampLogger with ShortLogger\n  val acct2 = new SavingsAccount with ShortLogger with TimestampLogger\n  acct.log(\"1234567890123456\")\n  println()\n  acct2.log(\"1234567890123456\")\n}\n// 输出：\n// ShortLogger.log\n// TimestampLogger.log\n// Logger.log\n// Tue Dec 01 10:38:35 CST 2015 123456789012...\n//\n// TimestampLogger.log\n// ShortLogger.log\n// Logger.log\n// Tue Dec 01 1...\n```\n上面代码已经可以看出端倪，当对象使用一串特质时，调用顺序是从后到前（从右至左）的。逐层调用时，如果当前特质的左边没有特质了，那么它的super就会调用自己的父特质。\n\n* spuer的调用关系，取决于特质的顺序。\n* 如果要指定调用父类特质可以：super[TimestampLogger].log(...)。但是只能指定自己的直接父类特质。\n\n以下代码是等价的：\n```scala\nval acct = new SavingsAccount with Logger with TimestampLogger with ShortLogger\n//等价于\nval acct = new SavingsAccount with TimestampLogger with ShortLogger\n```\n\n---\n\n### 在特质中使用抽象方法\n如果在子特质中使用super，而父特质中的方法为抽象方法时，子特质对应的方法要加上override和abstract\n\n```scala\ntrait Logger {\n    def log(msg: String) // 这是个抽象方法\n}\nabstract override def log() {\n    super.log(...)\n}\n```\n\n---\n\n### 模板方法\n\n```scala\ntrait Logger {\n  def log(msg: String)\n  def info(msg: String) { log(\"INFO: \" + msg) }\n  def warn(msg: String) { log(\"WARN: \" + msg) }\n  def error(msg: String) { log(\"ERROR: \" + msg) }\n}\n\nclass SavingsAccount extends Logger {\n  override def log(msg: String) = { println(msg) }\n}\n\nval acct = new SavingsAccount\nacct.error(\"oh my god!\")\n```\n\n---\n\n### 特质中的具体字段\nscala中的特质，字段如果有初始化值就是具体的，反之则为抽象。\n特质中的具体字段不会被子类继承，而只是被简单的添加进去。\n\n```scala\ntrait ShortLogger extends Logger {\n    val maxLength = 15 //具体字段\n}\n\nclass Account {\n    var balance = 0.0\n}\n\nclass SavingsAccount extends Account with ShortLogger {\n    var interest = 0.0\n}\n```\n\n\n    | balance   |  -> 父类对象\n    -------------\n    | interest  |  -> 子类字段\n    | maxLength |  -> 子类字段\n\n具体的特质字段，可以视为是一个装配指令，表示任何混入该字段的子类，都自动拷贝该字段给自己。\n\n---\n\n### 特质中的抽象字段\n\n特质中的未初始化的字段都是抽象的，子类必须重写，但是不用加override关键字。\n\n---\n\n### 特质构造顺序\n特质也有构造器，由字段的初始化和其他语句组成。\n\n```scala\ntrait FileLogger extends Logger {\n    val out = new PrintWriter(\"app.log\") //构造器的一部分\n    out.println(\"# \" + new Date().toString) //同样是物质构造器的一部分\n    def log(msg: String) {...} //不属于构造器的一部分\n}\n```\n构造顺序如下：\n\n* 对象首先调用父类构造器。\n* 特质构造器在父类构造器之后、类构造器之前执行。\n* 特质构造顺序和调用顺序相反，由左至右。\n* 每个特质中，父特质先构造。\n* 如果多个特质共有一个父特质，那么这个父特质在已经构造的情况下，不会再次构造。\n* 所有特质构造器完成，子类再构造。\n\n```scala\nclass SavingsAccount extends Account with FileLogger with ShortLogger\n```\n构造顺序\n1. Account // 对象首先调用父类构造器。\n2. Logger // 每个特质中，父特质先构造。\n3. FileLogger // 对象首先调用父类构造器。\n4. ShortLogger // 特质构造顺序和调用顺序相反，由左至右。\n5. SavingsAccount // 所有特质构造器完成，子类再构造。\n\n同样是之前的例子，调用顺序和初始化顺序放到一起打印：\n\n```scala\n//父特质\ntrait Logger {\n  println(\"Logger init\")\n\n  def log(msg: String) {\n    println(\"Logger.log\")\n    println(msg)\n  }\n}\n\n//给日志加时间戳\ntrait TimestampLogger extends Logger {\n  println(\"TimestampLogger init\")\n\n  override def log(msg: String) {\n    println(\"TimestampLogger.log\")\n    super.log(new java.util.Date() + \" \" + msg)\n  }\n}\n\n//截断日志\ntrait ShortLogger extends Logger {\n  println(\"ShortLogger init\")\n\n  val maxLength = 15\n\n  // 特质中的字段，下面会讲\n  override def log(msg: String) {\n    println(\"ShortLogger.log\")\n    super.log(if (msg.length <= maxLength) msg else msg.substring(0, maxLength - 3) + \"...\")\n  }\n}\n\n\nclass Account {\n  println(\"Account init\")\n}\n\nclass SavingsAccount extends Account with TimestampLogger with ShortLogger\n\nobject MyTest10 extends App {\n  val acct = new SavingsAccount\n  println(\"初始化顺序打印完成！下面开始打印调用顺序：\")\n  acct.log(\"1234567890123456\")\n}\n\n// 输出\n// Account init\n// Logger init\n// TimestampLogger init\n// ShortLogger init\n// 初始化顺序打印完成！下面开始打印调用顺序：\n// ShortLogger.log\n// TimestampLogger.log\n// Logger.log\n```\n可见第一轮全部先初始化，第二轮开始调用。顺序正好相反。\n\n线性化是描述某个类型的所有父类型的规范，定义：\n如果C extends C1 with C2 with ... Cn，则 lin(C) = C >> lin(Cn) >> ... >> lin(C2) >> lin(C1)\n“>>”表示串联并去掉重复项，右侧胜出。\n线性化顺序就是之前所说的super调用顺序。\n\n---\n\n### 初始化特质中的字段\n特质不能有构造参数，每个特质都有一个无参的构造函数。\n    \n    缺少构造参数是特质和类的唯一差别\n\n由于特质是无参构造，而且先于子类构造，那么如果想在常规构造之前初始化一些字段时，可以：\n\n```scala\nval acct = new { val filename = \"myapp.log\" } with FileLogger with ShortLogger\n//如果在类中实现\nclass SavingsAccount extends { val filename = \"myapp.log\" } with FileLogger with ShortLogger\n```\n也可以使用lazy值，只是效率不是很高。\n\n---\n\n继承类的特质\n类也可以被特质继承（变态啊）。若如此，该类也将自动成为该特质子类的父类。\n\n```scala\ntrait LoggedException extends Exception with Logger {\n  def log() { log(getMessage()) }\n}\n\nclass UnhappyException extends LoggedException {\n  override def getMessage() = \"arggh\"\n}\n```\n\n\n    | Exception |   | LoggedException |\n            ↖           ↗ \n          | UnhappyException |\n\n如果子类已经有一个父类，那么该父类必须是那个特质父类的子类。\n\n---\n\n### 自身类型\n当特质继承类时，编译器会把所有该特质的子类都认这个类为父类。scala还有另一套机制可以保证这一点：自身类型（self type）。\n定义如下：\n\n```scala\nthis: 类型 =>\n```\n例：\n\n```scala\ntrait LoggedException extends Logger {\n  this: Exception => def log() { log(getMessage()) }\n}\n\nclass UnhappyException extends Exception with LoggedException{\n  override def getMessage() = \"arggh\"\n}\n```\nLoggedException类这样就只能被Exception的子类继承。\n后面会更详细介绍这里自身类型。\n\n* 自身类型就是强制要求一些类型必须是某些类的子类。\n* 还有一种结构类型是强制要求一些类具有种个方法，属于一种轻量的接口。\n\n### 特质的背后\n特质会被翻译成jvm的类和接口。\n\n* 没有具体实现的特质，会直接翻译成java中的接口。\n* 有具体实现的方法scala会帮我们创建一个伴生类，该类用静态方法来存方法。\n* 这些伴生类不会有任何字段，对应的字段用getter和setter方法来表示。\n* 如果特质继承了某个父类，则伴生类不会继承这个父类。这个父类会被所有实现该特质的子类继承。\n\n\n","slug":"Chapter-10-特质","published":1,"updated":"2017-11-25T06:28:50.497Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjahvvnxn000kpv4nhvii7feb","content":"<h2><span id=\"chapter-10-特质\"> Chapter-10-特质</span></h2>\n<p>特质 trait 接口 interface</p>\n<hr>\n<h3><span id=\"当做接口使用的特质\"> 当做接口使用的特质</span></h3>\n<p>特质的部分功能和java中的接口十分类似。例如：</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">trait</span> <span class=\"title\">Logger</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">log</span></span>(msg: <span class=\"type\">String</span>) <span class=\"comment\">//这个是抽象方法，不要写abstract，特质中默认未实现的方法就是抽象的。</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ConsoleLogger</span> <span class=\"keyword\">extends</span> <span class=\"title\">Logger</span> </span>&#123; <span class=\"comment\">// 实现Logger。用extends，不是implements</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">log</span></span>(msg: <span class=\"type\">String</span>) &#123; println(msg) &#125; <span class=\"comment\">// 不需要写override </span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如果要实现多个特质，可以用with关键字来串联：</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ConsoleLogger</span> <span class=\"keyword\">extends</span> <span class=\"title\">Logger</span> <span class=\"keyword\">with</span> <span class=\"title\">Cloneable</span> <span class=\"keyword\">with</span> <span class=\"title\">Serializable</span> <span class=\"title\">//</span> <span class=\"title\">所有的java接口都可以做为scala的特质使用，scala中同样只能有一个父类，但是可以实现多个特质。</span></span></span><br></pre></td></tr></table></figure>\n<pre><code>上面这行代码要解读为Logger with Cloneable with Serializable是一个整体，然后再由ConsoleLogger类继承。\n</code></pre>\n<hr>\n<h3><span id=\"带有具体实现的特质\"> 带有具体实现的特质</span></h3>\n<p>在scala中，特质是可以有实现的。</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">trait</span> <span class=\"title\">Logger</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">log</span></span>(msg: <span class=\"type\">String</span>) &#123; println(msg) &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SavingsAccount</span> <span class=\"keyword\">extends</span> <span class=\"title\">Logger</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">withdraw</span></span>(amount: <span class=\"type\">Double</span>) &#123;</span><br><span class=\"line\">        log(<span class=\"string\">\"Insufficeient funds\"</span>) <span class=\"comment\">// 使用特质中的方法</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>让特质有具体实现有一个弊端，就是特质修改，子类要重新编译。</p>\n<hr>\n<h3><span id=\"使用特质的对象\"> 使用特质的对象</span></h3>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> acct = <span class=\"keyword\">new</span> <span class=\"type\">SavingsAccount</span> <span class=\"keyword\">with</span> <span class=\"type\">Logger</span></span><br><span class=\"line\">acct.withdraw(<span class=\"number\">1.0</span>)</span><br><span class=\"line\"><span class=\"comment\">// Insufficeient funds</span></span><br></pre></td></tr></table></figure>\n<hr>\n<h3><span id=\"特质继承顺序\"> 特质继承顺序</span></h3>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//父特质</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">trait</span> <span class=\"title\">Logger</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">log</span></span>(msg: <span class=\"type\">String</span>) &#123;</span><br><span class=\"line\">    println(<span class=\"string\">\"Logger.log\"</span>)</span><br><span class=\"line\">    println(msg)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//给日志加时间戳</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">trait</span> <span class=\"title\">TimestampLogger</span> <span class=\"keyword\">extends</span> <span class=\"title\">Logger</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">log</span></span>(msg: <span class=\"type\">String</span>) &#123;</span><br><span class=\"line\">    println(<span class=\"string\">\"TimestampLogger.log\"</span>)</span><br><span class=\"line\">    <span class=\"keyword\">super</span>.log(<span class=\"keyword\">new</span> java.util.<span class=\"type\">Date</span>() + <span class=\"string\">\" \"</span> + msg)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//截断日志</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">trait</span> <span class=\"title\">ShortLogger</span> <span class=\"keyword\">extends</span> <span class=\"title\">Logger</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">val</span> maxLength = <span class=\"number\">15</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 特质中的字段，下面会讲</span></span><br><span class=\"line\">  <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">log</span></span>(msg: <span class=\"type\">String</span>) &#123;</span><br><span class=\"line\">    println(<span class=\"string\">\"ShortLogger.log\"</span>)</span><br><span class=\"line\">    <span class=\"keyword\">super</span>.log(<span class=\"keyword\">if</span> (msg.length &lt;= maxLength) msg <span class=\"keyword\">else</span> msg.substring(<span class=\"number\">0</span>, maxLength - <span class=\"number\">3</span>) + <span class=\"string\">\"...\"</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SavingsAccount</span></span></span><br><span class=\"line\"><span class=\"class\"></span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">object</span> <span class=\"title\">MyTest10</span> <span class=\"keyword\">extends</span> <span class=\"title\">App</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">val</span> acct = <span class=\"keyword\">new</span> <span class=\"type\">SavingsAccount</span> <span class=\"keyword\">with</span> <span class=\"type\">TimestampLogger</span> <span class=\"keyword\">with</span> <span class=\"type\">ShortLogger</span></span><br><span class=\"line\">  <span class=\"keyword\">val</span> acct2 = <span class=\"keyword\">new</span> <span class=\"type\">SavingsAccount</span> <span class=\"keyword\">with</span> <span class=\"type\">ShortLogger</span> <span class=\"keyword\">with</span> <span class=\"type\">TimestampLogger</span></span><br><span class=\"line\">  acct.log(<span class=\"string\">\"1234567890123456\"</span>)</span><br><span class=\"line\">  println()</span><br><span class=\"line\">  acct2.log(<span class=\"string\">\"1234567890123456\"</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 输出：</span></span><br><span class=\"line\"><span class=\"comment\">// ShortLogger.log</span></span><br><span class=\"line\"><span class=\"comment\">// TimestampLogger.log</span></span><br><span class=\"line\"><span class=\"comment\">// Logger.log</span></span><br><span class=\"line\"><span class=\"comment\">// Tue Dec 01 10:38:35 CST 2015 123456789012...</span></span><br><span class=\"line\"><span class=\"comment\">//</span></span><br><span class=\"line\"><span class=\"comment\">// TimestampLogger.log</span></span><br><span class=\"line\"><span class=\"comment\">// ShortLogger.log</span></span><br><span class=\"line\"><span class=\"comment\">// Logger.log</span></span><br><span class=\"line\"><span class=\"comment\">// Tue Dec 01 1...</span></span><br></pre></td></tr></table></figure>\n<p>上面代码已经可以看出端倪，当对象使用一串特质时，调用顺序是从后到前（从右至左）的。逐层调用时，如果当前特质的左边没有特质了，那么它的super就会调用自己的父特质。</p>\n<ul>\n<li>spuer的调用关系，取决于特质的顺序。</li>\n<li>如果要指定调用父类特质可以：super[TimestampLogger].log(…)。但是只能指定自己的直接父类特质。</li>\n</ul>\n<p>以下代码是等价的：</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> acct = <span class=\"keyword\">new</span> <span class=\"type\">SavingsAccount</span> <span class=\"keyword\">with</span> <span class=\"type\">Logger</span> <span class=\"keyword\">with</span> <span class=\"type\">TimestampLogger</span> <span class=\"keyword\">with</span> <span class=\"type\">ShortLogger</span></span><br><span class=\"line\"><span class=\"comment\">//等价于</span></span><br><span class=\"line\"><span class=\"keyword\">val</span> acct = <span class=\"keyword\">new</span> <span class=\"type\">SavingsAccount</span> <span class=\"keyword\">with</span> <span class=\"type\">TimestampLogger</span> <span class=\"keyword\">with</span> <span class=\"type\">ShortLogger</span></span><br></pre></td></tr></table></figure>\n<hr>\n<h3><span id=\"在特质中使用抽象方法\"> 在特质中使用抽象方法</span></h3>\n<p>如果在子特质中使用super，而父特质中的方法为抽象方法时，子特质对应的方法要加上override和abstract</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">trait</span> <span class=\"title\">Logger</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">log</span></span>(msg: <span class=\"type\">String</span>) <span class=\"comment\">// 这是个抽象方法</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">abstract</span> <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">log</span></span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>.log(...)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<hr>\n<h3><span id=\"模板方法\"> 模板方法</span></h3>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">trait</span> <span class=\"title\">Logger</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">log</span></span>(msg: <span class=\"type\">String</span>)</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">info</span></span>(msg: <span class=\"type\">String</span>) &#123; log(<span class=\"string\">\"INFO: \"</span> + msg) &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">warn</span></span>(msg: <span class=\"type\">String</span>) &#123; log(<span class=\"string\">\"WARN: \"</span> + msg) &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">error</span></span>(msg: <span class=\"type\">String</span>) &#123; log(<span class=\"string\">\"ERROR: \"</span> + msg) &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SavingsAccount</span> <span class=\"keyword\">extends</span> <span class=\"title\">Logger</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">log</span></span>(msg: <span class=\"type\">String</span>) = &#123; println(msg) &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">val</span> acct = <span class=\"keyword\">new</span> <span class=\"type\">SavingsAccount</span></span><br><span class=\"line\">acct.error(<span class=\"string\">\"oh my god!\"</span>)</span><br></pre></td></tr></table></figure>\n<hr>\n<h3><span id=\"特质中的具体字段\"> 特质中的具体字段</span></h3>\n<p>scala中的特质，字段如果有初始化值就是具体的，反之则为抽象。<br>\n特质中的具体字段不会被子类继承，而只是被简单的添加进去。</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">trait</span> <span class=\"title\">ShortLogger</span> <span class=\"keyword\">extends</span> <span class=\"title\">Logger</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">val</span> maxLength = <span class=\"number\">15</span> <span class=\"comment\">//具体字段</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Account</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> balance = <span class=\"number\">0.0</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SavingsAccount</span> <span class=\"keyword\">extends</span> <span class=\"title\">Account</span> <span class=\"keyword\">with</span> <span class=\"title\">ShortLogger</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> interest = <span class=\"number\">0.0</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<pre><code>| balance   |  -&gt; 父类对象\n-------------\n| interest  |  -&gt; 子类字段\n| maxLength |  -&gt; 子类字段\n</code></pre>\n<p>具体的特质字段，可以视为是一个装配指令，表示任何混入该字段的子类，都自动拷贝该字段给自己。</p>\n<hr>\n<h3><span id=\"特质中的抽象字段\"> 特质中的抽象字段</span></h3>\n<p>特质中的未初始化的字段都是抽象的，子类必须重写，但是不用加override关键字。</p>\n<hr>\n<h3><span id=\"特质构造顺序\"> 特质构造顺序</span></h3>\n<p>特质也有构造器，由字段的初始化和其他语句组成。</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">trait</span> <span class=\"title\">FileLogger</span> <span class=\"keyword\">extends</span> <span class=\"title\">Logger</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">val</span> out = <span class=\"keyword\">new</span> <span class=\"type\">PrintWriter</span>(<span class=\"string\">\"app.log\"</span>) <span class=\"comment\">//构造器的一部分</span></span><br><span class=\"line\">    out.println(<span class=\"string\">\"# \"</span> + <span class=\"keyword\">new</span> <span class=\"type\">Date</span>().toString) <span class=\"comment\">//同样是物质构造器的一部分</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">log</span></span>(msg: <span class=\"type\">String</span>) &#123;...&#125; <span class=\"comment\">//不属于构造器的一部分</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>构造顺序如下：</p>\n<ul>\n<li>对象首先调用父类构造器。</li>\n<li>特质构造器在父类构造器之后、类构造器之前执行。</li>\n<li>特质构造顺序和调用顺序相反，由左至右。</li>\n<li>每个特质中，父特质先构造。</li>\n<li>如果多个特质共有一个父特质，那么这个父特质在已经构造的情况下，不会再次构造。</li>\n<li>所有特质构造器完成，子类再构造。</li>\n</ul>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SavingsAccount</span> <span class=\"keyword\">extends</span> <span class=\"title\">Account</span> <span class=\"keyword\">with</span> <span class=\"title\">FileLogger</span> <span class=\"keyword\">with</span> <span class=\"title\">ShortLogger</span></span></span><br></pre></td></tr></table></figure>\n<p>构造顺序</p>\n<ol>\n<li>Account // 对象首先调用父类构造器。</li>\n<li>Logger // 每个特质中，父特质先构造。</li>\n<li>FileLogger // 对象首先调用父类构造器。</li>\n<li>ShortLogger // 特质构造顺序和调用顺序相反，由左至右。</li>\n<li>SavingsAccount // 所有特质构造器完成，子类再构造。</li>\n</ol>\n<p>同样是之前的例子，调用顺序和初始化顺序放到一起打印：</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//父特质</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">trait</span> <span class=\"title\">Logger</span> </span>&#123;</span><br><span class=\"line\">  println(<span class=\"string\">\"Logger init\"</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">log</span></span>(msg: <span class=\"type\">String</span>) &#123;</span><br><span class=\"line\">    println(<span class=\"string\">\"Logger.log\"</span>)</span><br><span class=\"line\">    println(msg)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//给日志加时间戳</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">trait</span> <span class=\"title\">TimestampLogger</span> <span class=\"keyword\">extends</span> <span class=\"title\">Logger</span> </span>&#123;</span><br><span class=\"line\">  println(<span class=\"string\">\"TimestampLogger init\"</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">log</span></span>(msg: <span class=\"type\">String</span>) &#123;</span><br><span class=\"line\">    println(<span class=\"string\">\"TimestampLogger.log\"</span>)</span><br><span class=\"line\">    <span class=\"keyword\">super</span>.log(<span class=\"keyword\">new</span> java.util.<span class=\"type\">Date</span>() + <span class=\"string\">\" \"</span> + msg)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//截断日志</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">trait</span> <span class=\"title\">ShortLogger</span> <span class=\"keyword\">extends</span> <span class=\"title\">Logger</span> </span>&#123;</span><br><span class=\"line\">  println(<span class=\"string\">\"ShortLogger init\"</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">val</span> maxLength = <span class=\"number\">15</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 特质中的字段，下面会讲</span></span><br><span class=\"line\">  <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">log</span></span>(msg: <span class=\"type\">String</span>) &#123;</span><br><span class=\"line\">    println(<span class=\"string\">\"ShortLogger.log\"</span>)</span><br><span class=\"line\">    <span class=\"keyword\">super</span>.log(<span class=\"keyword\">if</span> (msg.length &lt;= maxLength) msg <span class=\"keyword\">else</span> msg.substring(<span class=\"number\">0</span>, maxLength - <span class=\"number\">3</span>) + <span class=\"string\">\"...\"</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Account</span> </span>&#123;</span><br><span class=\"line\">  println(<span class=\"string\">\"Account init\"</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SavingsAccount</span> <span class=\"keyword\">extends</span> <span class=\"title\">Account</span> <span class=\"keyword\">with</span> <span class=\"title\">TimestampLogger</span> <span class=\"keyword\">with</span> <span class=\"title\">ShortLogger</span></span></span><br><span class=\"line\"><span class=\"class\"></span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">object</span> <span class=\"title\">MyTest10</span> <span class=\"keyword\">extends</span> <span class=\"title\">App</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">val</span> acct = <span class=\"keyword\">new</span> <span class=\"type\">SavingsAccount</span></span><br><span class=\"line\">  println(<span class=\"string\">\"初始化顺序打印完成！下面开始打印调用顺序：\"</span>)</span><br><span class=\"line\">  acct.log(<span class=\"string\">\"1234567890123456\"</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 输出</span></span><br><span class=\"line\"><span class=\"comment\">// Account init</span></span><br><span class=\"line\"><span class=\"comment\">// Logger init</span></span><br><span class=\"line\"><span class=\"comment\">// TimestampLogger init</span></span><br><span class=\"line\"><span class=\"comment\">// ShortLogger init</span></span><br><span class=\"line\"><span class=\"comment\">// 初始化顺序打印完成！下面开始打印调用顺序：</span></span><br><span class=\"line\"><span class=\"comment\">// ShortLogger.log</span></span><br><span class=\"line\"><span class=\"comment\">// TimestampLogger.log</span></span><br><span class=\"line\"><span class=\"comment\">// Logger.log</span></span><br></pre></td></tr></table></figure>\n<p>可见第一轮全部先初始化，第二轮开始调用。顺序正好相反。</p>\n<p>线性化是描述某个类型的所有父类型的规范，定义：<br>\n如果C extends C1 with C2 with … Cn，则 lin© = C &gt;&gt; lin(Cn) &gt;&gt; … &gt;&gt; lin(C2) &gt;&gt; lin(C1)<br>\n“&gt;&gt;”表示串联并去掉重复项，右侧胜出。<br>\n线性化顺序就是之前所说的super调用顺序。</p>\n<hr>\n<h3><span id=\"初始化特质中的字段\"> 初始化特质中的字段</span></h3>\n<p>特质不能有构造参数，每个特质都有一个无参的构造函数。</p>\n<pre><code>缺少构造参数是特质和类的唯一差别\n</code></pre>\n<p>由于特质是无参构造，而且先于子类构造，那么如果想在常规构造之前初始化一些字段时，可以：</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> acct = <span class=\"keyword\">new</span> &#123; <span class=\"keyword\">val</span> filename = <span class=\"string\">\"myapp.log\"</span> &#125; <span class=\"keyword\">with</span> <span class=\"type\">FileLogger</span> <span class=\"keyword\">with</span> <span class=\"type\">ShortLogger</span></span><br><span class=\"line\"><span class=\"comment\">//如果在类中实现</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SavingsAccount</span> <span class=\"keyword\">extends</span> </span>&#123; <span class=\"keyword\">val</span> filename = <span class=\"string\">\"myapp.log\"</span> &#125; <span class=\"keyword\">with</span> <span class=\"type\">FileLogger</span> <span class=\"keyword\">with</span> <span class=\"type\">ShortLogger</span></span><br></pre></td></tr></table></figure>\n<p>也可以使用lazy值，只是效率不是很高。</p>\n<hr>\n<p>继承类的特质<br>\n类也可以被特质继承（变态啊）。若如此，该类也将自动成为该特质子类的父类。</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">trait</span> <span class=\"title\">LoggedException</span> <span class=\"keyword\">extends</span> <span class=\"title\">Exception</span> <span class=\"keyword\">with</span> <span class=\"title\">Logger</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">log</span></span>() &#123; log(getMessage()) &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">UnhappyException</span> <span class=\"keyword\">extends</span> <span class=\"title\">LoggedException</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">getMessage</span></span>() = <span class=\"string\">\"arggh\"</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<pre><code>| Exception |   | LoggedException |\n        ↖           ↗ \n      | UnhappyException |\n</code></pre>\n<p>如果子类已经有一个父类，那么该父类必须是那个特质父类的子类。</p>\n<hr>\n<h3><span id=\"自身类型\"> 自身类型</span></h3>\n<p>当特质继承类时，编译器会把所有该特质的子类都认这个类为父类。scala还有另一套机制可以保证这一点：自身类型（self type）。<br>\n定义如下：</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">this</span>: 类型 =&gt;</span><br></pre></td></tr></table></figure>\n<p>例：</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">trait</span> <span class=\"title\">LoggedException</span> <span class=\"keyword\">extends</span> <span class=\"title\">Logger</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>: <span class=\"type\">Exception</span> =&gt; <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">log</span></span>() &#123; log(getMessage()) &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">UnhappyException</span> <span class=\"keyword\">extends</span> <span class=\"title\">Exception</span> <span class=\"keyword\">with</span> <span class=\"title\">LoggedException</span></span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">getMessage</span></span>() = <span class=\"string\">\"arggh\"</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>LoggedException类这样就只能被Exception的子类继承。<br>\n后面会更详细介绍这里自身类型。</p>\n<ul>\n<li>自身类型就是强制要求一些类型必须是某些类的子类。</li>\n<li>还有一种结构类型是强制要求一些类具有种个方法，属于一种轻量的接口。</li>\n</ul>\n<h3><span id=\"特质的背后\"> 特质的背后</span></h3>\n<p>特质会被翻译成jvm的类和接口。</p>\n<ul>\n<li>没有具体实现的特质，会直接翻译成java中的接口。</li>\n<li>有具体实现的方法scala会帮我们创建一个伴生类，该类用静态方法来存方法。</li>\n<li>这些伴生类不会有任何字段，对应的字段用getter和setter方法来表示。</li>\n<li>如果特质继承了某个父类，则伴生类不会继承这个父类。这个父类会被所有实现该特质的子类继承。</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"chapter-10-特质\"><a class=\"markdownIt-Anchor\" href=\"#chapter-10-特质\"></a> Chapter-10-特质</h2>\n<p>特质 trait 接口 interface</p>\n<hr>\n<h3 id=\"当做接口使用的特质\"><a class=\"markdownIt-Anchor\" href=\"#当做接口使用的特质\"></a> 当做接口使用的特质</h3>\n<p>特质的部分功能和java中的接口十分类似。例如：</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">trait</span> <span class=\"title\">Logger</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">log</span></span>(msg: <span class=\"type\">String</span>) <span class=\"comment\">//这个是抽象方法，不要写abstract，特质中默认未实现的方法就是抽象的。</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ConsoleLogger</span> <span class=\"keyword\">extends</span> <span class=\"title\">Logger</span> </span>&#123; <span class=\"comment\">// 实现Logger。用extends，不是implements</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">log</span></span>(msg: <span class=\"type\">String</span>) &#123; println(msg) &#125; <span class=\"comment\">// 不需要写override </span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如果要实现多个特质，可以用with关键字来串联：</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ConsoleLogger</span> <span class=\"keyword\">extends</span> <span class=\"title\">Logger</span> <span class=\"keyword\">with</span> <span class=\"title\">Cloneable</span> <span class=\"keyword\">with</span> <span class=\"title\">Serializable</span> <span class=\"title\">//</span> <span class=\"title\">所有的java接口都可以做为scala的特质使用，scala中同样只能有一个父类，但是可以实现多个特质。</span></span></span><br></pre></td></tr></table></figure>\n<pre><code>上面这行代码要解读为Logger with Cloneable with Serializable是一个整体，然后再由ConsoleLogger类继承。\n</code></pre>\n<hr>\n<h3 id=\"带有具体实现的特质\"><a class=\"markdownIt-Anchor\" href=\"#带有具体实现的特质\"></a> 带有具体实现的特质</h3>\n<p>在scala中，特质是可以有实现的。</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">trait</span> <span class=\"title\">Logger</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">log</span></span>(msg: <span class=\"type\">String</span>) &#123; println(msg) &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SavingsAccount</span> <span class=\"keyword\">extends</span> <span class=\"title\">Logger</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">withdraw</span></span>(amount: <span class=\"type\">Double</span>) &#123;</span><br><span class=\"line\">        log(<span class=\"string\">\"Insufficeient funds\"</span>) <span class=\"comment\">// 使用特质中的方法</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>让特质有具体实现有一个弊端，就是特质修改，子类要重新编译。</p>\n<hr>\n<h3 id=\"使用特质的对象\"><a class=\"markdownIt-Anchor\" href=\"#使用特质的对象\"></a> 使用特质的对象</h3>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> acct = <span class=\"keyword\">new</span> <span class=\"type\">SavingsAccount</span> <span class=\"keyword\">with</span> <span class=\"type\">Logger</span></span><br><span class=\"line\">acct.withdraw(<span class=\"number\">1.0</span>)</span><br><span class=\"line\"><span class=\"comment\">// Insufficeient funds</span></span><br></pre></td></tr></table></figure>\n<hr>\n<h3 id=\"特质继承顺序\"><a class=\"markdownIt-Anchor\" href=\"#特质继承顺序\"></a> 特质继承顺序</h3>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//父特质</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">trait</span> <span class=\"title\">Logger</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">log</span></span>(msg: <span class=\"type\">String</span>) &#123;</span><br><span class=\"line\">    println(<span class=\"string\">\"Logger.log\"</span>)</span><br><span class=\"line\">    println(msg)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//给日志加时间戳</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">trait</span> <span class=\"title\">TimestampLogger</span> <span class=\"keyword\">extends</span> <span class=\"title\">Logger</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">log</span></span>(msg: <span class=\"type\">String</span>) &#123;</span><br><span class=\"line\">    println(<span class=\"string\">\"TimestampLogger.log\"</span>)</span><br><span class=\"line\">    <span class=\"keyword\">super</span>.log(<span class=\"keyword\">new</span> java.util.<span class=\"type\">Date</span>() + <span class=\"string\">\" \"</span> + msg)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//截断日志</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">trait</span> <span class=\"title\">ShortLogger</span> <span class=\"keyword\">extends</span> <span class=\"title\">Logger</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">val</span> maxLength = <span class=\"number\">15</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 特质中的字段，下面会讲</span></span><br><span class=\"line\">  <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">log</span></span>(msg: <span class=\"type\">String</span>) &#123;</span><br><span class=\"line\">    println(<span class=\"string\">\"ShortLogger.log\"</span>)</span><br><span class=\"line\">    <span class=\"keyword\">super</span>.log(<span class=\"keyword\">if</span> (msg.length &lt;= maxLength) msg <span class=\"keyword\">else</span> msg.substring(<span class=\"number\">0</span>, maxLength - <span class=\"number\">3</span>) + <span class=\"string\">\"...\"</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SavingsAccount</span></span></span><br><span class=\"line\"><span class=\"class\"></span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">object</span> <span class=\"title\">MyTest10</span> <span class=\"keyword\">extends</span> <span class=\"title\">App</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">val</span> acct = <span class=\"keyword\">new</span> <span class=\"type\">SavingsAccount</span> <span class=\"keyword\">with</span> <span class=\"type\">TimestampLogger</span> <span class=\"keyword\">with</span> <span class=\"type\">ShortLogger</span></span><br><span class=\"line\">  <span class=\"keyword\">val</span> acct2 = <span class=\"keyword\">new</span> <span class=\"type\">SavingsAccount</span> <span class=\"keyword\">with</span> <span class=\"type\">ShortLogger</span> <span class=\"keyword\">with</span> <span class=\"type\">TimestampLogger</span></span><br><span class=\"line\">  acct.log(<span class=\"string\">\"1234567890123456\"</span>)</span><br><span class=\"line\">  println()</span><br><span class=\"line\">  acct2.log(<span class=\"string\">\"1234567890123456\"</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 输出：</span></span><br><span class=\"line\"><span class=\"comment\">// ShortLogger.log</span></span><br><span class=\"line\"><span class=\"comment\">// TimestampLogger.log</span></span><br><span class=\"line\"><span class=\"comment\">// Logger.log</span></span><br><span class=\"line\"><span class=\"comment\">// Tue Dec 01 10:38:35 CST 2015 123456789012...</span></span><br><span class=\"line\"><span class=\"comment\">//</span></span><br><span class=\"line\"><span class=\"comment\">// TimestampLogger.log</span></span><br><span class=\"line\"><span class=\"comment\">// ShortLogger.log</span></span><br><span class=\"line\"><span class=\"comment\">// Logger.log</span></span><br><span class=\"line\"><span class=\"comment\">// Tue Dec 01 1...</span></span><br></pre></td></tr></table></figure>\n<p>上面代码已经可以看出端倪，当对象使用一串特质时，调用顺序是从后到前（从右至左）的。逐层调用时，如果当前特质的左边没有特质了，那么它的super就会调用自己的父特质。</p>\n<ul>\n<li>spuer的调用关系，取决于特质的顺序。</li>\n<li>如果要指定调用父类特质可以：super[TimestampLogger].log(…)。但是只能指定自己的直接父类特质。</li>\n</ul>\n<p>以下代码是等价的：</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> acct = <span class=\"keyword\">new</span> <span class=\"type\">SavingsAccount</span> <span class=\"keyword\">with</span> <span class=\"type\">Logger</span> <span class=\"keyword\">with</span> <span class=\"type\">TimestampLogger</span> <span class=\"keyword\">with</span> <span class=\"type\">ShortLogger</span></span><br><span class=\"line\"><span class=\"comment\">//等价于</span></span><br><span class=\"line\"><span class=\"keyword\">val</span> acct = <span class=\"keyword\">new</span> <span class=\"type\">SavingsAccount</span> <span class=\"keyword\">with</span> <span class=\"type\">TimestampLogger</span> <span class=\"keyword\">with</span> <span class=\"type\">ShortLogger</span></span><br></pre></td></tr></table></figure>\n<hr>\n<h3 id=\"在特质中使用抽象方法\"><a class=\"markdownIt-Anchor\" href=\"#在特质中使用抽象方法\"></a> 在特质中使用抽象方法</h3>\n<p>如果在子特质中使用super，而父特质中的方法为抽象方法时，子特质对应的方法要加上override和abstract</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">trait</span> <span class=\"title\">Logger</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">log</span></span>(msg: <span class=\"type\">String</span>) <span class=\"comment\">// 这是个抽象方法</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">abstract</span> <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">log</span></span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>.log(...)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<hr>\n<h3 id=\"模板方法\"><a class=\"markdownIt-Anchor\" href=\"#模板方法\"></a> 模板方法</h3>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">trait</span> <span class=\"title\">Logger</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">log</span></span>(msg: <span class=\"type\">String</span>)</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">info</span></span>(msg: <span class=\"type\">String</span>) &#123; log(<span class=\"string\">\"INFO: \"</span> + msg) &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">warn</span></span>(msg: <span class=\"type\">String</span>) &#123; log(<span class=\"string\">\"WARN: \"</span> + msg) &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">error</span></span>(msg: <span class=\"type\">String</span>) &#123; log(<span class=\"string\">\"ERROR: \"</span> + msg) &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SavingsAccount</span> <span class=\"keyword\">extends</span> <span class=\"title\">Logger</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">log</span></span>(msg: <span class=\"type\">String</span>) = &#123; println(msg) &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">val</span> acct = <span class=\"keyword\">new</span> <span class=\"type\">SavingsAccount</span></span><br><span class=\"line\">acct.error(<span class=\"string\">\"oh my god!\"</span>)</span><br></pre></td></tr></table></figure>\n<hr>\n<h3 id=\"特质中的具体字段\"><a class=\"markdownIt-Anchor\" href=\"#特质中的具体字段\"></a> 特质中的具体字段</h3>\n<p>scala中的特质，字段如果有初始化值就是具体的，反之则为抽象。<br>\n特质中的具体字段不会被子类继承，而只是被简单的添加进去。</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">trait</span> <span class=\"title\">ShortLogger</span> <span class=\"keyword\">extends</span> <span class=\"title\">Logger</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">val</span> maxLength = <span class=\"number\">15</span> <span class=\"comment\">//具体字段</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Account</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> balance = <span class=\"number\">0.0</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SavingsAccount</span> <span class=\"keyword\">extends</span> <span class=\"title\">Account</span> <span class=\"keyword\">with</span> <span class=\"title\">ShortLogger</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> interest = <span class=\"number\">0.0</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<pre><code>| balance   |  -&gt; 父类对象\n-------------\n| interest  |  -&gt; 子类字段\n| maxLength |  -&gt; 子类字段\n</code></pre>\n<p>具体的特质字段，可以视为是一个装配指令，表示任何混入该字段的子类，都自动拷贝该字段给自己。</p>\n<hr>\n<h3 id=\"特质中的抽象字段\"><a class=\"markdownIt-Anchor\" href=\"#特质中的抽象字段\"></a> 特质中的抽象字段</h3>\n<p>特质中的未初始化的字段都是抽象的，子类必须重写，但是不用加override关键字。</p>\n<hr>\n<h3 id=\"特质构造顺序\"><a class=\"markdownIt-Anchor\" href=\"#特质构造顺序\"></a> 特质构造顺序</h3>\n<p>特质也有构造器，由字段的初始化和其他语句组成。</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">trait</span> <span class=\"title\">FileLogger</span> <span class=\"keyword\">extends</span> <span class=\"title\">Logger</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">val</span> out = <span class=\"keyword\">new</span> <span class=\"type\">PrintWriter</span>(<span class=\"string\">\"app.log\"</span>) <span class=\"comment\">//构造器的一部分</span></span><br><span class=\"line\">    out.println(<span class=\"string\">\"# \"</span> + <span class=\"keyword\">new</span> <span class=\"type\">Date</span>().toString) <span class=\"comment\">//同样是物质构造器的一部分</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">log</span></span>(msg: <span class=\"type\">String</span>) &#123;...&#125; <span class=\"comment\">//不属于构造器的一部分</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>构造顺序如下：</p>\n<ul>\n<li>对象首先调用父类构造器。</li>\n<li>特质构造器在父类构造器之后、类构造器之前执行。</li>\n<li>特质构造顺序和调用顺序相反，由左至右。</li>\n<li>每个特质中，父特质先构造。</li>\n<li>如果多个特质共有一个父特质，那么这个父特质在已经构造的情况下，不会再次构造。</li>\n<li>所有特质构造器完成，子类再构造。</li>\n</ul>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SavingsAccount</span> <span class=\"keyword\">extends</span> <span class=\"title\">Account</span> <span class=\"keyword\">with</span> <span class=\"title\">FileLogger</span> <span class=\"keyword\">with</span> <span class=\"title\">ShortLogger</span></span></span><br></pre></td></tr></table></figure>\n<p>构造顺序</p>\n<ol>\n<li>Account // 对象首先调用父类构造器。</li>\n<li>Logger // 每个特质中，父特质先构造。</li>\n<li>FileLogger // 对象首先调用父类构造器。</li>\n<li>ShortLogger // 特质构造顺序和调用顺序相反，由左至右。</li>\n<li>SavingsAccount // 所有特质构造器完成，子类再构造。</li>\n</ol>\n<p>同样是之前的例子，调用顺序和初始化顺序放到一起打印：</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//父特质</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">trait</span> <span class=\"title\">Logger</span> </span>&#123;</span><br><span class=\"line\">  println(<span class=\"string\">\"Logger init\"</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">log</span></span>(msg: <span class=\"type\">String</span>) &#123;</span><br><span class=\"line\">    println(<span class=\"string\">\"Logger.log\"</span>)</span><br><span class=\"line\">    println(msg)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//给日志加时间戳</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">trait</span> <span class=\"title\">TimestampLogger</span> <span class=\"keyword\">extends</span> <span class=\"title\">Logger</span> </span>&#123;</span><br><span class=\"line\">  println(<span class=\"string\">\"TimestampLogger init\"</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">log</span></span>(msg: <span class=\"type\">String</span>) &#123;</span><br><span class=\"line\">    println(<span class=\"string\">\"TimestampLogger.log\"</span>)</span><br><span class=\"line\">    <span class=\"keyword\">super</span>.log(<span class=\"keyword\">new</span> java.util.<span class=\"type\">Date</span>() + <span class=\"string\">\" \"</span> + msg)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//截断日志</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">trait</span> <span class=\"title\">ShortLogger</span> <span class=\"keyword\">extends</span> <span class=\"title\">Logger</span> </span>&#123;</span><br><span class=\"line\">  println(<span class=\"string\">\"ShortLogger init\"</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">val</span> maxLength = <span class=\"number\">15</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 特质中的字段，下面会讲</span></span><br><span class=\"line\">  <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">log</span></span>(msg: <span class=\"type\">String</span>) &#123;</span><br><span class=\"line\">    println(<span class=\"string\">\"ShortLogger.log\"</span>)</span><br><span class=\"line\">    <span class=\"keyword\">super</span>.log(<span class=\"keyword\">if</span> (msg.length &lt;= maxLength) msg <span class=\"keyword\">else</span> msg.substring(<span class=\"number\">0</span>, maxLength - <span class=\"number\">3</span>) + <span class=\"string\">\"...\"</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Account</span> </span>&#123;</span><br><span class=\"line\">  println(<span class=\"string\">\"Account init\"</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SavingsAccount</span> <span class=\"keyword\">extends</span> <span class=\"title\">Account</span> <span class=\"keyword\">with</span> <span class=\"title\">TimestampLogger</span> <span class=\"keyword\">with</span> <span class=\"title\">ShortLogger</span></span></span><br><span class=\"line\"><span class=\"class\"></span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">object</span> <span class=\"title\">MyTest10</span> <span class=\"keyword\">extends</span> <span class=\"title\">App</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">val</span> acct = <span class=\"keyword\">new</span> <span class=\"type\">SavingsAccount</span></span><br><span class=\"line\">  println(<span class=\"string\">\"初始化顺序打印完成！下面开始打印调用顺序：\"</span>)</span><br><span class=\"line\">  acct.log(<span class=\"string\">\"1234567890123456\"</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 输出</span></span><br><span class=\"line\"><span class=\"comment\">// Account init</span></span><br><span class=\"line\"><span class=\"comment\">// Logger init</span></span><br><span class=\"line\"><span class=\"comment\">// TimestampLogger init</span></span><br><span class=\"line\"><span class=\"comment\">// ShortLogger init</span></span><br><span class=\"line\"><span class=\"comment\">// 初始化顺序打印完成！下面开始打印调用顺序：</span></span><br><span class=\"line\"><span class=\"comment\">// ShortLogger.log</span></span><br><span class=\"line\"><span class=\"comment\">// TimestampLogger.log</span></span><br><span class=\"line\"><span class=\"comment\">// Logger.log</span></span><br></pre></td></tr></table></figure>\n<p>可见第一轮全部先初始化，第二轮开始调用。顺序正好相反。</p>\n<p>线性化是描述某个类型的所有父类型的规范，定义：<br>\n如果C extends C1 with C2 with … Cn，则 lin© = C &gt;&gt; lin(Cn) &gt;&gt; … &gt;&gt; lin(C2) &gt;&gt; lin(C1)<br>\n“&gt;&gt;”表示串联并去掉重复项，右侧胜出。<br>\n线性化顺序就是之前所说的super调用顺序。</p>\n<hr>\n<h3 id=\"初始化特质中的字段\"><a class=\"markdownIt-Anchor\" href=\"#初始化特质中的字段\"></a> 初始化特质中的字段</h3>\n<p>特质不能有构造参数，每个特质都有一个无参的构造函数。</p>\n<pre><code>缺少构造参数是特质和类的唯一差别\n</code></pre>\n<p>由于特质是无参构造，而且先于子类构造，那么如果想在常规构造之前初始化一些字段时，可以：</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> acct = <span class=\"keyword\">new</span> &#123; <span class=\"keyword\">val</span> filename = <span class=\"string\">\"myapp.log\"</span> &#125; <span class=\"keyword\">with</span> <span class=\"type\">FileLogger</span> <span class=\"keyword\">with</span> <span class=\"type\">ShortLogger</span></span><br><span class=\"line\"><span class=\"comment\">//如果在类中实现</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SavingsAccount</span> <span class=\"keyword\">extends</span> </span>&#123; <span class=\"keyword\">val</span> filename = <span class=\"string\">\"myapp.log\"</span> &#125; <span class=\"keyword\">with</span> <span class=\"type\">FileLogger</span> <span class=\"keyword\">with</span> <span class=\"type\">ShortLogger</span></span><br></pre></td></tr></table></figure>\n<p>也可以使用lazy值，只是效率不是很高。</p>\n<hr>\n<p>继承类的特质<br>\n类也可以被特质继承（变态啊）。若如此，该类也将自动成为该特质子类的父类。</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">trait</span> <span class=\"title\">LoggedException</span> <span class=\"keyword\">extends</span> <span class=\"title\">Exception</span> <span class=\"keyword\">with</span> <span class=\"title\">Logger</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">log</span></span>() &#123; log(getMessage()) &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">UnhappyException</span> <span class=\"keyword\">extends</span> <span class=\"title\">LoggedException</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">getMessage</span></span>() = <span class=\"string\">\"arggh\"</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<pre><code>| Exception |   | LoggedException |\n        ↖           ↗ \n      | UnhappyException |\n</code></pre>\n<p>如果子类已经有一个父类，那么该父类必须是那个特质父类的子类。</p>\n<hr>\n<h3 id=\"自身类型\"><a class=\"markdownIt-Anchor\" href=\"#自身类型\"></a> 自身类型</h3>\n<p>当特质继承类时，编译器会把所有该特质的子类都认这个类为父类。scala还有另一套机制可以保证这一点：自身类型（self type）。<br>\n定义如下：</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">this</span>: 类型 =&gt;</span><br></pre></td></tr></table></figure>\n<p>例：</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">trait</span> <span class=\"title\">LoggedException</span> <span class=\"keyword\">extends</span> <span class=\"title\">Logger</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>: <span class=\"type\">Exception</span> =&gt; <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">log</span></span>() &#123; log(getMessage()) &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">UnhappyException</span> <span class=\"keyword\">extends</span> <span class=\"title\">Exception</span> <span class=\"keyword\">with</span> <span class=\"title\">LoggedException</span></span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">getMessage</span></span>() = <span class=\"string\">\"arggh\"</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>LoggedException类这样就只能被Exception的子类继承。<br>\n后面会更详细介绍这里自身类型。</p>\n<ul>\n<li>自身类型就是强制要求一些类型必须是某些类的子类。</li>\n<li>还有一种结构类型是强制要求一些类具有种个方法，属于一种轻量的接口。</li>\n</ul>\n<h3 id=\"特质的背后\"><a class=\"markdownIt-Anchor\" href=\"#特质的背后\"></a> 特质的背后</h3>\n<p>特质会被翻译成jvm的类和接口。</p>\n<ul>\n<li>没有具体实现的特质，会直接翻译成java中的接口。</li>\n<li>有具体实现的方法scala会帮我们创建一个伴生类，该类用静态方法来存方法。</li>\n<li>这些伴生类不会有任何字段，对应的字段用getter和setter方法来表示。</li>\n<li>如果特质继承了某个父类，则伴生类不会继承这个父类。这个父类会被所有实现该特质的子类继承。</li>\n</ul>\n"},{"title":"Chapter-11-operators","catalog":true,"date":"2015-06-22T09:21:29.000Z","header-img":"/img/04.jpg","_content":"\n## Chapter-11-operators\n\n操作符\n\n---\n\n### 标识符和操作符\n变量、函数、类等名称统称为标识符。在scala中的标识符，一般不跟关键字冲突，几乎所有的Unicode字符都可以。\n\n在scala中，很多时候操作符实际上是函数名，所以标识符和操作符这两个概念差别不大。\n\n常见的赋值操作符\n\n    a 操作符= b\n    等价于： a = a 操作符 b\n    \n---\n\n### infix（中置）\n    a 标识符 b\n    如 1 to 10\n这样的标识符在两个参数之间的表达式叫infix表达式（中置表达式）\n\n---\n\n### postfix和perfix (后置和前置)\n后置和前置表达式都一元的，就是只有一个参数。中置由于有两个参数，所以叫二元表达式。（承自haskell同样的概念）\n\n若标识符在后面，就叫后置。反之叫前置。\n    a 标识符 // 后置\n    如 1 toString\n    -a // 前置\n    \n后置操作符的优先级低于中置\n    a 中置操作符 b 后置操作符\n    上述代码等同于：\n    (a 中置操作符 b) 后置操作符\n    \n---\n\n### 左结合和右结合\n在优先级相同时，scala中的表达式默认是左结合，就是从左边向右开始计算。以下两种方式为右结合：\n\n* 以冒号（:）结尾的操作符\n* 赋值操作符\n\n用于构造List的::的操作符就是右结合的，如：\n\n```scala\n1 :: 2 :: Nil\n//意思是：\n1 :: (2 :: Nil)\n//这样先有2然后再把2挂到集合的尾部就成了List(1, 2)\n```\n右结合的二元操作符其实是第二个参数的方法：\n\n```scala\n2 :: Nil\n//等价于\nNil.::(2)\n```\n\n---\n\n### apply和update方法\n\n\n```scala\nf(arg1, arg2, ...)\nf(arg1, arg2, ...) = value\n```\n如果f不是函数，那么上面的代码实际上调用的是apply和update方法：\n\n\n```scala\nf.apply(arg1, arg2, ...) //如果f不是函数，这行代码与f(arg1, arg2, ...)等价\nf.update(arg1, arg2, ..., value) // 如果f不是函数，这行代码与f(arg1, arg2, ...) = value等价\n```\n这种机制被用在了数据和映射上，如：\n\n\n```scala\nval scores = new collection.mutable.HashMap[String, Int]\nscores(\"Bob\") = 100 //调用score.update(\"Bob\", 100)\nscores(\"Bob\")       //调用score.apply(\"Bob\")\n```\n同时，如之前章节提到的伴生对象，也是使用的这种方式：\n\n\n```scala\nclass Fraction(n: Int, d: Int)\n\nobject Fraction {\n  def apply(n: Int, d: Int) = new Fraction(n, d)\n}\n```\n---\n\n### 提取器\n顾名思义，unapply是反向apply。它接受一个对象，反解成具体的值。这种方式叫提取器（Extractor）。\n\nscala有三种提取器：\n\n* **def unapply(object: S): Option[(T1, ..., Tn)]**\n* **def unapply(object: S): Option[T]**\n* **def unapply(object: S): Boolean**\n\n#### 第一种提取器：def unapply(object: S): Option[(T1, ..., Tn)]\n\n\n```scala\nclass Fraction(n: Int, d: Int) {\n  def *(f: Fraction): Fraction = Fraction(n * f.n, d * f.d)\n}\n\nobject Fraction {\n  def apply(n: Int, d: Int) = new Fraction(n, d)\n  def unapply(input: Fraction) = if (input.d == 0) None else Some((input.n, input.d, input.hashcode))\n}\n\n\nvar Fraction(a, b, c) = Fraction(3, 4) * Fraction(2, 5)\nprintln(\"a:\" + a + \", b:\" + b + \", c:\" + c)\n//输出a:6, b:20, c:586617651\n```\nunapply反回一个Option，它包含一个元组。里面可以放一些值进去。\n注意它和模式匹配（后面会讲）有点像，但是实际上不相同：\n\n```scala\nvar Fraction(a, b, c) = ...\ncase Fraction(a, b, c) => ...\n```\n其实unapply能接受任何参数，并不局限于该类对象：\n\n\n```scala\nobject Name {\n  def unapply(input: String) = { // 接受一个String\n    val x = input.split(\" \")\n    Some(x(0), x(1))\n  }\n}\n\nval author = \"Allon Li\"\nvar Name(first, last) = author // Name.unapply(author)\nprintln(\"first:\" + first + \", last:\" + last)\n//输出 first:Allon, last:Li\n```\n每个case class（在后面会讲）默认会配备一对apply和unapply\n\n\n```scala\ncase class Name(first: String, last: String) \n\nval author = Name(\"Allon\",\"Li\") //apply\n\nauthor match {\n  case Name(first, \"Li\") => println(\"the first name : \" + first) // Name.unapply(author) ,这行代码表示：last name 必须为\"Li\"的人才能匹配成功。\n}\n```\n\n\nscala中没有一个元素的元组，如果要用unapply提取单个值，要指定它的返回值类型为Option的泛型。那就用到了，第二种提取器。如下：\n#### 第二种提取器：def unapply(object: S): Option[T]\n\n```scala\nobject Number {\n    def unapply(input: String): Option[Int] =\n    try {\n        Some(Integer.parseInt(input.trim))\n    } catch {\n        case ex: NumberFormatException => None\n    }\n}\n\nval Number(n) = \"1729\"\n```\n也可以用于测试输入，但不提取值。这时，unapply返回Boolean。这要就用到了第三种提取器：\n#### 第三种提取器：def unapply(object: S): Boolean\n\n```scala\nobject IsCompound {\n    def unapply(input: String) = input.contains(\" \")\n}\n\nauthor match {\n  case IsCompound() => println(\"is compound\") //IsCompound()里的()不能省\n  case _ => println(\"...\")\n}\n```\n**在使用case时，对于返回Option的提取器，如果调用unapply方法成功返回Some，就算是成功。对于返回Boolean的提取器，如果调用unapply方法返回true，那就是匹配成功。**\n\n同样可以把第一种和第三种提取器结合，就像以下代码：\n\n\n```scala\nauthor match{\n    case Name(first, last @ IsCompound()) => println(\"has a compound last name\")\n    case Name(first, last) => println(\"don't has a compound name\")\n    case _ => println(\"...\")\n  }\n```\n上面代码中第一个case是一种复合匹配，只有当Name这个提取器匹配成功，并且提取出来的第二个变量匹配成功IsCompound()时，整个模式才会匹配成功。在这里@定义了一个变量last，把它绑定到成功匹配了IsCompound的那个值上。\n\n#### 提取序列\n前面提到的提取器，都要固定返回值个数，也可以让提取器任意个数返回结果。这要使用unapplySeq方法。\n\n\n```scala\nobject Name {\n  def unapplySeq(input: String): Option[Seq[String]] = {\n    Some(input.split(\" \"))\n  }\n}\n\nauthor match { // author是unapplySeq的入参\n  case Name(first, \"Li\") => println(\"the first name : \" + first)\n  case Name(\"Allon\", middle, \"Li\") => println(\"the middle name : \" + middle)\n}\n```\n如果同时定义unapplySeq和冲突的unapply，会报错。\n\n\n","source":"_posts/Chapter-11-operators.md","raw":"---\ntitle: 'Chapter-11-operators'\ncatalog: true\ndate: 2015-06-22 17:21:29\nheader-img: \"/img/04.jpg\"\ntags: \"scala\"\n---\n\n## Chapter-11-operators\n\n操作符\n\n---\n\n### 标识符和操作符\n变量、函数、类等名称统称为标识符。在scala中的标识符，一般不跟关键字冲突，几乎所有的Unicode字符都可以。\n\n在scala中，很多时候操作符实际上是函数名，所以标识符和操作符这两个概念差别不大。\n\n常见的赋值操作符\n\n    a 操作符= b\n    等价于： a = a 操作符 b\n    \n---\n\n### infix（中置）\n    a 标识符 b\n    如 1 to 10\n这样的标识符在两个参数之间的表达式叫infix表达式（中置表达式）\n\n---\n\n### postfix和perfix (后置和前置)\n后置和前置表达式都一元的，就是只有一个参数。中置由于有两个参数，所以叫二元表达式。（承自haskell同样的概念）\n\n若标识符在后面，就叫后置。反之叫前置。\n    a 标识符 // 后置\n    如 1 toString\n    -a // 前置\n    \n后置操作符的优先级低于中置\n    a 中置操作符 b 后置操作符\n    上述代码等同于：\n    (a 中置操作符 b) 后置操作符\n    \n---\n\n### 左结合和右结合\n在优先级相同时，scala中的表达式默认是左结合，就是从左边向右开始计算。以下两种方式为右结合：\n\n* 以冒号（:）结尾的操作符\n* 赋值操作符\n\n用于构造List的::的操作符就是右结合的，如：\n\n```scala\n1 :: 2 :: Nil\n//意思是：\n1 :: (2 :: Nil)\n//这样先有2然后再把2挂到集合的尾部就成了List(1, 2)\n```\n右结合的二元操作符其实是第二个参数的方法：\n\n```scala\n2 :: Nil\n//等价于\nNil.::(2)\n```\n\n---\n\n### apply和update方法\n\n\n```scala\nf(arg1, arg2, ...)\nf(arg1, arg2, ...) = value\n```\n如果f不是函数，那么上面的代码实际上调用的是apply和update方法：\n\n\n```scala\nf.apply(arg1, arg2, ...) //如果f不是函数，这行代码与f(arg1, arg2, ...)等价\nf.update(arg1, arg2, ..., value) // 如果f不是函数，这行代码与f(arg1, arg2, ...) = value等价\n```\n这种机制被用在了数据和映射上，如：\n\n\n```scala\nval scores = new collection.mutable.HashMap[String, Int]\nscores(\"Bob\") = 100 //调用score.update(\"Bob\", 100)\nscores(\"Bob\")       //调用score.apply(\"Bob\")\n```\n同时，如之前章节提到的伴生对象，也是使用的这种方式：\n\n\n```scala\nclass Fraction(n: Int, d: Int)\n\nobject Fraction {\n  def apply(n: Int, d: Int) = new Fraction(n, d)\n}\n```\n---\n\n### 提取器\n顾名思义，unapply是反向apply。它接受一个对象，反解成具体的值。这种方式叫提取器（Extractor）。\n\nscala有三种提取器：\n\n* **def unapply(object: S): Option[(T1, ..., Tn)]**\n* **def unapply(object: S): Option[T]**\n* **def unapply(object: S): Boolean**\n\n#### 第一种提取器：def unapply(object: S): Option[(T1, ..., Tn)]\n\n\n```scala\nclass Fraction(n: Int, d: Int) {\n  def *(f: Fraction): Fraction = Fraction(n * f.n, d * f.d)\n}\n\nobject Fraction {\n  def apply(n: Int, d: Int) = new Fraction(n, d)\n  def unapply(input: Fraction) = if (input.d == 0) None else Some((input.n, input.d, input.hashcode))\n}\n\n\nvar Fraction(a, b, c) = Fraction(3, 4) * Fraction(2, 5)\nprintln(\"a:\" + a + \", b:\" + b + \", c:\" + c)\n//输出a:6, b:20, c:586617651\n```\nunapply反回一个Option，它包含一个元组。里面可以放一些值进去。\n注意它和模式匹配（后面会讲）有点像，但是实际上不相同：\n\n```scala\nvar Fraction(a, b, c) = ...\ncase Fraction(a, b, c) => ...\n```\n其实unapply能接受任何参数，并不局限于该类对象：\n\n\n```scala\nobject Name {\n  def unapply(input: String) = { // 接受一个String\n    val x = input.split(\" \")\n    Some(x(0), x(1))\n  }\n}\n\nval author = \"Allon Li\"\nvar Name(first, last) = author // Name.unapply(author)\nprintln(\"first:\" + first + \", last:\" + last)\n//输出 first:Allon, last:Li\n```\n每个case class（在后面会讲）默认会配备一对apply和unapply\n\n\n```scala\ncase class Name(first: String, last: String) \n\nval author = Name(\"Allon\",\"Li\") //apply\n\nauthor match {\n  case Name(first, \"Li\") => println(\"the first name : \" + first) // Name.unapply(author) ,这行代码表示：last name 必须为\"Li\"的人才能匹配成功。\n}\n```\n\n\nscala中没有一个元素的元组，如果要用unapply提取单个值，要指定它的返回值类型为Option的泛型。那就用到了，第二种提取器。如下：\n#### 第二种提取器：def unapply(object: S): Option[T]\n\n```scala\nobject Number {\n    def unapply(input: String): Option[Int] =\n    try {\n        Some(Integer.parseInt(input.trim))\n    } catch {\n        case ex: NumberFormatException => None\n    }\n}\n\nval Number(n) = \"1729\"\n```\n也可以用于测试输入，但不提取值。这时，unapply返回Boolean。这要就用到了第三种提取器：\n#### 第三种提取器：def unapply(object: S): Boolean\n\n```scala\nobject IsCompound {\n    def unapply(input: String) = input.contains(\" \")\n}\n\nauthor match {\n  case IsCompound() => println(\"is compound\") //IsCompound()里的()不能省\n  case _ => println(\"...\")\n}\n```\n**在使用case时，对于返回Option的提取器，如果调用unapply方法成功返回Some，就算是成功。对于返回Boolean的提取器，如果调用unapply方法返回true，那就是匹配成功。**\n\n同样可以把第一种和第三种提取器结合，就像以下代码：\n\n\n```scala\nauthor match{\n    case Name(first, last @ IsCompound()) => println(\"has a compound last name\")\n    case Name(first, last) => println(\"don't has a compound name\")\n    case _ => println(\"...\")\n  }\n```\n上面代码中第一个case是一种复合匹配，只有当Name这个提取器匹配成功，并且提取出来的第二个变量匹配成功IsCompound()时，整个模式才会匹配成功。在这里@定义了一个变量last，把它绑定到成功匹配了IsCompound的那个值上。\n\n#### 提取序列\n前面提到的提取器，都要固定返回值个数，也可以让提取器任意个数返回结果。这要使用unapplySeq方法。\n\n\n```scala\nobject Name {\n  def unapplySeq(input: String): Option[Seq[String]] = {\n    Some(input.split(\" \"))\n  }\n}\n\nauthor match { // author是unapplySeq的入参\n  case Name(first, \"Li\") => println(\"the first name : \" + first)\n  case Name(\"Allon\", middle, \"Li\") => println(\"the middle name : \" + middle)\n}\n```\n如果同时定义unapplySeq和冲突的unapply，会报错。\n\n\n","slug":"Chapter-11-operators","published":1,"updated":"2017-11-25T06:28:50.497Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjahvvnxq000mpv4n0a2bm8jg","content":"<h2><span id=\"chapter-11-operators\"> Chapter-11-operators</span></h2>\n<p>操作符</p>\n<hr>\n<h3><span id=\"标识符和操作符\"> 标识符和操作符</span></h3>\n<p>变量、函数、类等名称统称为标识符。在scala中的标识符，一般不跟关键字冲突，几乎所有的Unicode字符都可以。</p>\n<p>在scala中，很多时候操作符实际上是函数名，所以标识符和操作符这两个概念差别不大。</p>\n<p>常见的赋值操作符</p>\n<pre><code>a 操作符= b\n等价于： a = a 操作符 b\n</code></pre>\n<hr>\n<h3><span id=\"infix中置\"> infix（中置）</span></h3>\n<pre><code>a 标识符 b\n如 1 to 10\n</code></pre>\n<p>这样的标识符在两个参数之间的表达式叫infix表达式（中置表达式）</p>\n<hr>\n<h3><span id=\"postfix和perfix-后置和前置\"> postfix和perfix (后置和前置)</span></h3>\n<p>后置和前置表达式都一元的，就是只有一个参数。中置由于有两个参数，所以叫二元表达式。（承自haskell同样的概念）</p>\n<p>若标识符在后面，就叫后置。反之叫前置。<br>\na 标识符 // 后置<br>\n如 1 toString<br>\n-a // 前置</p>\n<p>后置操作符的优先级低于中置<br>\na 中置操作符 b 后置操作符<br>\n上述代码等同于：<br>\n(a 中置操作符 b) 后置操作符</p>\n<hr>\n<h3><span id=\"左结合和右结合\"> 左结合和右结合</span></h3>\n<p>在优先级相同时，scala中的表达式默认是左结合，就是从左边向右开始计算。以下两种方式为右结合：</p>\n<ul>\n<li>以冒号（:）结尾的操作符</li>\n<li>赋值操作符</li>\n</ul>\n<p>用于构造List的::的操作符就是右结合的，如：</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1</span> :: <span class=\"number\">2</span> :: <span class=\"type\">Nil</span></span><br><span class=\"line\"><span class=\"comment\">//意思是：</span></span><br><span class=\"line\"><span class=\"number\">1</span> :: (<span class=\"number\">2</span> :: <span class=\"type\">Nil</span>)</span><br><span class=\"line\"><span class=\"comment\">//这样先有2然后再把2挂到集合的尾部就成了List(1, 2)</span></span><br></pre></td></tr></table></figure>\n<p>右结合的二元操作符其实是第二个参数的方法：</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">2</span> :: <span class=\"type\">Nil</span></span><br><span class=\"line\"><span class=\"comment\">//等价于</span></span><br><span class=\"line\"><span class=\"type\">Nil</span>.::(<span class=\"number\">2</span>)</span><br></pre></td></tr></table></figure>\n<hr>\n<h3><span id=\"apply和update方法\"> apply和update方法</span></h3>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">f(arg1, arg2, ...)</span><br><span class=\"line\">f(arg1, arg2, ...) = value</span><br></pre></td></tr></table></figure>\n<p>如果f不是函数，那么上面的代码实际上调用的是apply和update方法：</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">f.apply(arg1, arg2, ...) <span class=\"comment\">//如果f不是函数，这行代码与f(arg1, arg2, ...)等价</span></span><br><span class=\"line\">f.update(arg1, arg2, ..., value) <span class=\"comment\">// 如果f不是函数，这行代码与f(arg1, arg2, ...) = value等价</span></span><br></pre></td></tr></table></figure>\n<p>这种机制被用在了数据和映射上，如：</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> scores = <span class=\"keyword\">new</span> collection.mutable.<span class=\"type\">HashMap</span>[<span class=\"type\">String</span>, <span class=\"type\">Int</span>]</span><br><span class=\"line\">scores(<span class=\"string\">\"Bob\"</span>) = <span class=\"number\">100</span> <span class=\"comment\">//调用score.update(\"Bob\", 100)</span></span><br><span class=\"line\">scores(<span class=\"string\">\"Bob\"</span>)       <span class=\"comment\">//调用score.apply(\"Bob\")</span></span><br></pre></td></tr></table></figure>\n<p>同时，如之前章节提到的伴生对象，也是使用的这种方式：</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Fraction</span>(<span class=\"params\">n: <span class=\"type\">Int</span>, d: <span class=\"type\">Int</span></span>)</span></span><br><span class=\"line\"><span class=\"class\"></span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">object</span> <span class=\"title\">Fraction</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">apply</span></span>(n: <span class=\"type\">Int</span>, d: <span class=\"type\">Int</span>) = <span class=\"keyword\">new</span> <span class=\"type\">Fraction</span>(n, d)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<hr>\n<h3><span id=\"提取器\"> 提取器</span></h3>\n<p>顾名思义，unapply是反向apply。它接受一个对象，反解成具体的值。这种方式叫提取器（Extractor）。</p>\n<p>scala有三种提取器：</p>\n<ul>\n<li><strong>def unapply(object: S): Option[(T1, …, Tn)]</strong></li>\n<li><strong>def unapply(object: S): Option[T]</strong></li>\n<li><strong>def unapply(object: S): Boolean</strong></li>\n</ul>\n<h4><span id=\"第一种提取器def-unapplyobject-s-optiont1-tn\"> 第一种提取器：def unapply(object: S): Option[(T1, …, Tn)]</span></h4>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Fraction</span>(<span class=\"params\">n: <span class=\"type\">Int</span>, d: <span class=\"type\">Int</span></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">*</span></span>(f: <span class=\"type\">Fraction</span>): <span class=\"type\">Fraction</span> = <span class=\"type\">Fraction</span>(n * f.n, d * f.d)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">object</span> <span class=\"title\">Fraction</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">apply</span></span>(n: <span class=\"type\">Int</span>, d: <span class=\"type\">Int</span>) = <span class=\"keyword\">new</span> <span class=\"type\">Fraction</span>(n, d)</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">unapply</span></span>(input: <span class=\"type\">Fraction</span>) = <span class=\"keyword\">if</span> (input.d == <span class=\"number\">0</span>) <span class=\"type\">None</span> <span class=\"keyword\">else</span> <span class=\"type\">Some</span>((input.n, input.d, input.hashcode))</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> <span class=\"type\">Fraction</span>(a, b, c) = <span class=\"type\">Fraction</span>(<span class=\"number\">3</span>, <span class=\"number\">4</span>) * <span class=\"type\">Fraction</span>(<span class=\"number\">2</span>, <span class=\"number\">5</span>)</span><br><span class=\"line\">println(<span class=\"string\">\"a:\"</span> + a + <span class=\"string\">\", b:\"</span> + b + <span class=\"string\">\", c:\"</span> + c)</span><br><span class=\"line\"><span class=\"comment\">//输出a:6, b:20, c:586617651</span></span><br></pre></td></tr></table></figure>\n<p>unapply反回一个Option，它包含一个元组。里面可以放一些值进去。<br>\n注意它和模式匹配（后面会讲）有点像，但是实际上不相同：</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> <span class=\"type\">Fraction</span>(a, b, c) = ...</span><br><span class=\"line\"><span class=\"keyword\">case</span> <span class=\"type\">Fraction</span>(a, b, c) =&gt; ...</span><br></pre></td></tr></table></figure>\n<p>其实unapply能接受任何参数，并不局限于该类对象：</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">object</span> <span class=\"title\">Name</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">unapply</span></span>(input: <span class=\"type\">String</span>) = &#123; <span class=\"comment\">// 接受一个String</span></span><br><span class=\"line\">    <span class=\"keyword\">val</span> x = input.split(<span class=\"string\">\" \"</span>)</span><br><span class=\"line\">    <span class=\"type\">Some</span>(x(<span class=\"number\">0</span>), x(<span class=\"number\">1</span>))</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">val</span> author = <span class=\"string\">\"Allon Li\"</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> <span class=\"type\">Name</span>(first, last) = author <span class=\"comment\">// Name.unapply(author)</span></span><br><span class=\"line\">println(<span class=\"string\">\"first:\"</span> + first + <span class=\"string\">\", last:\"</span> + last)</span><br><span class=\"line\"><span class=\"comment\">//输出 first:Allon, last:Li</span></span><br></pre></td></tr></table></figure>\n<p>每个case class（在后面会讲）默认会配备一对apply和unapply</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">case</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Name</span>(<span class=\"params\">first: <span class=\"type\">String</span>, last: <span class=\"type\">String</span></span>) </span></span><br><span class=\"line\"><span class=\"class\"></span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">val</span> <span class=\"title\">author</span> </span>= <span class=\"type\">Name</span>(<span class=\"string\">\"Allon\"</span>,<span class=\"string\">\"Li\"</span>) <span class=\"comment\">//apply</span></span><br><span class=\"line\"></span><br><span class=\"line\">author <span class=\"keyword\">match</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">case</span> <span class=\"type\">Name</span>(first, <span class=\"string\">\"Li\"</span>) =&gt; println(<span class=\"string\">\"the first name : \"</span> + first) <span class=\"comment\">// Name.unapply(author) ,这行代码表示：last name 必须为\"Li\"的人才能匹配成功。</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>scala中没有一个元素的元组，如果要用unapply提取单个值，要指定它的返回值类型为Option的泛型。那就用到了，第二种提取器。如下：</p>\n<h4><span id=\"第二种提取器def-unapplyobject-s-optiont\"> 第二种提取器：def unapply(object: S): Option[T]</span></h4>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">object</span> <span class=\"title\">Number</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">unapply</span></span>(input: <span class=\"type\">String</span>): <span class=\"type\">Option</span>[<span class=\"type\">Int</span>] =</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">Some</span>(<span class=\"type\">Integer</span>.parseInt(input.trim))</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> ex: <span class=\"type\">NumberFormatException</span> =&gt; <span class=\"type\">None</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">val</span> <span class=\"type\">Number</span>(n) = <span class=\"string\">\"1729\"</span></span><br></pre></td></tr></table></figure>\n<p>也可以用于测试输入，但不提取值。这时，unapply返回Boolean。这要就用到了第三种提取器：</p>\n<h4><span id=\"第三种提取器def-unapplyobject-s-boolean\"> 第三种提取器：def unapply(object: S): Boolean</span></h4>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">object</span> <span class=\"title\">IsCompound</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">unapply</span></span>(input: <span class=\"type\">String</span>) = input.contains(<span class=\"string\">\" \"</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">author <span class=\"keyword\">match</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">case</span> <span class=\"type\">IsCompound</span>() =&gt; println(<span class=\"string\">\"is compound\"</span>) <span class=\"comment\">//IsCompound()里的()不能省</span></span><br><span class=\"line\">  <span class=\"keyword\">case</span> _ =&gt; println(<span class=\"string\">\"...\"</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>在使用case时，对于返回Option的提取器，如果调用unapply方法成功返回Some，就算是成功。对于返回Boolean的提取器，如果调用unapply方法返回true，那就是匹配成功。</strong></p>\n<p>同样可以把第一种和第三种提取器结合，就像以下代码：</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">author <span class=\"keyword\">match</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"type\">Name</span>(first, last @ <span class=\"type\">IsCompound</span>()) =&gt; println(<span class=\"string\">\"has a compound last name\"</span>)</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"type\">Name</span>(first, last) =&gt; println(<span class=\"string\">\"don't has a compound name\"</span>)</span><br><span class=\"line\">    <span class=\"keyword\">case</span> _ =&gt; println(<span class=\"string\">\"...\"</span>)</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n<p>上面代码中第一个case是一种复合匹配，只有当Name这个提取器匹配成功，并且提取出来的第二个变量匹配成功IsCompound()时，整个模式才会匹配成功。在这里@定义了一个变量last，把它绑定到成功匹配了IsCompound的那个值上。</p>\n<h4><span id=\"提取序列\"> 提取序列</span></h4>\n<p>前面提到的提取器，都要固定返回值个数，也可以让提取器任意个数返回结果。这要使用unapplySeq方法。</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">object</span> <span class=\"title\">Name</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">unapplySeq</span></span>(input: <span class=\"type\">String</span>): <span class=\"type\">Option</span>[<span class=\"type\">Seq</span>[<span class=\"type\">String</span>]] = &#123;</span><br><span class=\"line\">    <span class=\"type\">Some</span>(input.split(<span class=\"string\">\" \"</span>))</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">author <span class=\"keyword\">match</span> &#123; <span class=\"comment\">// author是unapplySeq的入参</span></span><br><span class=\"line\">  <span class=\"keyword\">case</span> <span class=\"type\">Name</span>(first, <span class=\"string\">\"Li\"</span>) =&gt; println(<span class=\"string\">\"the first name : \"</span> + first)</span><br><span class=\"line\">  <span class=\"keyword\">case</span> <span class=\"type\">Name</span>(<span class=\"string\">\"Allon\"</span>, middle, <span class=\"string\">\"Li\"</span>) =&gt; println(<span class=\"string\">\"the middle name : \"</span> + middle)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如果同时定义unapplySeq和冲突的unapply，会报错。</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"chapter-11-operators\"><a class=\"markdownIt-Anchor\" href=\"#chapter-11-operators\"></a> Chapter-11-operators</h2>\n<p>操作符</p>\n<hr>\n<h3 id=\"标识符和操作符\"><a class=\"markdownIt-Anchor\" href=\"#标识符和操作符\"></a> 标识符和操作符</h3>\n<p>变量、函数、类等名称统称为标识符。在scala中的标识符，一般不跟关键字冲突，几乎所有的Unicode字符都可以。</p>\n<p>在scala中，很多时候操作符实际上是函数名，所以标识符和操作符这两个概念差别不大。</p>\n<p>常见的赋值操作符</p>\n<pre><code>a 操作符= b\n等价于： a = a 操作符 b\n</code></pre>\n<hr>\n<h3 id=\"infix中置\"><a class=\"markdownIt-Anchor\" href=\"#infix中置\"></a> infix（中置）</h3>\n<pre><code>a 标识符 b\n如 1 to 10\n</code></pre>\n<p>这样的标识符在两个参数之间的表达式叫infix表达式（中置表达式）</p>\n<hr>\n<h3 id=\"postfix和perfix-后置和前置\"><a class=\"markdownIt-Anchor\" href=\"#postfix和perfix-后置和前置\"></a> postfix和perfix (后置和前置)</h3>\n<p>后置和前置表达式都一元的，就是只有一个参数。中置由于有两个参数，所以叫二元表达式。（承自haskell同样的概念）</p>\n<p>若标识符在后面，就叫后置。反之叫前置。<br>\na 标识符 // 后置<br>\n如 1 toString<br>\n-a // 前置</p>\n<p>后置操作符的优先级低于中置<br>\na 中置操作符 b 后置操作符<br>\n上述代码等同于：<br>\n(a 中置操作符 b) 后置操作符</p>\n<hr>\n<h3 id=\"左结合和右结合\"><a class=\"markdownIt-Anchor\" href=\"#左结合和右结合\"></a> 左结合和右结合</h3>\n<p>在优先级相同时，scala中的表达式默认是左结合，就是从左边向右开始计算。以下两种方式为右结合：</p>\n<ul>\n<li>以冒号（:）结尾的操作符</li>\n<li>赋值操作符</li>\n</ul>\n<p>用于构造List的::的操作符就是右结合的，如：</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1</span> :: <span class=\"number\">2</span> :: <span class=\"type\">Nil</span></span><br><span class=\"line\"><span class=\"comment\">//意思是：</span></span><br><span class=\"line\"><span class=\"number\">1</span> :: (<span class=\"number\">2</span> :: <span class=\"type\">Nil</span>)</span><br><span class=\"line\"><span class=\"comment\">//这样先有2然后再把2挂到集合的尾部就成了List(1, 2)</span></span><br></pre></td></tr></table></figure>\n<p>右结合的二元操作符其实是第二个参数的方法：</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">2</span> :: <span class=\"type\">Nil</span></span><br><span class=\"line\"><span class=\"comment\">//等价于</span></span><br><span class=\"line\"><span class=\"type\">Nil</span>.::(<span class=\"number\">2</span>)</span><br></pre></td></tr></table></figure>\n<hr>\n<h3 id=\"apply和update方法\"><a class=\"markdownIt-Anchor\" href=\"#apply和update方法\"></a> apply和update方法</h3>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">f(arg1, arg2, ...)</span><br><span class=\"line\">f(arg1, arg2, ...) = value</span><br></pre></td></tr></table></figure>\n<p>如果f不是函数，那么上面的代码实际上调用的是apply和update方法：</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">f.apply(arg1, arg2, ...) <span class=\"comment\">//如果f不是函数，这行代码与f(arg1, arg2, ...)等价</span></span><br><span class=\"line\">f.update(arg1, arg2, ..., value) <span class=\"comment\">// 如果f不是函数，这行代码与f(arg1, arg2, ...) = value等价</span></span><br></pre></td></tr></table></figure>\n<p>这种机制被用在了数据和映射上，如：</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> scores = <span class=\"keyword\">new</span> collection.mutable.<span class=\"type\">HashMap</span>[<span class=\"type\">String</span>, <span class=\"type\">Int</span>]</span><br><span class=\"line\">scores(<span class=\"string\">\"Bob\"</span>) = <span class=\"number\">100</span> <span class=\"comment\">//调用score.update(\"Bob\", 100)</span></span><br><span class=\"line\">scores(<span class=\"string\">\"Bob\"</span>)       <span class=\"comment\">//调用score.apply(\"Bob\")</span></span><br></pre></td></tr></table></figure>\n<p>同时，如之前章节提到的伴生对象，也是使用的这种方式：</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Fraction</span>(<span class=\"params\">n: <span class=\"type\">Int</span>, d: <span class=\"type\">Int</span></span>)</span></span><br><span class=\"line\"><span class=\"class\"></span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">object</span> <span class=\"title\">Fraction</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">apply</span></span>(n: <span class=\"type\">Int</span>, d: <span class=\"type\">Int</span>) = <span class=\"keyword\">new</span> <span class=\"type\">Fraction</span>(n, d)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<hr>\n<h3 id=\"提取器\"><a class=\"markdownIt-Anchor\" href=\"#提取器\"></a> 提取器</h3>\n<p>顾名思义，unapply是反向apply。它接受一个对象，反解成具体的值。这种方式叫提取器（Extractor）。</p>\n<p>scala有三种提取器：</p>\n<ul>\n<li><strong>def unapply(object: S): Option[(T1, …, Tn)]</strong></li>\n<li><strong>def unapply(object: S): Option[T]</strong></li>\n<li><strong>def unapply(object: S): Boolean</strong></li>\n</ul>\n<h4 id=\"第一种提取器def-unapplyobject-s-optiont1-tn\"><a class=\"markdownIt-Anchor\" href=\"#第一种提取器def-unapplyobject-s-optiont1-tn\"></a> 第一种提取器：def unapply(object: S): Option[(T1, …, Tn)]</h4>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Fraction</span>(<span class=\"params\">n: <span class=\"type\">Int</span>, d: <span class=\"type\">Int</span></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">*</span></span>(f: <span class=\"type\">Fraction</span>): <span class=\"type\">Fraction</span> = <span class=\"type\">Fraction</span>(n * f.n, d * f.d)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">object</span> <span class=\"title\">Fraction</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">apply</span></span>(n: <span class=\"type\">Int</span>, d: <span class=\"type\">Int</span>) = <span class=\"keyword\">new</span> <span class=\"type\">Fraction</span>(n, d)</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">unapply</span></span>(input: <span class=\"type\">Fraction</span>) = <span class=\"keyword\">if</span> (input.d == <span class=\"number\">0</span>) <span class=\"type\">None</span> <span class=\"keyword\">else</span> <span class=\"type\">Some</span>((input.n, input.d, input.hashcode))</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> <span class=\"type\">Fraction</span>(a, b, c) = <span class=\"type\">Fraction</span>(<span class=\"number\">3</span>, <span class=\"number\">4</span>) * <span class=\"type\">Fraction</span>(<span class=\"number\">2</span>, <span class=\"number\">5</span>)</span><br><span class=\"line\">println(<span class=\"string\">\"a:\"</span> + a + <span class=\"string\">\", b:\"</span> + b + <span class=\"string\">\", c:\"</span> + c)</span><br><span class=\"line\"><span class=\"comment\">//输出a:6, b:20, c:586617651</span></span><br></pre></td></tr></table></figure>\n<p>unapply反回一个Option，它包含一个元组。里面可以放一些值进去。<br>\n注意它和模式匹配（后面会讲）有点像，但是实际上不相同：</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> <span class=\"type\">Fraction</span>(a, b, c) = ...</span><br><span class=\"line\"><span class=\"keyword\">case</span> <span class=\"type\">Fraction</span>(a, b, c) =&gt; ...</span><br></pre></td></tr></table></figure>\n<p>其实unapply能接受任何参数，并不局限于该类对象：</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">object</span> <span class=\"title\">Name</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">unapply</span></span>(input: <span class=\"type\">String</span>) = &#123; <span class=\"comment\">// 接受一个String</span></span><br><span class=\"line\">    <span class=\"keyword\">val</span> x = input.split(<span class=\"string\">\" \"</span>)</span><br><span class=\"line\">    <span class=\"type\">Some</span>(x(<span class=\"number\">0</span>), x(<span class=\"number\">1</span>))</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">val</span> author = <span class=\"string\">\"Allon Li\"</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> <span class=\"type\">Name</span>(first, last) = author <span class=\"comment\">// Name.unapply(author)</span></span><br><span class=\"line\">println(<span class=\"string\">\"first:\"</span> + first + <span class=\"string\">\", last:\"</span> + last)</span><br><span class=\"line\"><span class=\"comment\">//输出 first:Allon, last:Li</span></span><br></pre></td></tr></table></figure>\n<p>每个case class（在后面会讲）默认会配备一对apply和unapply</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">case</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Name</span>(<span class=\"params\">first: <span class=\"type\">String</span>, last: <span class=\"type\">String</span></span>) </span></span><br><span class=\"line\"><span class=\"class\"></span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">val</span> <span class=\"title\">author</span> </span>= <span class=\"type\">Name</span>(<span class=\"string\">\"Allon\"</span>,<span class=\"string\">\"Li\"</span>) <span class=\"comment\">//apply</span></span><br><span class=\"line\"></span><br><span class=\"line\">author <span class=\"keyword\">match</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">case</span> <span class=\"type\">Name</span>(first, <span class=\"string\">\"Li\"</span>) =&gt; println(<span class=\"string\">\"the first name : \"</span> + first) <span class=\"comment\">// Name.unapply(author) ,这行代码表示：last name 必须为\"Li\"的人才能匹配成功。</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>scala中没有一个元素的元组，如果要用unapply提取单个值，要指定它的返回值类型为Option的泛型。那就用到了，第二种提取器。如下：</p>\n<h4 id=\"第二种提取器def-unapplyobject-s-optiont\"><a class=\"markdownIt-Anchor\" href=\"#第二种提取器def-unapplyobject-s-optiont\"></a> 第二种提取器：def unapply(object: S): Option[T]</h4>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">object</span> <span class=\"title\">Number</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">unapply</span></span>(input: <span class=\"type\">String</span>): <span class=\"type\">Option</span>[<span class=\"type\">Int</span>] =</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">Some</span>(<span class=\"type\">Integer</span>.parseInt(input.trim))</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> ex: <span class=\"type\">NumberFormatException</span> =&gt; <span class=\"type\">None</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">val</span> <span class=\"type\">Number</span>(n) = <span class=\"string\">\"1729\"</span></span><br></pre></td></tr></table></figure>\n<p>也可以用于测试输入，但不提取值。这时，unapply返回Boolean。这要就用到了第三种提取器：</p>\n<h4 id=\"第三种提取器def-unapplyobject-s-boolean\"><a class=\"markdownIt-Anchor\" href=\"#第三种提取器def-unapplyobject-s-boolean\"></a> 第三种提取器：def unapply(object: S): Boolean</h4>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">object</span> <span class=\"title\">IsCompound</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">unapply</span></span>(input: <span class=\"type\">String</span>) = input.contains(<span class=\"string\">\" \"</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">author <span class=\"keyword\">match</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">case</span> <span class=\"type\">IsCompound</span>() =&gt; println(<span class=\"string\">\"is compound\"</span>) <span class=\"comment\">//IsCompound()里的()不能省</span></span><br><span class=\"line\">  <span class=\"keyword\">case</span> _ =&gt; println(<span class=\"string\">\"...\"</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>在使用case时，对于返回Option的提取器，如果调用unapply方法成功返回Some，就算是成功。对于返回Boolean的提取器，如果调用unapply方法返回true，那就是匹配成功。</strong></p>\n<p>同样可以把第一种和第三种提取器结合，就像以下代码：</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">author <span class=\"keyword\">match</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"type\">Name</span>(first, last @ <span class=\"type\">IsCompound</span>()) =&gt; println(<span class=\"string\">\"has a compound last name\"</span>)</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"type\">Name</span>(first, last) =&gt; println(<span class=\"string\">\"don't has a compound name\"</span>)</span><br><span class=\"line\">    <span class=\"keyword\">case</span> _ =&gt; println(<span class=\"string\">\"...\"</span>)</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n<p>上面代码中第一个case是一种复合匹配，只有当Name这个提取器匹配成功，并且提取出来的第二个变量匹配成功IsCompound()时，整个模式才会匹配成功。在这里@定义了一个变量last，把它绑定到成功匹配了IsCompound的那个值上。</p>\n<h4 id=\"提取序列\"><a class=\"markdownIt-Anchor\" href=\"#提取序列\"></a> 提取序列</h4>\n<p>前面提到的提取器，都要固定返回值个数，也可以让提取器任意个数返回结果。这要使用unapplySeq方法。</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">object</span> <span class=\"title\">Name</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">unapplySeq</span></span>(input: <span class=\"type\">String</span>): <span class=\"type\">Option</span>[<span class=\"type\">Seq</span>[<span class=\"type\">String</span>]] = &#123;</span><br><span class=\"line\">    <span class=\"type\">Some</span>(input.split(<span class=\"string\">\" \"</span>))</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">author <span class=\"keyword\">match</span> &#123; <span class=\"comment\">// author是unapplySeq的入参</span></span><br><span class=\"line\">  <span class=\"keyword\">case</span> <span class=\"type\">Name</span>(first, <span class=\"string\">\"Li\"</span>) =&gt; println(<span class=\"string\">\"the first name : \"</span> + first)</span><br><span class=\"line\">  <span class=\"keyword\">case</span> <span class=\"type\">Name</span>(<span class=\"string\">\"Allon\"</span>, middle, <span class=\"string\">\"Li\"</span>) =&gt; println(<span class=\"string\">\"the middle name : \"</span> + middle)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如果同时定义unapplySeq和冲突的unapply，会报错。</p>\n"},{"title":"chapter-02-sharing-and-multimedia","catalog":true,"date":"2016-02-22T09:21:29.000Z","header-img":"/img/06.jpg","_content":"\n# chapter-02-sharing-and-multimedia\n\nTags:Training-for-Android-developers\n\n---\n\n## 分享\n### 分享简单的数据\n在构建一个intent时，必须指定这个intent需要触发的actions。Android定义了一些actions，比如ACTION_SEND，该action表明该intent用于从一个activity发送数据到另外一个activity的，甚至可以是跨进程之间的数据发送。\n\n    在不同的程序之间使用intent收发数据是在社交分享内容时最常用的方法。Intent使用户能够通过最常用的程序进行快速简单的分享信息。\n\n```java\nIntent sendIntent = new Intent();\nsendIntent.setAction(Intent.ACTION_SEND);\nsendIntent.putExtra(Intent.EXTRA_TEXT, \"This is my text to send.\");\nsendIntent.setType(\"text/plain\"); // 再度印证了这玩意像request\nstartActivity(sendI``ntent);\n```\n分享多张图片\n```java\nArrayList<Uri> imageUris = new ArrayList<Uri>();\nimageUris.add(imageUri1); // Add your image URIs here\nimageUris.add(imageUri2);\n\nIntent shareIntent = new Intent();\nshareIntent.setAction(Intent.ACTION_SEND_MULTIPLE);\nshareIntent.putParcelableArrayListExtra(Intent.EXTRA_STREAM, imageUris);\nshareIntent.setType(\"image/*\");\nstartActivity(Intent.createChooser(shareIntent, \"Share images to..\"));\n```\n分享多种不同类型的内容，需要使用ACTION_SEND_MULTIPLE与指定到那些数据的URIs列表。分享3张JPEG的图片，那么MIME类型仍然是image/jpeg。如果是不同图片格式的话，应该是用image/*来匹配那些可以接收任何图片类型的activity。如果完全不限格式就是 \\*/\\*。\n\n### 接收数据\n\n```xml\n<activity android:name=\".ui.MyActivity\" >\n    <intent-filter>\n        <action android:name=\"android.intent.action.SEND\" />\n        <category android:name=\"android.intent.category.DEFAULT\" />\n        <data android:mimeType=\"image/*\" />\n    </intent-filter>\n    <intent-filter>\n        <action android:name=\"android.intent.action.SEND\" />\n        <category android:name=\"android.intent.category.DEFAULT\" />\n        <data android:mimeType=\"text/plain\" />\n    </intent-filter>\n    <intent-filter>\n        <action android:name=\"android.intent.action.SEND_MULTIPLE\" />\n        <category android:name=\"android.intent.category.DEFAULT\" />\n        <data android:mimeType=\"image/*\" />\n    </intent-filter>\n</activity>\n```\n代码处理\n```java\nvoid onCreate (Bundle savedInstanceState) {\n    ...\n    // Get intent, action and MIME type\n    Intent intent = getIntent();\n    String action = intent.getAction();\n    String type = intent.getType();\n\n    if (Intent.ACTION_SEND.equals(action) && type != null) {\n        if (\"text/plain\".equals(type)) {\n            handleSendText(intent); // Handle text being sent\n        } else if (type.startsWith(\"image/\")) {\n            handleSendImage(intent); // Handle single image being sent\n        }\n    } else if (Intent.ACTION_SEND_MULTIPLE.equals(action) && type != null) {\n        if (type.startsWith(\"image/\")) {\n            handleSendMultipleImages(intent); // Handle multiple images being sent\n        }\n    } else {\n        // Handle other intents, such as being started from the home screen\n    }\n    ...\n}\n\nvoid handleSendText(Intent intent) {\n    String sharedText = intent.getStringExtra(Intent.EXTRA_TEXT);\n    if (sharedText != null) {\n        // Update UI to reflect text being shared\n    }\n}\n\nvoid handleSendImage(Intent intent) {\n    Uri imageUri = (Uri) intent.getParcelableExtra(Intent.EXTRA_STREAM);\n    if (imageUri != null) {\n        // Update UI to reflect image being shared\n    }\n}\n\nvoid handleSendMultipleImages(Intent intent) {\n    ArrayList<Uri> imageUris = intent.getParcelableArrayListExtra(Intent.EXTRA_STREAM);\n    if (imageUris != null) {\n        // Update UI to reflect multiple images being shared\n    }\n}\n```\n### 大文件分享\n\n分享大文件方式和分享文本和流相似，只不过它不发数据过去，传个引用过去。发的其实不是文件，是文件的URI。“服务端”app把数据分享给其他“客户端”app总共分三步：\n一、生成文件的content URI。\n二、授予URI的临时访问权限。\n三、将URI发送给接收文件的应用程序。\n“客户端”app要拿到这个文件，总共有两步：\n一、发起请求。拿到URI。\n二、通过URI拿到FileDescriptor，开始处理文件。\n    \n>  这一过程中没有文件的安全问题，因为客户端应用程序所收到的所有数据只有文件的Content URI而已。由于URI不包含目录路径信息，客户端应用程序无法查询或打开任何服务端应用程序的其他文件。客户端应用程序仅仅获取了这个文件的访问渠道以及由服务端应用程序授予的访问权限。同时访问权限是临时的，一旦这个客户端应用的任务栈结束了，这个文件将无法再被除服务端应用程序之外的其他应用程序访问。\n\n### NFC传文件\n\n>* Android 4.1（API Level 16）及以上版本的Android系统中使用。\n>* 文件必须放置于外部存储。\n>* 文件必须是全局可读的。我们可以通过File.setReadable(true,false)来为文件设置相应的读权限。\n\n## Android多媒体\n\n### 音频播放\nAndroid为播放音乐，闹铃，通知铃，来电声音，系统声音，打电话声音与拨号声音分别维护了一个独立的音频流。音频操作在AudioManger中进行。\n```java\nAudioManager am = (AudioManager)activity.getSystemService(Context.AUDIO_SERVICE);\nsetVolumeControlStream(AudioManager.STREAM_MUSIC);\n```\n为了防止多个音乐播放应用同时播放音频，Android使用音频焦点（Audio Focus）来控制音频的播放——即只有获取到音频焦点的应用才能够播放音频。requestAudioFocus()方法可以获取我们希望得到的音频流焦点。\n\n短暂的焦点锁定：当计划播放一个短暂的音频时使用（比如播放导航指示）。\n永久的焦点锁定：当计划播放一个较长但时长可预期的音频时使用（比如播放音乐）。\n\n","source":"_posts/chapter-02-sharing-and-multimedia.md","raw":"---\ntitle: 'chapter-02-sharing-and-multimedia'\ncatalog: true\ndate: 2016-02-22 17:21:29\nheader-img: \"/img/06.jpg\"\ntags: \"android\"\n---\n\n# chapter-02-sharing-and-multimedia\n\nTags:Training-for-Android-developers\n\n---\n\n## 分享\n### 分享简单的数据\n在构建一个intent时，必须指定这个intent需要触发的actions。Android定义了一些actions，比如ACTION_SEND，该action表明该intent用于从一个activity发送数据到另外一个activity的，甚至可以是跨进程之间的数据发送。\n\n    在不同的程序之间使用intent收发数据是在社交分享内容时最常用的方法。Intent使用户能够通过最常用的程序进行快速简单的分享信息。\n\n```java\nIntent sendIntent = new Intent();\nsendIntent.setAction(Intent.ACTION_SEND);\nsendIntent.putExtra(Intent.EXTRA_TEXT, \"This is my text to send.\");\nsendIntent.setType(\"text/plain\"); // 再度印证了这玩意像request\nstartActivity(sendI``ntent);\n```\n分享多张图片\n```java\nArrayList<Uri> imageUris = new ArrayList<Uri>();\nimageUris.add(imageUri1); // Add your image URIs here\nimageUris.add(imageUri2);\n\nIntent shareIntent = new Intent();\nshareIntent.setAction(Intent.ACTION_SEND_MULTIPLE);\nshareIntent.putParcelableArrayListExtra(Intent.EXTRA_STREAM, imageUris);\nshareIntent.setType(\"image/*\");\nstartActivity(Intent.createChooser(shareIntent, \"Share images to..\"));\n```\n分享多种不同类型的内容，需要使用ACTION_SEND_MULTIPLE与指定到那些数据的URIs列表。分享3张JPEG的图片，那么MIME类型仍然是image/jpeg。如果是不同图片格式的话，应该是用image/*来匹配那些可以接收任何图片类型的activity。如果完全不限格式就是 \\*/\\*。\n\n### 接收数据\n\n```xml\n<activity android:name=\".ui.MyActivity\" >\n    <intent-filter>\n        <action android:name=\"android.intent.action.SEND\" />\n        <category android:name=\"android.intent.category.DEFAULT\" />\n        <data android:mimeType=\"image/*\" />\n    </intent-filter>\n    <intent-filter>\n        <action android:name=\"android.intent.action.SEND\" />\n        <category android:name=\"android.intent.category.DEFAULT\" />\n        <data android:mimeType=\"text/plain\" />\n    </intent-filter>\n    <intent-filter>\n        <action android:name=\"android.intent.action.SEND_MULTIPLE\" />\n        <category android:name=\"android.intent.category.DEFAULT\" />\n        <data android:mimeType=\"image/*\" />\n    </intent-filter>\n</activity>\n```\n代码处理\n```java\nvoid onCreate (Bundle savedInstanceState) {\n    ...\n    // Get intent, action and MIME type\n    Intent intent = getIntent();\n    String action = intent.getAction();\n    String type = intent.getType();\n\n    if (Intent.ACTION_SEND.equals(action) && type != null) {\n        if (\"text/plain\".equals(type)) {\n            handleSendText(intent); // Handle text being sent\n        } else if (type.startsWith(\"image/\")) {\n            handleSendImage(intent); // Handle single image being sent\n        }\n    } else if (Intent.ACTION_SEND_MULTIPLE.equals(action) && type != null) {\n        if (type.startsWith(\"image/\")) {\n            handleSendMultipleImages(intent); // Handle multiple images being sent\n        }\n    } else {\n        // Handle other intents, such as being started from the home screen\n    }\n    ...\n}\n\nvoid handleSendText(Intent intent) {\n    String sharedText = intent.getStringExtra(Intent.EXTRA_TEXT);\n    if (sharedText != null) {\n        // Update UI to reflect text being shared\n    }\n}\n\nvoid handleSendImage(Intent intent) {\n    Uri imageUri = (Uri) intent.getParcelableExtra(Intent.EXTRA_STREAM);\n    if (imageUri != null) {\n        // Update UI to reflect image being shared\n    }\n}\n\nvoid handleSendMultipleImages(Intent intent) {\n    ArrayList<Uri> imageUris = intent.getParcelableArrayListExtra(Intent.EXTRA_STREAM);\n    if (imageUris != null) {\n        // Update UI to reflect multiple images being shared\n    }\n}\n```\n### 大文件分享\n\n分享大文件方式和分享文本和流相似，只不过它不发数据过去，传个引用过去。发的其实不是文件，是文件的URI。“服务端”app把数据分享给其他“客户端”app总共分三步：\n一、生成文件的content URI。\n二、授予URI的临时访问权限。\n三、将URI发送给接收文件的应用程序。\n“客户端”app要拿到这个文件，总共有两步：\n一、发起请求。拿到URI。\n二、通过URI拿到FileDescriptor，开始处理文件。\n    \n>  这一过程中没有文件的安全问题，因为客户端应用程序所收到的所有数据只有文件的Content URI而已。由于URI不包含目录路径信息，客户端应用程序无法查询或打开任何服务端应用程序的其他文件。客户端应用程序仅仅获取了这个文件的访问渠道以及由服务端应用程序授予的访问权限。同时访问权限是临时的，一旦这个客户端应用的任务栈结束了，这个文件将无法再被除服务端应用程序之外的其他应用程序访问。\n\n### NFC传文件\n\n>* Android 4.1（API Level 16）及以上版本的Android系统中使用。\n>* 文件必须放置于外部存储。\n>* 文件必须是全局可读的。我们可以通过File.setReadable(true,false)来为文件设置相应的读权限。\n\n## Android多媒体\n\n### 音频播放\nAndroid为播放音乐，闹铃，通知铃，来电声音，系统声音，打电话声音与拨号声音分别维护了一个独立的音频流。音频操作在AudioManger中进行。\n```java\nAudioManager am = (AudioManager)activity.getSystemService(Context.AUDIO_SERVICE);\nsetVolumeControlStream(AudioManager.STREAM_MUSIC);\n```\n为了防止多个音乐播放应用同时播放音频，Android使用音频焦点（Audio Focus）来控制音频的播放——即只有获取到音频焦点的应用才能够播放音频。requestAudioFocus()方法可以获取我们希望得到的音频流焦点。\n\n短暂的焦点锁定：当计划播放一个短暂的音频时使用（比如播放导航指示）。\n永久的焦点锁定：当计划播放一个较长但时长可预期的音频时使用（比如播放音乐）。\n\n","slug":"chapter-02-sharing-and-multimedia","published":1,"updated":"2017-11-25T06:38:21.371Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjahvvnxu000opv4nro3x1p54","content":"<h1><span id=\"chapter-02-sharing-and-multimedia\"> chapter-02-sharing-and-multimedia</span></h1>\n<p>Tags:Training-for-Android-developers</p>\n<hr>\n<h2><span id=\"分享\"> 分享</span></h2>\n<h3><span id=\"分享简单的数据\"> 分享简单的数据</span></h3>\n<p>在构建一个intent时，必须指定这个intent需要触发的actions。Android定义了一些actions，比如ACTION_SEND，该action表明该intent用于从一个activity发送数据到另外一个activity的，甚至可以是跨进程之间的数据发送。</p>\n<pre><code>在不同的程序之间使用intent收发数据是在社交分享内容时最常用的方法。Intent使用户能够通过最常用的程序进行快速简单的分享信息。\n</code></pre>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Intent sendIntent = <span class=\"keyword\">new</span> Intent();</span><br><span class=\"line\">sendIntent.setAction(Intent.ACTION_SEND);</span><br><span class=\"line\">sendIntent.putExtra(Intent.EXTRA_TEXT, <span class=\"string\">\"This is my text to send.\"</span>);</span><br><span class=\"line\">sendIntent.setType(<span class=\"string\">\"text/plain\"</span>); <span class=\"comment\">// 再度印证了这玩意像request</span></span><br><span class=\"line\">startActivity(sendI``ntent);</span><br></pre></td></tr></table></figure>\n<p>分享多张图片</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ArrayList&lt;Uri&gt; imageUris = <span class=\"keyword\">new</span> ArrayList&lt;Uri&gt;();</span><br><span class=\"line\">imageUris.add(imageUri1); <span class=\"comment\">// Add your image URIs here</span></span><br><span class=\"line\">imageUris.add(imageUri2);</span><br><span class=\"line\"></span><br><span class=\"line\">Intent shareIntent = <span class=\"keyword\">new</span> Intent();</span><br><span class=\"line\">shareIntent.setAction(Intent.ACTION_SEND_MULTIPLE);</span><br><span class=\"line\">shareIntent.putParcelableArrayListExtra(Intent.EXTRA_STREAM, imageUris);</span><br><span class=\"line\">shareIntent.setType(<span class=\"string\">\"image/*\"</span>);</span><br><span class=\"line\">startActivity(Intent.createChooser(shareIntent, <span class=\"string\">\"Share images to..\"</span>));</span><br></pre></td></tr></table></figure>\n<p>分享多种不同类型的内容，需要使用ACTION_SEND_MULTIPLE与指定到那些数据的URIs列表。分享3张JPEG的图片，那么MIME类型仍然是image/jpeg。如果是不同图片格式的话，应该是用image/*来匹配那些可以接收任何图片类型的activity。如果完全不限格式就是 */*。</p>\n<h3><span id=\"接收数据\"> 接收数据</span></h3>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">activity</span> <span class=\"attr\">android:name</span>=<span class=\"string\">\".ui.MyActivity\"</span> &gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">intent-filter</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">action</span> <span class=\"attr\">android:name</span>=<span class=\"string\">\"android.intent.action.SEND\"</span> /&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">category</span> <span class=\"attr\">android:name</span>=<span class=\"string\">\"android.intent.category.DEFAULT\"</span> /&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">data</span> <span class=\"attr\">android:mimeType</span>=<span class=\"string\">\"image/*\"</span> /&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">intent-filter</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">intent-filter</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">action</span> <span class=\"attr\">android:name</span>=<span class=\"string\">\"android.intent.action.SEND\"</span> /&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">category</span> <span class=\"attr\">android:name</span>=<span class=\"string\">\"android.intent.category.DEFAULT\"</span> /&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">data</span> <span class=\"attr\">android:mimeType</span>=<span class=\"string\">\"text/plain\"</span> /&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">intent-filter</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">intent-filter</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">action</span> <span class=\"attr\">android:name</span>=<span class=\"string\">\"android.intent.action.SEND_MULTIPLE\"</span> /&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">category</span> <span class=\"attr\">android:name</span>=<span class=\"string\">\"android.intent.category.DEFAULT\"</span> /&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">data</span> <span class=\"attr\">android:mimeType</span>=<span class=\"string\">\"image/*\"</span> /&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">intent-filter</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">activity</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>代码处理</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">onCreate</span> <span class=\"params\">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"comment\">// Get intent, action and MIME type</span></span><br><span class=\"line\">    Intent intent = getIntent();</span><br><span class=\"line\">    String action = intent.getAction();</span><br><span class=\"line\">    String type = intent.getType();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (Intent.ACTION_SEND.equals(action) &amp;&amp; type != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"string\">\"text/plain\"</span>.equals(type)) &#123;</span><br><span class=\"line\">            handleSendText(intent); <span class=\"comment\">// Handle text being sent</span></span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (type.startsWith(<span class=\"string\">\"image/\"</span>)) &#123;</span><br><span class=\"line\">            handleSendImage(intent); <span class=\"comment\">// Handle single image being sent</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (Intent.ACTION_SEND_MULTIPLE.equals(action) &amp;&amp; type != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (type.startsWith(<span class=\"string\">\"image/\"</span>)) &#123;</span><br><span class=\"line\">            handleSendMultipleImages(intent); <span class=\"comment\">// Handle multiple images being sent</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// Handle other intents, such as being started from the home screen</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">handleSendText</span><span class=\"params\">(Intent intent)</span> </span>&#123;</span><br><span class=\"line\">    String sharedText = intent.getStringExtra(Intent.EXTRA_TEXT);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (sharedText != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// Update UI to reflect text being shared</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">handleSendImage</span><span class=\"params\">(Intent intent)</span> </span>&#123;</span><br><span class=\"line\">    Uri imageUri = (Uri) intent.getParcelableExtra(Intent.EXTRA_STREAM);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (imageUri != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// Update UI to reflect image being shared</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">handleSendMultipleImages</span><span class=\"params\">(Intent intent)</span> </span>&#123;</span><br><span class=\"line\">    ArrayList&lt;Uri&gt; imageUris = intent.getParcelableArrayListExtra(Intent.EXTRA_STREAM);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (imageUris != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// Update UI to reflect multiple images being shared</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3><span id=\"大文件分享\"> 大文件分享</span></h3>\n<p>分享大文件方式和分享文本和流相似，只不过它不发数据过去，传个引用过去。发的其实不是文件，是文件的URI。“服务端”app把数据分享给其他“客户端”app总共分三步：<br>\n一、生成文件的content URI。<br>\n二、授予URI的临时访问权限。<br>\n三、将URI发送给接收文件的应用程序。<br>\n“客户端”app要拿到这个文件，总共有两步：<br>\n一、发起请求。拿到URI。<br>\n二、通过URI拿到FileDescriptor，开始处理文件。</p>\n<blockquote>\n<p>这一过程中没有文件的安全问题，因为客户端应用程序所收到的所有数据只有文件的Content URI而已。由于URI不包含目录路径信息，客户端应用程序无法查询或打开任何服务端应用程序的其他文件。客户端应用程序仅仅获取了这个文件的访问渠道以及由服务端应用程序授予的访问权限。同时访问权限是临时的，一旦这个客户端应用的任务栈结束了，这个文件将无法再被除服务端应用程序之外的其他应用程序访问。</p>\n</blockquote>\n<h3><span id=\"nfc传文件\"> NFC传文件</span></h3>\n<blockquote>\n<ul>\n<li>Android 4.1（API Level 16）及以上版本的Android系统中使用。</li>\n<li>文件必须放置于外部存储。</li>\n<li>文件必须是全局可读的。我们可以通过File.setReadable(true,false)来为文件设置相应的读权限。</li>\n</ul>\n</blockquote>\n<h2><span id=\"android多媒体\"> Android多媒体</span></h2>\n<h3><span id=\"音频播放\"> 音频播放</span></h3>\n<p>Android为播放音乐，闹铃，通知铃，来电声音，系统声音，打电话声音与拨号声音分别维护了一个独立的音频流。音频操作在AudioManger中进行。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">AudioManager am = (AudioManager)activity.getSystemService(Context.AUDIO_SERVICE);</span><br><span class=\"line\">setVolumeControlStream(AudioManager.STREAM_MUSIC);</span><br></pre></td></tr></table></figure>\n<p>为了防止多个音乐播放应用同时播放音频，Android使用音频焦点（Audio Focus）来控制音频的播放——即只有获取到音频焦点的应用才能够播放音频。requestAudioFocus()方法可以获取我们希望得到的音频流焦点。</p>\n<p>短暂的焦点锁定：当计划播放一个短暂的音频时使用（比如播放导航指示）。<br>\n永久的焦点锁定：当计划播放一个较长但时长可预期的音频时使用（比如播放音乐）。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"chapter-02-sharing-and-multimedia\"><a class=\"markdownIt-Anchor\" href=\"#chapter-02-sharing-and-multimedia\"></a> chapter-02-sharing-and-multimedia</h1>\n<p>Tags:Training-for-Android-developers</p>\n<hr>\n<h2 id=\"分享\"><a class=\"markdownIt-Anchor\" href=\"#分享\"></a> 分享</h2>\n<h3 id=\"分享简单的数据\"><a class=\"markdownIt-Anchor\" href=\"#分享简单的数据\"></a> 分享简单的数据</h3>\n<p>在构建一个intent时，必须指定这个intent需要触发的actions。Android定义了一些actions，比如ACTION_SEND，该action表明该intent用于从一个activity发送数据到另外一个activity的，甚至可以是跨进程之间的数据发送。</p>\n<pre><code>在不同的程序之间使用intent收发数据是在社交分享内容时最常用的方法。Intent使用户能够通过最常用的程序进行快速简单的分享信息。\n</code></pre>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Intent sendIntent = <span class=\"keyword\">new</span> Intent();</span><br><span class=\"line\">sendIntent.setAction(Intent.ACTION_SEND);</span><br><span class=\"line\">sendIntent.putExtra(Intent.EXTRA_TEXT, <span class=\"string\">\"This is my text to send.\"</span>);</span><br><span class=\"line\">sendIntent.setType(<span class=\"string\">\"text/plain\"</span>); <span class=\"comment\">// 再度印证了这玩意像request</span></span><br><span class=\"line\">startActivity(sendI``ntent);</span><br></pre></td></tr></table></figure>\n<p>分享多张图片</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ArrayList&lt;Uri&gt; imageUris = <span class=\"keyword\">new</span> ArrayList&lt;Uri&gt;();</span><br><span class=\"line\">imageUris.add(imageUri1); <span class=\"comment\">// Add your image URIs here</span></span><br><span class=\"line\">imageUris.add(imageUri2);</span><br><span class=\"line\"></span><br><span class=\"line\">Intent shareIntent = <span class=\"keyword\">new</span> Intent();</span><br><span class=\"line\">shareIntent.setAction(Intent.ACTION_SEND_MULTIPLE);</span><br><span class=\"line\">shareIntent.putParcelableArrayListExtra(Intent.EXTRA_STREAM, imageUris);</span><br><span class=\"line\">shareIntent.setType(<span class=\"string\">\"image/*\"</span>);</span><br><span class=\"line\">startActivity(Intent.createChooser(shareIntent, <span class=\"string\">\"Share images to..\"</span>));</span><br></pre></td></tr></table></figure>\n<p>分享多种不同类型的内容，需要使用ACTION_SEND_MULTIPLE与指定到那些数据的URIs列表。分享3张JPEG的图片，那么MIME类型仍然是image/jpeg。如果是不同图片格式的话，应该是用image/*来匹配那些可以接收任何图片类型的activity。如果完全不限格式就是 */*。</p>\n<h3 id=\"接收数据\"><a class=\"markdownIt-Anchor\" href=\"#接收数据\"></a> 接收数据</h3>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">activity</span> <span class=\"attr\">android:name</span>=<span class=\"string\">\".ui.MyActivity\"</span> &gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">intent-filter</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">action</span> <span class=\"attr\">android:name</span>=<span class=\"string\">\"android.intent.action.SEND\"</span> /&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">category</span> <span class=\"attr\">android:name</span>=<span class=\"string\">\"android.intent.category.DEFAULT\"</span> /&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">data</span> <span class=\"attr\">android:mimeType</span>=<span class=\"string\">\"image/*\"</span> /&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">intent-filter</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">intent-filter</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">action</span> <span class=\"attr\">android:name</span>=<span class=\"string\">\"android.intent.action.SEND\"</span> /&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">category</span> <span class=\"attr\">android:name</span>=<span class=\"string\">\"android.intent.category.DEFAULT\"</span> /&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">data</span> <span class=\"attr\">android:mimeType</span>=<span class=\"string\">\"text/plain\"</span> /&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">intent-filter</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">intent-filter</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">action</span> <span class=\"attr\">android:name</span>=<span class=\"string\">\"android.intent.action.SEND_MULTIPLE\"</span> /&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">category</span> <span class=\"attr\">android:name</span>=<span class=\"string\">\"android.intent.category.DEFAULT\"</span> /&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">data</span> <span class=\"attr\">android:mimeType</span>=<span class=\"string\">\"image/*\"</span> /&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">intent-filter</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">activity</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>代码处理</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">onCreate</span> <span class=\"params\">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"comment\">// Get intent, action and MIME type</span></span><br><span class=\"line\">    Intent intent = getIntent();</span><br><span class=\"line\">    String action = intent.getAction();</span><br><span class=\"line\">    String type = intent.getType();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (Intent.ACTION_SEND.equals(action) &amp;&amp; type != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"string\">\"text/plain\"</span>.equals(type)) &#123;</span><br><span class=\"line\">            handleSendText(intent); <span class=\"comment\">// Handle text being sent</span></span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (type.startsWith(<span class=\"string\">\"image/\"</span>)) &#123;</span><br><span class=\"line\">            handleSendImage(intent); <span class=\"comment\">// Handle single image being sent</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (Intent.ACTION_SEND_MULTIPLE.equals(action) &amp;&amp; type != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (type.startsWith(<span class=\"string\">\"image/\"</span>)) &#123;</span><br><span class=\"line\">            handleSendMultipleImages(intent); <span class=\"comment\">// Handle multiple images being sent</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// Handle other intents, such as being started from the home screen</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">handleSendText</span><span class=\"params\">(Intent intent)</span> </span>&#123;</span><br><span class=\"line\">    String sharedText = intent.getStringExtra(Intent.EXTRA_TEXT);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (sharedText != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// Update UI to reflect text being shared</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">handleSendImage</span><span class=\"params\">(Intent intent)</span> </span>&#123;</span><br><span class=\"line\">    Uri imageUri = (Uri) intent.getParcelableExtra(Intent.EXTRA_STREAM);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (imageUri != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// Update UI to reflect image being shared</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">handleSendMultipleImages</span><span class=\"params\">(Intent intent)</span> </span>&#123;</span><br><span class=\"line\">    ArrayList&lt;Uri&gt; imageUris = intent.getParcelableArrayListExtra(Intent.EXTRA_STREAM);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (imageUris != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// Update UI to reflect multiple images being shared</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"大文件分享\"><a class=\"markdownIt-Anchor\" href=\"#大文件分享\"></a> 大文件分享</h3>\n<p>分享大文件方式和分享文本和流相似，只不过它不发数据过去，传个引用过去。发的其实不是文件，是文件的URI。“服务端”app把数据分享给其他“客户端”app总共分三步：<br>\n一、生成文件的content URI。<br>\n二、授予URI的临时访问权限。<br>\n三、将URI发送给接收文件的应用程序。<br>\n“客户端”app要拿到这个文件，总共有两步：<br>\n一、发起请求。拿到URI。<br>\n二、通过URI拿到FileDescriptor，开始处理文件。</p>\n<blockquote>\n<p>这一过程中没有文件的安全问题，因为客户端应用程序所收到的所有数据只有文件的Content URI而已。由于URI不包含目录路径信息，客户端应用程序无法查询或打开任何服务端应用程序的其他文件。客户端应用程序仅仅获取了这个文件的访问渠道以及由服务端应用程序授予的访问权限。同时访问权限是临时的，一旦这个客户端应用的任务栈结束了，这个文件将无法再被除服务端应用程序之外的其他应用程序访问。</p>\n</blockquote>\n<h3 id=\"nfc传文件\"><a class=\"markdownIt-Anchor\" href=\"#nfc传文件\"></a> NFC传文件</h3>\n<blockquote>\n<ul>\n<li>Android 4.1（API Level 16）及以上版本的Android系统中使用。</li>\n<li>文件必须放置于外部存储。</li>\n<li>文件必须是全局可读的。我们可以通过File.setReadable(true,false)来为文件设置相应的读权限。</li>\n</ul>\n</blockquote>\n<h2 id=\"android多媒体\"><a class=\"markdownIt-Anchor\" href=\"#android多媒体\"></a> Android多媒体</h2>\n<h3 id=\"音频播放\"><a class=\"markdownIt-Anchor\" href=\"#音频播放\"></a> 音频播放</h3>\n<p>Android为播放音乐，闹铃，通知铃，来电声音，系统声音，打电话声音与拨号声音分别维护了一个独立的音频流。音频操作在AudioManger中进行。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">AudioManager am = (AudioManager)activity.getSystemService(Context.AUDIO_SERVICE);</span><br><span class=\"line\">setVolumeControlStream(AudioManager.STREAM_MUSIC);</span><br></pre></td></tr></table></figure>\n<p>为了防止多个音乐播放应用同时播放音频，Android使用音频焦点（Audio Focus）来控制音频的播放——即只有获取到音频焦点的应用才能够播放音频。requestAudioFocus()方法可以获取我们希望得到的音频流焦点。</p>\n<p>短暂的焦点锁定：当计划播放一个短暂的音频时使用（比如播放导航指示）。<br>\n永久的焦点锁定：当计划播放一个较长但时长可预期的音频时使用（比如播放音乐）。</p>\n"},{"title":"chapter-01-getting-started","catalog":true,"date":"2016-02-22T09:21:29.000Z","header-img":"/img/06.jpg","_content":"\n# chapter-01-getting-started\n\nTags: Training-for-Android-developers\n\n---\n\n这是一个读 google的 android 教程的整理。仅以记录，不求误人。卽此而已。\n\n### 关于 IDE\n欲善其事必利其器，在工具的对比和选择时间耗费整整用了一天。不过仍有磨刀不费砍柴功的感觉。直接上结论。\n\n>*  eclipse pass ,其因不再赘述。\n>*  IDEA + android support插件，和 android studio 是相同的代码 compile 出来的，只不过移植要慢一些。由于之前长期使用 idea，在上面有很多种类已经在用的代码插件，目前以来用它通吃了 python\\scala\\java\\php。如果转到其他 IDE 势必会出现要使用两个 IDEA 的情况，不过在使用了一段时间 idea 打 android 插件的方式以后，发现对 android 开发的支持不太完备，用起来有些勉强。十分不情愿的放弃了它。 想说爱你不容易。\n>*  Android Studio 实际上是 IDEA的太监版，试着装了一些诸如 scala 语言的插件，几乎是不可用的。但是！我的目的现在是找一个好用的 IDE for Android。试了一下它的所有android 相关功能非常不错。更重要的是 google官方教程也使用的这款 IDE。\n>*    注（官网答复）： Android Studio and the Android plugin for IntelliJ IDEA are built from the same code, and all of the changes in Android Studio are, and will continue to be, available in IntelliJ IDEA releases.\n\n\n### gradle\nandroid 程序和 java 程序一样也需要编译好后打包发布。在 java   中早期使用的 ant 比较多。后期逐步由 maven 做了大部分工作。和 ant、maven 一样。gradle 是一种相对较新的打包发布工具。目前在 android 中应用较多。主要是 android studio 使它。其实就是 ant 的升级版，完全兼容 ant 同时可以使用 groovy 和 scala 一些 jvm 平台上的其他语言做为配置语言。比使用 XML 灵活一些（然并卵！谁没事天天配这东西）。类似于 scala 里的 sbt ， nodejs 里的 npm 。\n有人写了一本书还不错：\nhttps://dongchuan.gitbooks.io/gradle-user-guide-/content/index.html\n\n最后，感觉对于 android 新人，完全没必要在这个上面浪费太多时间。现学现卖足矣。\n\n---\n\n## Getting Started\n新建一个 android 工程。\n\nactivity ，一个 android 界面就是一个activity。它需要一个布局配置。如下：\n\n\n    app/src/main/res/layout/activity_my.xml\n\n全局描述文件：\n\n    app/src/main/AndroidManifest.xml\n    \ngradle 配置文件：\n\n    app/build.gradle\n\nvalues、layout、menu 目录：\n\n    values 目录常放一些数字和字符串的值，就是一些存值的配置。类似于 properties 文件。另外两个见名知义。\n\n### Activity及其四种状态\nActivity启动模式设置：\n\n        <activity android:name=\".MainActivity\" android:launchMode=\"standard\" />\n\nActivity的四种启动模式：\n\n    1. standard\n\n        默认启动模式，每次激活Activity时都会创建Activity，并放入任务栈中，永远不会调用onNewIntent()。\n\n    2. singleTop\n\n        如果在任务的栈顶正好存在该Activity的实例， 就重用该实例，并调用其onNewIntent()，否者就会创建新的实例并放入栈顶(即使栈中已经存在该Activity实例，只要不在栈顶，都会创建实例，而不会调用onNewIntent()，此时就跟standard模式一样)。\n\n    3. singleTask\n\n        如果在栈中已经有该Activity的实例，就重用该实例(会调用实例的onNewIntent())。重用时，会让该实例回到栈顶，因此在它上面的实例将会被移除栈。如果栈中不存在该实例，将会创建新的实例放入栈中（此时不会调用onNewIntent()）。 \n\n    4. singleInstance\n\n        在一个新栈中创建该Activity实例，并让多个应用共享改栈中的该Activity实例。一旦改模式的Activity的实例存在于某个栈中，任何应用再激活改Activity时都会重用该栈中的实例，其效果相当于多个应用程序共享一个应用，不管谁激活该Activity都会进入同一个应用中。\n\n    \n### 运行和Activity消息传递\n\n* Andoird中有 View 和 ViewGroup 的概念。View 就是可见的控件，按钮啥的。类似一些GUI里的 Component ， ViewGroup类似一些语言 GUI 里的 Panel。\n* ViewGroup 是 View 容器而已。为了不使这些 View 散乱和更易管理。把许多 View 放在 ViewGroup  中集中调整它的布局等属性。\n    \nwrap_content 根据控件文本等自适应大小。简单来讲：够用就得。\nmatch_parent 充满整个父容器边界。\n\n### 权重\n\n*The weight value is a number that specifies the amount of remaining space each view should consume, relative to the amount consumed by sibling views. This works kind of like the amount of ingredients in a drink recipe: \"2 parts soda, 1 part syrup\" means two-thirds of the drink is soda. For example, if you give one view a weight of 2 and another one a weight of 1, the sum is 3, so the first view fills 2/3 of the remaining space and the second view fills the rest. If you add a third view and give it a weight of 1, then the first view (with weight of 2) now gets 1/2 the remaining space, while the remaining two each get 1/4.*\n\n```\n    权重的值指的是每个部件所占剩余空间的大小，该值与同级部件所占空间大小有关。\n    就类似于饮料的成分配方：“两份伏特加酒，一份咖啡利口酒”，即该酒中伏特加酒占三分之二\n    。例如，我们设置一个View的权重是2，另一个View的权重是1，那么总数就是3，这时第一个View占据2/3的空间，第二个占据1/3的空间。如果你再加入第三个View，权重设为1，那么第一个View(权重为2的)会占据1/2的空间，剩余的另外两个View各占1/4。(请注意，使用权重的前提一般是给View的宽或者高的大小设置为0dp，然后系统根据上面的权重规则来计算View应该占据的空间。\n    但是很多情况下，如果给View设置了match_parent的属性，那么上面计算权重时则不是通常的正比，而是反比，也就是权重值大的反而占据空间小)。\n    对于所有的View默认的权重是0，如果只设置了一个View的权重大于0，则该View将占据除去别的View本身占据的空间的所有剩余空间。\n    因此这里设置EditText的权重为1，使其能够占据除了按钮之外的所有空间。\n    目前全中仅被用在LinearLayout中。\n```\n    \n**总结：权值PK，此消彼长。**\n\n### Activity 间传递及拉起\n\n两个界面 （Activity） 之间如果要传值或者一个拉起另一个的操作，都需要 Intent做为媒介（哪怕不传值，只是拉起下游 Activity 也要使用 Intet 源码中这里没有任何处理，只要你不传它就报 NPE）。Intent 特别类似于网络请求中的 Request 对象，如果服务端没接到 Request 对象，后面的业务也不会被拉起。同样的像 Request 一样，Intent 也可以做为信息传递的载体，putExtra方法和 Request 中的 setAttribute 一样。用 K->V 的方式存储信息。\n\n---\n\n## 适配\n```java\n//判断指定版本下才可以运行，柔性可用\nif (Build.VERSION.SDK_INT >= Build.VERSION_CODES.HONEYCOMB) {\n    ActionBar actionBar = getActionBar();\n    actionBar.setDisplayHomeAsUpEnabled(true);\n}\n```\n\n* 有4种普遍尺寸：小(small)，普通(normal)，大(large)，超大(xlarge)\n* 4种普遍分辨率：低精度(ldpi), 中精度(mdpi), 高精度(hdpi), 超高精度(xhdpi)\n\n**layout\\国际化(语言)\\图片 这些差别都是用目录来区分的。系统会根据设置或者默认拉起对应的配置。**\n\n\n## Activity 的生命周期\n\n \n![图1][1]\n\n上图显示：当用户离开我们的activity时，系统会调用onStop()来停止activity (1). 这个时候如果用户返回，系统会调用onRestart()(2), 之后会迅速调用onStart()(3)与onResume()(4). 请注意：无论什么原因导致activity停止，系统总是会在onStop()之前调用onPause()方法。\n\n* onResume: 初始化操作一般在这里做，onCreate 不要初始化太多东西，不然打开应用会很久看不到界面。\n* onStop: 当 activity 隐藏以后要执行的heavy-load操作一般会在 onStop 中。不要把heavy-load操作放到 onPasue 这样会影响界面切换速度。写 DB 建议在此方法中实现，任何heavy-load操作再生命周期中执行，要多考虑异步执行，否则容易引起主线程假死。\n\n几种会调用onDestroy的情况:\n\n>*  用户点击 back 按钮\n>*  程序里调用了 finish() 方法\n>*  资源紧张时（后台长期 stop 状态或者前台需要更多内存），系统可能会干掉它。系统在 destroy 时把现场存到一个 Bundle 对象中的键值对中(instance state)，当用户要回到这个 Activity 时，系统会重建一个 Activity 实例（此 Activity 已是物是人非，非彼 Activity!）\n>*  Activity 会在每次旋转屏幕时被 destroyed 与 recreated 。当屏幕改变方向时，系统会 Destory 与 Recreate 前台的 activity ，因为屏幕配置被改变，Activity 可能需要加载另一些替代的资源(例如layout)。为了让所有信息顺利\n\n\n![图2][2]\n\n**调用 onSaveInstanceState 的时机：**\nonSaveInstanceState()的调用遵循一个重要原则，即当系统存在“未经你许可”时销毁了我们的activity的**可能**时，则onSaveInstanceState()**可能**会被系统调用，这是系统的责任，因为它必须要提供一个机会让你保存你的数据（当然你不保存那就随便你了）。如果调用，调用将发生在onPause()之后、onStop()方法之前。注：如果你kill或者kill -9，系统都不会调用此方法，因为它没机会执行就被干掉了，做不到。\n　\n以下情况都仅仅是可能会触发该方法的，\n>* 用户按下HOME键时。\n>* 长按HOME键，选择运行其他的程序时。\n>* 按下电源按键（关闭屏幕显示）时。\n>* 从activity A中启动一个新的activity时。\n>* 屏幕方向切换时，例如从竖屏切换到横屏时。\n\n**调用 onRestoreInstanceState 的时机：**\n只有在Activity真的被系统非正常干掉过，恢复显示Activity的时候，才会调用onRestoreInstanceState。\n\n## Fragments\n\n![图3][3]\n\nFragment是为了activity的模块化而出现的概念，它拥有自己的生命周期，接收自己的输入事件，可以在acvitity运行过程中添加或者移除（有点像\"子activity\"，可以在不同的activity里面重复使用，当通过XML布局文件的方式将Fragment添加进activity时，Fragment是不能被动态移除的。如果想要在用户交互的时候把fragment切入与切出，必须在activity启动后，再将fragment添加进activity。）。\n\n![图4][4]\n\n* 为了执行fragment的增加或者移除操作，必须通过 FragmentManager 创建一个FragmentTransaction对象,FragmentTransaction提供了用来增加、移除、替换以及其它一些操作的APIs。\n\n* 如果我们的activity允许fragment移除或者替换，我们应该在activity的onCreate()方法中添加初始化fragment(s).\n\n* fragment其实只是一个虚拟的框，它里面不装东西它就什么也不是。所以必须有一个View把它撑起来（inflate）。\n```java\ninflater.inflate(R.layout.article_view, container, false);\n```\n\n移除或者替换Fragment，如果要适当地让用户可以向后导航与\"撤销\"这次改变。为了让用户向后导航fragment事务，我们必须在FragmentTransaction提交前调用addToBackStack()方法。（如果不加到栈顶，点返回键栈里没东西时，会直接返回到桌面）\n```java\ntransaction.addToBackStack(null);\n```\n  \n## 数据持久化\n为了能方便这里的实验，手机root以后。可以用以下两种方式查看系统文件：\n\n>* 手机连usb后将android sdk的platform加到PATH中，执行adb shell，su - root。就可以切到root下，为所欲为（君子有所为有所不为）。\n>* 也可以在手机端安装一个ssh server软件（如：SSHDriodPro）,启动服务，在确认软件拿到root权限同时pc和手机在相同网段后，pc上使用ssh root@[ip] -p [port]连上，再su - root。效果同上。\n\n### 保存到Preference\npreference有些类似cookie。每个Prefernece文件就是存一些k->v。\n\n* getSharedPreferences() 可以取多个带名文件，当文件不存在的时间，get时会自动创建。\n* getPreference() 不需要名，只取一个文件。 \n* 当写文件时，Preference的Editor对象要commit一下才会生效。\n\n> 当我们用root登录到手机上，cd /data/data/com.example.android.fragments/ (包名根据具体app配置决定)，之后我们能看到一个叫shared_prefs文件夹。\n进入这个文件夹后看到：MainActivity.xml和preference_file_key.xml。\n\n\n单个文件，无需指定文件名方式\n```xml\n<!--MainActivity.xml-->\n<?xml version='1.0' encoding='utf-8' standalone='yes' ?>\n<map>\n    <string name=\"preference\">preference1</string>\n</map>\n```\n自己指定文件名来存储\n```xml\n<!--preference_file_key.xml-->\n<?xml version='1.0' encoding='utf-8' standalone='yes' ?>\n<map>\n    <string name=\"sharedPref\">SharedPreferences1</string>\n</map>\n```\n再对比一下代码，司马昭之心路人皆知：***所谓的Preference就是一个xml文件而已***\n```java\npublic void saveData(){\n    SharedPreferences sharedPref = getSharedPreferences();\n    SharedPreferences preference = getPreference();\n    \n    if (sharedPref.getString(\"sharedPref\", null) == null) {\n        SharedPreferences.Editor editor = sharedPref.edit();\n        editor.putString(\"sharedPref\", \"SharedPreferences1\");\n        editor.commit();\n    }\n    \n    if (preference.getString(\"preference\", null) == null) {\n        SharedPreferences.Editor editor = preference.edit();\n        editor.putString(\"preference\", \"preference1\");\n        editor.commit();\n    }\n}\n\n/**\n * 获取preferences\n *\n * @return\n */\nprivate SharedPreferences getSharedPreferences() {\n    return getActivity().getSharedPreferences(getString(R.string.preference_file_key), Context.MODE_PRIVATE);\n}\n\n/**\n * 获取单个文件\n *\n * @return\n */\nprivate SharedPreferences getPreference() {\n    return getActivity().getPreferences(Context.MODE_PRIVATE);\n}\n```\n\n### 存文件\n\n也可以直接操作文件来读写，分为External和Internal两种文件操作。使用的API都是java操作文件IO的标准API。当写完文件以后，可以用adb在上面提到的shared_prefs同级目录中查看到一个files和caches目录分别存储用来存普通文件和临时文件。\n写文件不仅可以写到应用/data/data/package_name/files/下，还可以写到外部存储路径，即sdcard中。\n\n> 在写入文件时，目录是可以指定的。但是一般情况下的权限只能指定自己app所对应的目录。其他程序目录如果强制被chmod授权，当前程序也可以写到那个目录，或者当前程序拿到root权限也可随便写。\n\n### 写DB\n\nAndroid的自带DB规范是sqlite。操作和java中的一些操作DB方式基本相同。DB文件存在/data/data/[应用]/databases下。可以使用sqlite3命令查看。如果手机上没有安装，可以从模拟器中pull出来，再push到手机上。前提是手机得root。\n\n搞定以后直接sqlite3 xxx.db。然后sql语句就ok.\n\n> 在调试过程中，经常会有查询DB中的数据需要。除了命令行，也可以使用一个sqlite editor pro的软件。它可以帮你搜索整个手机中的DB数据，直观查看。\n\n查询\n```java\n//要查哪些列\nString[] projection = {\n        FeedReaderContract.FeedEntry._ID,\n        FeedReaderContract.FeedEntry.COLUMN_NAME_TITLE\n};\n//排序参数，也可以加各种where\nString sortOrder = FeedReaderContract.FeedEntry._ID + \" DESC\";\n//拿到游标\nCursor cursor = db.query(\n        FeedReaderContract.FeedEntry.TABLE_NAME,  // The table to query\n        projection,                               // The columns to return\n        null,                                // The columns for the WHERE clause\n        null,                            // The values for the WHERE clause\n        null,                                     // don't group the rows\n        null,                                     // don't filter by row groups\n        sortOrder                                 // The sort order\n);\n//移到头\ncursor.moveToFirst();\n//一般于用do while，判断isLast，然后moveToNext。相当于jdbc中的rs.next()。\ncursor.moveToNext();\n```\n写\n```java\nContentValues values = new ContentValues();\nvalues.put(FeedReaderContract.FeedEntry.COLUMN_NAME_ENTRY_ID, i);\nvalues.put(FeedReaderContract.FeedEntry.COLUMN_NAME_TITLE, \"title\" + i);\n\nlong newRowId = db.insert(FeedReaderContract.FeedEntry.TABLE_NAME, null, values);\n\nlist.add(newRowId);\n```\n删除\n```java\ndb.delete\n```\n更新\n```java\ndb.update\n```\n\n\n\n\n  [1]: http://developer.android.com/images/training/basics/basic-lifecycle-paused.png\n  [2]: http://developer.android.com/images/training/basics/basic-lifecycle-savestate.png\n  [3]: http://developer.android.com/images/fundamentals/fragments.png\n  [4]: http://developer.android.com/images/fragment_lifecycle.png\n","source":"_posts/chapter-01-getting-started.md","raw":"---\ntitle: 'chapter-01-getting-started'\ncatalog: true\ndate: 2016-02-22 17:21:29\nheader-img: \"/img/06.jpg\"\ntags: \"android\"\n---\n\n# chapter-01-getting-started\n\nTags: Training-for-Android-developers\n\n---\n\n这是一个读 google的 android 教程的整理。仅以记录，不求误人。卽此而已。\n\n### 关于 IDE\n欲善其事必利其器，在工具的对比和选择时间耗费整整用了一天。不过仍有磨刀不费砍柴功的感觉。直接上结论。\n\n>*  eclipse pass ,其因不再赘述。\n>*  IDEA + android support插件，和 android studio 是相同的代码 compile 出来的，只不过移植要慢一些。由于之前长期使用 idea，在上面有很多种类已经在用的代码插件，目前以来用它通吃了 python\\scala\\java\\php。如果转到其他 IDE 势必会出现要使用两个 IDEA 的情况，不过在使用了一段时间 idea 打 android 插件的方式以后，发现对 android 开发的支持不太完备，用起来有些勉强。十分不情愿的放弃了它。 想说爱你不容易。\n>*  Android Studio 实际上是 IDEA的太监版，试着装了一些诸如 scala 语言的插件，几乎是不可用的。但是！我的目的现在是找一个好用的 IDE for Android。试了一下它的所有android 相关功能非常不错。更重要的是 google官方教程也使用的这款 IDE。\n>*    注（官网答复）： Android Studio and the Android plugin for IntelliJ IDEA are built from the same code, and all of the changes in Android Studio are, and will continue to be, available in IntelliJ IDEA releases.\n\n\n### gradle\nandroid 程序和 java 程序一样也需要编译好后打包发布。在 java   中早期使用的 ant 比较多。后期逐步由 maven 做了大部分工作。和 ant、maven 一样。gradle 是一种相对较新的打包发布工具。目前在 android 中应用较多。主要是 android studio 使它。其实就是 ant 的升级版，完全兼容 ant 同时可以使用 groovy 和 scala 一些 jvm 平台上的其他语言做为配置语言。比使用 XML 灵活一些（然并卵！谁没事天天配这东西）。类似于 scala 里的 sbt ， nodejs 里的 npm 。\n有人写了一本书还不错：\nhttps://dongchuan.gitbooks.io/gradle-user-guide-/content/index.html\n\n最后，感觉对于 android 新人，完全没必要在这个上面浪费太多时间。现学现卖足矣。\n\n---\n\n## Getting Started\n新建一个 android 工程。\n\nactivity ，一个 android 界面就是一个activity。它需要一个布局配置。如下：\n\n\n    app/src/main/res/layout/activity_my.xml\n\n全局描述文件：\n\n    app/src/main/AndroidManifest.xml\n    \ngradle 配置文件：\n\n    app/build.gradle\n\nvalues、layout、menu 目录：\n\n    values 目录常放一些数字和字符串的值，就是一些存值的配置。类似于 properties 文件。另外两个见名知义。\n\n### Activity及其四种状态\nActivity启动模式设置：\n\n        <activity android:name=\".MainActivity\" android:launchMode=\"standard\" />\n\nActivity的四种启动模式：\n\n    1. standard\n\n        默认启动模式，每次激活Activity时都会创建Activity，并放入任务栈中，永远不会调用onNewIntent()。\n\n    2. singleTop\n\n        如果在任务的栈顶正好存在该Activity的实例， 就重用该实例，并调用其onNewIntent()，否者就会创建新的实例并放入栈顶(即使栈中已经存在该Activity实例，只要不在栈顶，都会创建实例，而不会调用onNewIntent()，此时就跟standard模式一样)。\n\n    3. singleTask\n\n        如果在栈中已经有该Activity的实例，就重用该实例(会调用实例的onNewIntent())。重用时，会让该实例回到栈顶，因此在它上面的实例将会被移除栈。如果栈中不存在该实例，将会创建新的实例放入栈中（此时不会调用onNewIntent()）。 \n\n    4. singleInstance\n\n        在一个新栈中创建该Activity实例，并让多个应用共享改栈中的该Activity实例。一旦改模式的Activity的实例存在于某个栈中，任何应用再激活改Activity时都会重用该栈中的实例，其效果相当于多个应用程序共享一个应用，不管谁激活该Activity都会进入同一个应用中。\n\n    \n### 运行和Activity消息传递\n\n* Andoird中有 View 和 ViewGroup 的概念。View 就是可见的控件，按钮啥的。类似一些GUI里的 Component ， ViewGroup类似一些语言 GUI 里的 Panel。\n* ViewGroup 是 View 容器而已。为了不使这些 View 散乱和更易管理。把许多 View 放在 ViewGroup  中集中调整它的布局等属性。\n    \nwrap_content 根据控件文本等自适应大小。简单来讲：够用就得。\nmatch_parent 充满整个父容器边界。\n\n### 权重\n\n*The weight value is a number that specifies the amount of remaining space each view should consume, relative to the amount consumed by sibling views. This works kind of like the amount of ingredients in a drink recipe: \"2 parts soda, 1 part syrup\" means two-thirds of the drink is soda. For example, if you give one view a weight of 2 and another one a weight of 1, the sum is 3, so the first view fills 2/3 of the remaining space and the second view fills the rest. If you add a third view and give it a weight of 1, then the first view (with weight of 2) now gets 1/2 the remaining space, while the remaining two each get 1/4.*\n\n```\n    权重的值指的是每个部件所占剩余空间的大小，该值与同级部件所占空间大小有关。\n    就类似于饮料的成分配方：“两份伏特加酒，一份咖啡利口酒”，即该酒中伏特加酒占三分之二\n    。例如，我们设置一个View的权重是2，另一个View的权重是1，那么总数就是3，这时第一个View占据2/3的空间，第二个占据1/3的空间。如果你再加入第三个View，权重设为1，那么第一个View(权重为2的)会占据1/2的空间，剩余的另外两个View各占1/4。(请注意，使用权重的前提一般是给View的宽或者高的大小设置为0dp，然后系统根据上面的权重规则来计算View应该占据的空间。\n    但是很多情况下，如果给View设置了match_parent的属性，那么上面计算权重时则不是通常的正比，而是反比，也就是权重值大的反而占据空间小)。\n    对于所有的View默认的权重是0，如果只设置了一个View的权重大于0，则该View将占据除去别的View本身占据的空间的所有剩余空间。\n    因此这里设置EditText的权重为1，使其能够占据除了按钮之外的所有空间。\n    目前全中仅被用在LinearLayout中。\n```\n    \n**总结：权值PK，此消彼长。**\n\n### Activity 间传递及拉起\n\n两个界面 （Activity） 之间如果要传值或者一个拉起另一个的操作，都需要 Intent做为媒介（哪怕不传值，只是拉起下游 Activity 也要使用 Intet 源码中这里没有任何处理，只要你不传它就报 NPE）。Intent 特别类似于网络请求中的 Request 对象，如果服务端没接到 Request 对象，后面的业务也不会被拉起。同样的像 Request 一样，Intent 也可以做为信息传递的载体，putExtra方法和 Request 中的 setAttribute 一样。用 K->V 的方式存储信息。\n\n---\n\n## 适配\n```java\n//判断指定版本下才可以运行，柔性可用\nif (Build.VERSION.SDK_INT >= Build.VERSION_CODES.HONEYCOMB) {\n    ActionBar actionBar = getActionBar();\n    actionBar.setDisplayHomeAsUpEnabled(true);\n}\n```\n\n* 有4种普遍尺寸：小(small)，普通(normal)，大(large)，超大(xlarge)\n* 4种普遍分辨率：低精度(ldpi), 中精度(mdpi), 高精度(hdpi), 超高精度(xhdpi)\n\n**layout\\国际化(语言)\\图片 这些差别都是用目录来区分的。系统会根据设置或者默认拉起对应的配置。**\n\n\n## Activity 的生命周期\n\n \n![图1][1]\n\n上图显示：当用户离开我们的activity时，系统会调用onStop()来停止activity (1). 这个时候如果用户返回，系统会调用onRestart()(2), 之后会迅速调用onStart()(3)与onResume()(4). 请注意：无论什么原因导致activity停止，系统总是会在onStop()之前调用onPause()方法。\n\n* onResume: 初始化操作一般在这里做，onCreate 不要初始化太多东西，不然打开应用会很久看不到界面。\n* onStop: 当 activity 隐藏以后要执行的heavy-load操作一般会在 onStop 中。不要把heavy-load操作放到 onPasue 这样会影响界面切换速度。写 DB 建议在此方法中实现，任何heavy-load操作再生命周期中执行，要多考虑异步执行，否则容易引起主线程假死。\n\n几种会调用onDestroy的情况:\n\n>*  用户点击 back 按钮\n>*  程序里调用了 finish() 方法\n>*  资源紧张时（后台长期 stop 状态或者前台需要更多内存），系统可能会干掉它。系统在 destroy 时把现场存到一个 Bundle 对象中的键值对中(instance state)，当用户要回到这个 Activity 时，系统会重建一个 Activity 实例（此 Activity 已是物是人非，非彼 Activity!）\n>*  Activity 会在每次旋转屏幕时被 destroyed 与 recreated 。当屏幕改变方向时，系统会 Destory 与 Recreate 前台的 activity ，因为屏幕配置被改变，Activity 可能需要加载另一些替代的资源(例如layout)。为了让所有信息顺利\n\n\n![图2][2]\n\n**调用 onSaveInstanceState 的时机：**\nonSaveInstanceState()的调用遵循一个重要原则，即当系统存在“未经你许可”时销毁了我们的activity的**可能**时，则onSaveInstanceState()**可能**会被系统调用，这是系统的责任，因为它必须要提供一个机会让你保存你的数据（当然你不保存那就随便你了）。如果调用，调用将发生在onPause()之后、onStop()方法之前。注：如果你kill或者kill -9，系统都不会调用此方法，因为它没机会执行就被干掉了，做不到。\n　\n以下情况都仅仅是可能会触发该方法的，\n>* 用户按下HOME键时。\n>* 长按HOME键，选择运行其他的程序时。\n>* 按下电源按键（关闭屏幕显示）时。\n>* 从activity A中启动一个新的activity时。\n>* 屏幕方向切换时，例如从竖屏切换到横屏时。\n\n**调用 onRestoreInstanceState 的时机：**\n只有在Activity真的被系统非正常干掉过，恢复显示Activity的时候，才会调用onRestoreInstanceState。\n\n## Fragments\n\n![图3][3]\n\nFragment是为了activity的模块化而出现的概念，它拥有自己的生命周期，接收自己的输入事件，可以在acvitity运行过程中添加或者移除（有点像\"子activity\"，可以在不同的activity里面重复使用，当通过XML布局文件的方式将Fragment添加进activity时，Fragment是不能被动态移除的。如果想要在用户交互的时候把fragment切入与切出，必须在activity启动后，再将fragment添加进activity。）。\n\n![图4][4]\n\n* 为了执行fragment的增加或者移除操作，必须通过 FragmentManager 创建一个FragmentTransaction对象,FragmentTransaction提供了用来增加、移除、替换以及其它一些操作的APIs。\n\n* 如果我们的activity允许fragment移除或者替换，我们应该在activity的onCreate()方法中添加初始化fragment(s).\n\n* fragment其实只是一个虚拟的框，它里面不装东西它就什么也不是。所以必须有一个View把它撑起来（inflate）。\n```java\ninflater.inflate(R.layout.article_view, container, false);\n```\n\n移除或者替换Fragment，如果要适当地让用户可以向后导航与\"撤销\"这次改变。为了让用户向后导航fragment事务，我们必须在FragmentTransaction提交前调用addToBackStack()方法。（如果不加到栈顶，点返回键栈里没东西时，会直接返回到桌面）\n```java\ntransaction.addToBackStack(null);\n```\n  \n## 数据持久化\n为了能方便这里的实验，手机root以后。可以用以下两种方式查看系统文件：\n\n>* 手机连usb后将android sdk的platform加到PATH中，执行adb shell，su - root。就可以切到root下，为所欲为（君子有所为有所不为）。\n>* 也可以在手机端安装一个ssh server软件（如：SSHDriodPro）,启动服务，在确认软件拿到root权限同时pc和手机在相同网段后，pc上使用ssh root@[ip] -p [port]连上，再su - root。效果同上。\n\n### 保存到Preference\npreference有些类似cookie。每个Prefernece文件就是存一些k->v。\n\n* getSharedPreferences() 可以取多个带名文件，当文件不存在的时间，get时会自动创建。\n* getPreference() 不需要名，只取一个文件。 \n* 当写文件时，Preference的Editor对象要commit一下才会生效。\n\n> 当我们用root登录到手机上，cd /data/data/com.example.android.fragments/ (包名根据具体app配置决定)，之后我们能看到一个叫shared_prefs文件夹。\n进入这个文件夹后看到：MainActivity.xml和preference_file_key.xml。\n\n\n单个文件，无需指定文件名方式\n```xml\n<!--MainActivity.xml-->\n<?xml version='1.0' encoding='utf-8' standalone='yes' ?>\n<map>\n    <string name=\"preference\">preference1</string>\n</map>\n```\n自己指定文件名来存储\n```xml\n<!--preference_file_key.xml-->\n<?xml version='1.0' encoding='utf-8' standalone='yes' ?>\n<map>\n    <string name=\"sharedPref\">SharedPreferences1</string>\n</map>\n```\n再对比一下代码，司马昭之心路人皆知：***所谓的Preference就是一个xml文件而已***\n```java\npublic void saveData(){\n    SharedPreferences sharedPref = getSharedPreferences();\n    SharedPreferences preference = getPreference();\n    \n    if (sharedPref.getString(\"sharedPref\", null) == null) {\n        SharedPreferences.Editor editor = sharedPref.edit();\n        editor.putString(\"sharedPref\", \"SharedPreferences1\");\n        editor.commit();\n    }\n    \n    if (preference.getString(\"preference\", null) == null) {\n        SharedPreferences.Editor editor = preference.edit();\n        editor.putString(\"preference\", \"preference1\");\n        editor.commit();\n    }\n}\n\n/**\n * 获取preferences\n *\n * @return\n */\nprivate SharedPreferences getSharedPreferences() {\n    return getActivity().getSharedPreferences(getString(R.string.preference_file_key), Context.MODE_PRIVATE);\n}\n\n/**\n * 获取单个文件\n *\n * @return\n */\nprivate SharedPreferences getPreference() {\n    return getActivity().getPreferences(Context.MODE_PRIVATE);\n}\n```\n\n### 存文件\n\n也可以直接操作文件来读写，分为External和Internal两种文件操作。使用的API都是java操作文件IO的标准API。当写完文件以后，可以用adb在上面提到的shared_prefs同级目录中查看到一个files和caches目录分别存储用来存普通文件和临时文件。\n写文件不仅可以写到应用/data/data/package_name/files/下，还可以写到外部存储路径，即sdcard中。\n\n> 在写入文件时，目录是可以指定的。但是一般情况下的权限只能指定自己app所对应的目录。其他程序目录如果强制被chmod授权，当前程序也可以写到那个目录，或者当前程序拿到root权限也可随便写。\n\n### 写DB\n\nAndroid的自带DB规范是sqlite。操作和java中的一些操作DB方式基本相同。DB文件存在/data/data/[应用]/databases下。可以使用sqlite3命令查看。如果手机上没有安装，可以从模拟器中pull出来，再push到手机上。前提是手机得root。\n\n搞定以后直接sqlite3 xxx.db。然后sql语句就ok.\n\n> 在调试过程中，经常会有查询DB中的数据需要。除了命令行，也可以使用一个sqlite editor pro的软件。它可以帮你搜索整个手机中的DB数据，直观查看。\n\n查询\n```java\n//要查哪些列\nString[] projection = {\n        FeedReaderContract.FeedEntry._ID,\n        FeedReaderContract.FeedEntry.COLUMN_NAME_TITLE\n};\n//排序参数，也可以加各种where\nString sortOrder = FeedReaderContract.FeedEntry._ID + \" DESC\";\n//拿到游标\nCursor cursor = db.query(\n        FeedReaderContract.FeedEntry.TABLE_NAME,  // The table to query\n        projection,                               // The columns to return\n        null,                                // The columns for the WHERE clause\n        null,                            // The values for the WHERE clause\n        null,                                     // don't group the rows\n        null,                                     // don't filter by row groups\n        sortOrder                                 // The sort order\n);\n//移到头\ncursor.moveToFirst();\n//一般于用do while，判断isLast，然后moveToNext。相当于jdbc中的rs.next()。\ncursor.moveToNext();\n```\n写\n```java\nContentValues values = new ContentValues();\nvalues.put(FeedReaderContract.FeedEntry.COLUMN_NAME_ENTRY_ID, i);\nvalues.put(FeedReaderContract.FeedEntry.COLUMN_NAME_TITLE, \"title\" + i);\n\nlong newRowId = db.insert(FeedReaderContract.FeedEntry.TABLE_NAME, null, values);\n\nlist.add(newRowId);\n```\n删除\n```java\ndb.delete\n```\n更新\n```java\ndb.update\n```\n\n\n\n\n  [1]: http://developer.android.com/images/training/basics/basic-lifecycle-paused.png\n  [2]: http://developer.android.com/images/training/basics/basic-lifecycle-savestate.png\n  [3]: http://developer.android.com/images/fundamentals/fragments.png\n  [4]: http://developer.android.com/images/fragment_lifecycle.png\n","slug":"chapter-01-getting-started","published":1,"updated":"2017-11-25T06:38:21.371Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjahvvnxv000qpv4ndsb3etut","content":"<h1><span id=\"chapter-01-getting-started\"> chapter-01-getting-started</span></h1>\n<p>Tags: Training-for-Android-developers</p>\n<hr>\n<p>这是一个读 google的 android 教程的整理。仅以记录，不求误人。卽此而已。</p>\n<h3><span id=\"关于-ide\"> 关于 IDE</span></h3>\n<p>欲善其事必利其器，在工具的对比和选择时间耗费整整用了一天。不过仍有磨刀不费砍柴功的感觉。直接上结论。</p>\n<blockquote>\n<ul>\n<li>eclipse pass ,其因不再赘述。</li>\n<li>IDEA + android support插件，和 android studio 是相同的代码 compile 出来的，只不过移植要慢一些。由于之前长期使用 idea，在上面有很多种类已经在用的代码插件，目前以来用它通吃了 python\\scala\\java\\php。如果转到其他 IDE 势必会出现要使用两个 IDEA 的情况，不过在使用了一段时间 idea 打 android 插件的方式以后，发现对 android 开发的支持不太完备，用起来有些勉强。十分不情愿的放弃了它。 想说爱你不容易。</li>\n<li>Android Studio 实际上是 IDEA的太监版，试着装了一些诸如 scala 语言的插件，几乎是不可用的。但是！我的目的现在是找一个好用的 IDE for Android。试了一下它的所有android 相关功能非常不错。更重要的是 google官方教程也使用的这款 IDE。</li>\n<li>注（官网答复）： Android Studio and the Android plugin for IntelliJ IDEA are built from the same code, and all of the changes in Android Studio are, and will continue to be, available in IntelliJ IDEA releases.</li>\n</ul>\n</blockquote>\n<h3><span id=\"gradle\"> gradle</span></h3>\n<p>android 程序和 java 程序一样也需要编译好后打包发布。在 java   中早期使用的 ant 比较多。后期逐步由 maven 做了大部分工作。和 ant、maven 一样。gradle 是一种相对较新的打包发布工具。目前在 android 中应用较多。主要是 android studio 使它。其实就是 ant 的升级版，完全兼容 ant 同时可以使用 groovy 和 scala 一些 jvm 平台上的其他语言做为配置语言。比使用 XML 灵活一些（然并卵！谁没事天天配这东西）。类似于 scala 里的 sbt ， nodejs 里的 npm 。<br>\n有人写了一本书还不错：<br>\n<a href=\"https://dongchuan.gitbooks.io/gradle-user-guide-/content/index.html\" target=\"_blank\" rel=\"noopener\">https://dongchuan.gitbooks.io/gradle-user-guide-/content/index.html</a></p>\n<p>最后，感觉对于 android 新人，完全没必要在这个上面浪费太多时间。现学现卖足矣。</p>\n<hr>\n<h2><span id=\"getting-started\"> Getting Started</span></h2>\n<p>新建一个 android 工程。</p>\n<p>activity ，一个 android 界面就是一个activity。它需要一个布局配置。如下：</p>\n<pre><code>app/src/main/res/layout/activity_my.xml\n</code></pre>\n<p>全局描述文件：</p>\n<pre><code>app/src/main/AndroidManifest.xml\n</code></pre>\n<p>gradle 配置文件：</p>\n<pre><code>app/build.gradle\n</code></pre>\n<p>values、layout、menu 目录：</p>\n<pre><code>values 目录常放一些数字和字符串的值，就是一些存值的配置。类似于 properties 文件。另外两个见名知义。\n</code></pre>\n<h3><span id=\"activity及其四种状态\"> Activity及其四种状态</span></h3>\n<p>Activity启动模式设置：</p>\n<pre><code>    &lt;activity android:name=&quot;.MainActivity&quot; android:launchMode=&quot;standard&quot; /&gt;\n</code></pre>\n<p>Activity的四种启动模式：</p>\n<pre><code>1. standard\n\n    默认启动模式，每次激活Activity时都会创建Activity，并放入任务栈中，永远不会调用onNewIntent()。\n\n2. singleTop\n\n    如果在任务的栈顶正好存在该Activity的实例， 就重用该实例，并调用其onNewIntent()，否者就会创建新的实例并放入栈顶(即使栈中已经存在该Activity实例，只要不在栈顶，都会创建实例，而不会调用onNewIntent()，此时就跟standard模式一样)。\n\n3. singleTask\n\n    如果在栈中已经有该Activity的实例，就重用该实例(会调用实例的onNewIntent())。重用时，会让该实例回到栈顶，因此在它上面的实例将会被移除栈。如果栈中不存在该实例，将会创建新的实例放入栈中（此时不会调用onNewIntent()）。 \n\n4. singleInstance\n\n    在一个新栈中创建该Activity实例，并让多个应用共享改栈中的该Activity实例。一旦改模式的Activity的实例存在于某个栈中，任何应用再激活改Activity时都会重用该栈中的实例，其效果相当于多个应用程序共享一个应用，不管谁激活该Activity都会进入同一个应用中。\n</code></pre>\n<h3><span id=\"运行和activity消息传递\"> 运行和Activity消息传递</span></h3>\n<ul>\n<li>Andoird中有 View 和 ViewGroup 的概念。View 就是可见的控件，按钮啥的。类似一些GUI里的 Component ， ViewGroup类似一些语言 GUI 里的 Panel。</li>\n<li>ViewGroup 是 View 容器而已。为了不使这些 View 散乱和更易管理。把许多 View 放在 ViewGroup  中集中调整它的布局等属性。</li>\n</ul>\n<p>wrap_content 根据控件文本等自适应大小。简单来讲：够用就得。<br>\nmatch_parent 充满整个父容器边界。</p>\n<h3><span id=\"权重\"> 权重</span></h3>\n<p><em>The weight value is a number that specifies the amount of remaining space each view should consume, relative to the amount consumed by sibling views. This works kind of like the amount of ingredients in a drink recipe: “2 parts soda, 1 part syrup” means two-thirds of the drink is soda. For example, if you give one view a weight of 2 and another one a weight of 1, the sum is 3, so the first view fills 2/3 of the remaining space and the second view fills the rest. If you add a third view and give it a weight of 1, then the first view (with weight of 2) now gets 1/2 the remaining space, while the remaining two each get 1/4.</em></p>\n<figure class=\"highlight lsl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">权重的值指的是每个部件所占剩余空间的大小，该值与同级部件所占空间大小有关。</span><br><span class=\"line\">就类似于饮料的成分配方：“两份伏特加酒，一份咖啡利口酒”，即该酒中伏特加酒占三分之二</span><br><span class=\"line\">。例如，我们设置一个View的权重是<span class=\"number\">2</span>，另一个View的权重是<span class=\"number\">1</span>，那么总数就是<span class=\"number\">3</span>，这时第一个View占据<span class=\"number\">2</span>/<span class=\"number\">3</span>的空间，第二个占据<span class=\"number\">1</span>/<span class=\"number\">3</span>的空间。如果你再加入第三个View，权重设为<span class=\"number\">1</span>，那么第一个View(权重为<span class=\"number\">2</span>的)会占据<span class=\"number\">1</span>/<span class=\"number\">2</span>的空间，剩余的另外两个View各占<span class=\"number\">1</span>/<span class=\"number\">4</span>。(请注意，使用权重的前提一般是给View的宽或者高的大小设置为<span class=\"number\">0</span>dp，然后系统根据上面的权重规则来计算View应该占据的空间。</span><br><span class=\"line\">但是很多情况下，如果给View设置了match_parent的属性，那么上面计算权重时则不是通常的正比，而是反比，也就是权重值大的反而占据空间小)。</span><br><span class=\"line\">对于所有的View默认的权重是<span class=\"number\">0</span>，如果只设置了一个View的权重大于<span class=\"number\">0</span>，则该View将占据除去别的View本身占据的空间的所有剩余空间。</span><br><span class=\"line\">因此这里设置EditText的权重为<span class=\"number\">1</span>，使其能够占据除了按钮之外的所有空间。</span><br><span class=\"line\">目前全中仅被用在LinearLayout中。</span><br></pre></td></tr></table></figure>\n<p><strong>总结：权值PK，此消彼长。</strong></p>\n<h3><span id=\"activity-间传递及拉起\"> Activity 间传递及拉起</span></h3>\n<p>两个界面 （Activity） 之间如果要传值或者一个拉起另一个的操作，都需要 Intent做为媒介（哪怕不传值，只是拉起下游 Activity 也要使用 Intet 源码中这里没有任何处理，只要你不传它就报 NPE）。Intent 特别类似于网络请求中的 Request 对象，如果服务端没接到 Request 对象，后面的业务也不会被拉起。同样的像 Request 一样，Intent 也可以做为信息传递的载体，putExtra方法和 Request 中的 setAttribute 一样。用 K-&gt;V 的方式存储信息。</p>\n<hr>\n<h2><span id=\"适配\"> 适配</span></h2>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//判断指定版本下才可以运行，柔性可用</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.HONEYCOMB) &#123;</span><br><span class=\"line\">    ActionBar actionBar = getActionBar();</span><br><span class=\"line\">    actionBar.setDisplayHomeAsUpEnabled(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>有4种普遍尺寸：小(small)，普通(normal)，大(large)，超大(xlarge)</li>\n<li>4种普遍分辨率：低精度(ldpi), 中精度(mdpi), 高精度(hdpi), 超高精度(xhdpi)</li>\n</ul>\n<p><strong>layout\\国际化(语言)\\图片 这些差别都是用目录来区分的。系统会根据设置或者默认拉起对应的配置。</strong></p>\n<h2><span id=\"activity-的生命周期\"> Activity 的生命周期</span></h2>\n<p><img src=\"http://developer.android.com/images/training/basics/basic-lifecycle-paused.png\" alt=\"图1\"></p>\n<p>上图显示：当用户离开我们的activity时，系统会调用onStop()来停止activity (1). 这个时候如果用户返回，系统会调用onRestart()(2), 之后会迅速调用onStart()(3)与onResume()(4). 请注意：无论什么原因导致activity停止，系统总是会在onStop()之前调用onPause()方法。</p>\n<ul>\n<li>onResume: 初始化操作一般在这里做，onCreate 不要初始化太多东西，不然打开应用会很久看不到界面。</li>\n<li>onStop: 当 activity 隐藏以后要执行的heavy-load操作一般会在 onStop 中。不要把heavy-load操作放到 onPasue 这样会影响界面切换速度。写 DB 建议在此方法中实现，任何heavy-load操作再生命周期中执行，要多考虑异步执行，否则容易引起主线程假死。</li>\n</ul>\n<p>几种会调用onDestroy的情况:</p>\n<blockquote>\n<ul>\n<li>用户点击 back 按钮</li>\n<li>程序里调用了 finish() 方法</li>\n<li>资源紧张时（后台长期 stop 状态或者前台需要更多内存），系统可能会干掉它。系统在 destroy 时把现场存到一个 Bundle 对象中的键值对中(instance state)，当用户要回到这个 Activity 时，系统会重建一个 Activity 实例（此 Activity 已是物是人非，非彼 Activity!）</li>\n<li>Activity 会在每次旋转屏幕时被 destroyed 与 recreated 。当屏幕改变方向时，系统会 Destory 与 Recreate 前台的 activity ，因为屏幕配置被改变，Activity 可能需要加载另一些替代的资源(例如layout)。为了让所有信息顺利</li>\n</ul>\n</blockquote>\n<p><img src=\"http://developer.android.com/images/training/basics/basic-lifecycle-savestate.png\" alt=\"图2\"></p>\n<p><strong>调用 onSaveInstanceState 的时机：</strong><br>\nonSaveInstanceState()的调用遵循一个重要原则，即当系统存在“未经你许可”时销毁了我们的activity的<strong>可能</strong>时，则onSaveInstanceState()<strong>可能</strong>会被系统调用，这是系统的责任，因为它必须要提供一个机会让你保存你的数据（当然你不保存那就随便你了）。如果调用，调用将发生在onPause()之后、onStop()方法之前。注：如果你kill或者kill -9，系统都不会调用此方法，因为它没机会执行就被干掉了，做不到。<br>\n　<br>\n以下情况都仅仅是可能会触发该方法的，</p>\n<blockquote>\n<ul>\n<li>用户按下HOME键时。</li>\n<li>长按HOME键，选择运行其他的程序时。</li>\n<li>按下电源按键（关闭屏幕显示）时。</li>\n<li>从activity A中启动一个新的activity时。</li>\n<li>屏幕方向切换时，例如从竖屏切换到横屏时。</li>\n</ul>\n</blockquote>\n<p><strong>调用 onRestoreInstanceState 的时机：</strong><br>\n只有在Activity真的被系统非正常干掉过，恢复显示Activity的时候，才会调用onRestoreInstanceState。</p>\n<h2><span id=\"fragments\"> Fragments</span></h2>\n<p><img src=\"http://developer.android.com/images/fundamentals/fragments.png\" alt=\"图3\"></p>\n<p>Fragment是为了activity的模块化而出现的概念，它拥有自己的生命周期，接收自己的输入事件，可以在acvitity运行过程中添加或者移除（有点像&quot;子activity&quot;，可以在不同的activity里面重复使用，当通过XML布局文件的方式将Fragment添加进activity时，Fragment是不能被动态移除的。如果想要在用户交互的时候把fragment切入与切出，必须在activity启动后，再将fragment添加进activity。）。</p>\n<p><img src=\"http://developer.android.com/images/fragment_lifecycle.png\" alt=\"图4\"></p>\n<ul>\n<li>\n<p>为了执行fragment的增加或者移除操作，必须通过 FragmentManager 创建一个FragmentTransaction对象,FragmentTransaction提供了用来增加、移除、替换以及其它一些操作的APIs。</p>\n</li>\n<li>\n<p>如果我们的activity允许fragment移除或者替换，我们应该在activity的onCreate()方法中添加初始化fragment(s).</p>\n</li>\n<li>\n<p>fragment其实只是一个虚拟的框，它里面不装东西它就什么也不是。所以必须有一个View把它撑起来（inflate）。</p>\n</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">inflater.inflate(R.layout.article_view, container, <span class=\"keyword\">false</span>);</span><br></pre></td></tr></table></figure>\n<p>移除或者替换Fragment，如果要适当地让用户可以向后导航与&quot;撤销&quot;这次改变。为了让用户向后导航fragment事务，我们必须在FragmentTransaction提交前调用addToBackStack()方法。（如果不加到栈顶，点返回键栈里没东西时，会直接返回到桌面）</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">transaction.addToBackStack(<span class=\"keyword\">null</span>);</span><br></pre></td></tr></table></figure>\n<h2><span id=\"数据持久化\"> 数据持久化</span></h2>\n<p>为了能方便这里的实验，手机root以后。可以用以下两种方式查看系统文件：</p>\n<blockquote>\n<ul>\n<li>手机连usb后将android sdk的platform加到PATH中，执行adb shell，su - root。就可以切到root下，为所欲为（君子有所为有所不为）。</li>\n<li>也可以在手机端安装一个ssh server软件（如：SSHDriodPro）,启动服务，在确认软件拿到root权限同时pc和手机在相同网段后，pc上使用ssh root@[ip] -p [port]连上，再su - root。效果同上。</li>\n</ul>\n</blockquote>\n<h3><span id=\"保存到preference\"> 保存到Preference</span></h3>\n<p>preference有些类似cookie。每个Prefernece文件就是存一些k-&gt;v。</p>\n<ul>\n<li>getSharedPreferences() 可以取多个带名文件，当文件不存在的时间，get时会自动创建。</li>\n<li>getPreference() 不需要名，只取一个文件。</li>\n<li>当写文件时，Preference的Editor对象要commit一下才会生效。</li>\n</ul>\n<blockquote>\n<p>当我们用root登录到手机上，cd /data/data/com.example.android.fragments/ (包名根据具体app配置决定)，之后我们能看到一个叫shared_prefs文件夹。<br>\n进入这个文件夹后看到：MainActivity.xml和preference_file_key.xml。</p>\n</blockquote>\n<p>单个文件，无需指定文件名方式</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!--MainActivity.xml--&gt;</span></span><br><span class=\"line\"><span class=\"php\"><span class=\"meta\">&lt;?</span>xml version=<span class=\"string\">'1.0'</span> encoding=<span class=\"string\">'utf-8'</span> standalone=<span class=\"string\">'yes'</span> <span class=\"meta\">?&gt;</span></span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">map</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">string</span> <span class=\"attr\">name</span>=<span class=\"string\">\"preference\"</span>&gt;</span>preference1<span class=\"tag\">&lt;/<span class=\"name\">string</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">map</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>自己指定文件名来存储</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!--preference_file_key.xml--&gt;</span></span><br><span class=\"line\"><span class=\"php\"><span class=\"meta\">&lt;?</span>xml version=<span class=\"string\">'1.0'</span> encoding=<span class=\"string\">'utf-8'</span> standalone=<span class=\"string\">'yes'</span> <span class=\"meta\">?&gt;</span></span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">map</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">string</span> <span class=\"attr\">name</span>=<span class=\"string\">\"sharedPref\"</span>&gt;</span>SharedPreferences1<span class=\"tag\">&lt;/<span class=\"name\">string</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">map</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>再对比一下代码，司马昭之心路人皆知：<em><strong>所谓的Preference就是一个xml文件而已</strong></em></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">saveData</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    SharedPreferences sharedPref = getSharedPreferences();</span><br><span class=\"line\">    SharedPreferences preference = getPreference();</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (sharedPref.getString(<span class=\"string\">\"sharedPref\"</span>, <span class=\"keyword\">null</span>) == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        SharedPreferences.Editor editor = sharedPref.edit();</span><br><span class=\"line\">        editor.putString(<span class=\"string\">\"sharedPref\"</span>, <span class=\"string\">\"SharedPreferences1\"</span>);</span><br><span class=\"line\">        editor.commit();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (preference.getString(<span class=\"string\">\"preference\"</span>, <span class=\"keyword\">null</span>) == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        SharedPreferences.Editor editor = preference.edit();</span><br><span class=\"line\">        editor.putString(<span class=\"string\">\"preference\"</span>, <span class=\"string\">\"preference1\"</span>);</span><br><span class=\"line\">        editor.commit();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 获取preferences</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> SharedPreferences <span class=\"title\">getSharedPreferences</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> getActivity().getSharedPreferences(getString(R.string.preference_file_key), Context.MODE_PRIVATE);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 获取单个文件</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> SharedPreferences <span class=\"title\">getPreference</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> getActivity().getPreferences(Context.MODE_PRIVATE);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3><span id=\"存文件\"> 存文件</span></h3>\n<p>也可以直接操作文件来读写，分为External和Internal两种文件操作。使用的API都是java操作文件IO的标准API。当写完文件以后，可以用adb在上面提到的shared_prefs同级目录中查看到一个files和caches目录分别存储用来存普通文件和临时文件。<br>\n写文件不仅可以写到应用/data/data/package_name/files/下，还可以写到外部存储路径，即sdcard中。</p>\n<blockquote>\n<p>在写入文件时，目录是可以指定的。但是一般情况下的权限只能指定自己app所对应的目录。其他程序目录如果强制被chmod授权，当前程序也可以写到那个目录，或者当前程序拿到root权限也可随便写。</p>\n</blockquote>\n<h3><span id=\"写db\"> 写DB</span></h3>\n<p>Android的自带DB规范是sqlite。操作和java中的一些操作DB方式基本相同。DB文件存在/data/data/[应用]/databases下。可以使用sqlite3命令查看。如果手机上没有安装，可以从模拟器中pull出来，再push到手机上。前提是手机得root。</p>\n<p>搞定以后直接sqlite3 xxx.db。然后sql语句就ok.</p>\n<blockquote>\n<p>在调试过程中，经常会有查询DB中的数据需要。除了命令行，也可以使用一个sqlite editor pro的软件。它可以帮你搜索整个手机中的DB数据，直观查看。</p>\n</blockquote>\n<p>查询</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//要查哪些列</span></span><br><span class=\"line\">String[] projection = &#123;</span><br><span class=\"line\">        FeedReaderContract.FeedEntry._ID,</span><br><span class=\"line\">        FeedReaderContract.FeedEntry.COLUMN_NAME_TITLE</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"comment\">//排序参数，也可以加各种where</span></span><br><span class=\"line\">String sortOrder = FeedReaderContract.FeedEntry._ID + <span class=\"string\">\" DESC\"</span>;</span><br><span class=\"line\"><span class=\"comment\">//拿到游标</span></span><br><span class=\"line\">Cursor cursor = db.query(</span><br><span class=\"line\">        FeedReaderContract.FeedEntry.TABLE_NAME,  <span class=\"comment\">// The table to query</span></span><br><span class=\"line\">        projection,                               <span class=\"comment\">// The columns to return</span></span><br><span class=\"line\">        <span class=\"keyword\">null</span>,                                <span class=\"comment\">// The columns for the WHERE clause</span></span><br><span class=\"line\">        <span class=\"keyword\">null</span>,                            <span class=\"comment\">// The values for the WHERE clause</span></span><br><span class=\"line\">        <span class=\"keyword\">null</span>,                                     <span class=\"comment\">// don't group the rows</span></span><br><span class=\"line\">        <span class=\"keyword\">null</span>,                                     <span class=\"comment\">// don't filter by row groups</span></span><br><span class=\"line\">        sortOrder                                 <span class=\"comment\">// The sort order</span></span><br><span class=\"line\">);</span><br><span class=\"line\"><span class=\"comment\">//移到头</span></span><br><span class=\"line\">cursor.moveToFirst();</span><br><span class=\"line\"><span class=\"comment\">//一般于用do while，判断isLast，然后moveToNext。相当于jdbc中的rs.next()。</span></span><br><span class=\"line\">cursor.moveToNext();</span><br></pre></td></tr></table></figure>\n<p>写</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ContentValues values = <span class=\"keyword\">new</span> ContentValues();</span><br><span class=\"line\">values.put(FeedReaderContract.FeedEntry.COLUMN_NAME_ENTRY_ID, i);</span><br><span class=\"line\">values.put(FeedReaderContract.FeedEntry.COLUMN_NAME_TITLE, <span class=\"string\">\"title\"</span> + i);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">long</span> newRowId = db.insert(FeedReaderContract.FeedEntry.TABLE_NAME, <span class=\"keyword\">null</span>, values);</span><br><span class=\"line\"></span><br><span class=\"line\">list.add(newRowId);</span><br></pre></td></tr></table></figure>\n<p>删除</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">db.delete</span><br></pre></td></tr></table></figure>\n<p>更新</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">db.update</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"chapter-01-getting-started\"><a class=\"markdownIt-Anchor\" href=\"#chapter-01-getting-started\"></a> chapter-01-getting-started</h1>\n<p>Tags: Training-for-Android-developers</p>\n<hr>\n<p>这是一个读 google的 android 教程的整理。仅以记录，不求误人。卽此而已。</p>\n<h3 id=\"关于-ide\"><a class=\"markdownIt-Anchor\" href=\"#关于-ide\"></a> 关于 IDE</h3>\n<p>欲善其事必利其器，在工具的对比和选择时间耗费整整用了一天。不过仍有磨刀不费砍柴功的感觉。直接上结论。</p>\n<blockquote>\n<ul>\n<li>eclipse pass ,其因不再赘述。</li>\n<li>IDEA + android support插件，和 android studio 是相同的代码 compile 出来的，只不过移植要慢一些。由于之前长期使用 idea，在上面有很多种类已经在用的代码插件，目前以来用它通吃了 python\\scala\\java\\php。如果转到其他 IDE 势必会出现要使用两个 IDEA 的情况，不过在使用了一段时间 idea 打 android 插件的方式以后，发现对 android 开发的支持不太完备，用起来有些勉强。十分不情愿的放弃了它。 想说爱你不容易。</li>\n<li>Android Studio 实际上是 IDEA的太监版，试着装了一些诸如 scala 语言的插件，几乎是不可用的。但是！我的目的现在是找一个好用的 IDE for Android。试了一下它的所有android 相关功能非常不错。更重要的是 google官方教程也使用的这款 IDE。</li>\n<li>注（官网答复）： Android Studio and the Android plugin for IntelliJ IDEA are built from the same code, and all of the changes in Android Studio are, and will continue to be, available in IntelliJ IDEA releases.</li>\n</ul>\n</blockquote>\n<h3 id=\"gradle\"><a class=\"markdownIt-Anchor\" href=\"#gradle\"></a> gradle</h3>\n<p>android 程序和 java 程序一样也需要编译好后打包发布。在 java   中早期使用的 ant 比较多。后期逐步由 maven 做了大部分工作。和 ant、maven 一样。gradle 是一种相对较新的打包发布工具。目前在 android 中应用较多。主要是 android studio 使它。其实就是 ant 的升级版，完全兼容 ant 同时可以使用 groovy 和 scala 一些 jvm 平台上的其他语言做为配置语言。比使用 XML 灵活一些（然并卵！谁没事天天配这东西）。类似于 scala 里的 sbt ， nodejs 里的 npm 。<br>\n有人写了一本书还不错：<br>\n<a href=\"https://dongchuan.gitbooks.io/gradle-user-guide-/content/index.html\" target=\"_blank\" rel=\"noopener\">https://dongchuan.gitbooks.io/gradle-user-guide-/content/index.html</a></p>\n<p>最后，感觉对于 android 新人，完全没必要在这个上面浪费太多时间。现学现卖足矣。</p>\n<hr>\n<h2 id=\"getting-started\"><a class=\"markdownIt-Anchor\" href=\"#getting-started\"></a> Getting Started</h2>\n<p>新建一个 android 工程。</p>\n<p>activity ，一个 android 界面就是一个activity。它需要一个布局配置。如下：</p>\n<pre><code>app/src/main/res/layout/activity_my.xml\n</code></pre>\n<p>全局描述文件：</p>\n<pre><code>app/src/main/AndroidManifest.xml\n</code></pre>\n<p>gradle 配置文件：</p>\n<pre><code>app/build.gradle\n</code></pre>\n<p>values、layout、menu 目录：</p>\n<pre><code>values 目录常放一些数字和字符串的值，就是一些存值的配置。类似于 properties 文件。另外两个见名知义。\n</code></pre>\n<h3 id=\"activity及其四种状态\"><a class=\"markdownIt-Anchor\" href=\"#activity及其四种状态\"></a> Activity及其四种状态</h3>\n<p>Activity启动模式设置：</p>\n<pre><code>    &lt;activity android:name=&quot;.MainActivity&quot; android:launchMode=&quot;standard&quot; /&gt;\n</code></pre>\n<p>Activity的四种启动模式：</p>\n<pre><code>1. standard\n\n    默认启动模式，每次激活Activity时都会创建Activity，并放入任务栈中，永远不会调用onNewIntent()。\n\n2. singleTop\n\n    如果在任务的栈顶正好存在该Activity的实例， 就重用该实例，并调用其onNewIntent()，否者就会创建新的实例并放入栈顶(即使栈中已经存在该Activity实例，只要不在栈顶，都会创建实例，而不会调用onNewIntent()，此时就跟standard模式一样)。\n\n3. singleTask\n\n    如果在栈中已经有该Activity的实例，就重用该实例(会调用实例的onNewIntent())。重用时，会让该实例回到栈顶，因此在它上面的实例将会被移除栈。如果栈中不存在该实例，将会创建新的实例放入栈中（此时不会调用onNewIntent()）。 \n\n4. singleInstance\n\n    在一个新栈中创建该Activity实例，并让多个应用共享改栈中的该Activity实例。一旦改模式的Activity的实例存在于某个栈中，任何应用再激活改Activity时都会重用该栈中的实例，其效果相当于多个应用程序共享一个应用，不管谁激活该Activity都会进入同一个应用中。\n</code></pre>\n<h3 id=\"运行和activity消息传递\"><a class=\"markdownIt-Anchor\" href=\"#运行和activity消息传递\"></a> 运行和Activity消息传递</h3>\n<ul>\n<li>Andoird中有 View 和 ViewGroup 的概念。View 就是可见的控件，按钮啥的。类似一些GUI里的 Component ， ViewGroup类似一些语言 GUI 里的 Panel。</li>\n<li>ViewGroup 是 View 容器而已。为了不使这些 View 散乱和更易管理。把许多 View 放在 ViewGroup  中集中调整它的布局等属性。</li>\n</ul>\n<p>wrap_content 根据控件文本等自适应大小。简单来讲：够用就得。<br>\nmatch_parent 充满整个父容器边界。</p>\n<h3 id=\"权重\"><a class=\"markdownIt-Anchor\" href=\"#权重\"></a> 权重</h3>\n<p><em>The weight value is a number that specifies the amount of remaining space each view should consume, relative to the amount consumed by sibling views. This works kind of like the amount of ingredients in a drink recipe: “2 parts soda, 1 part syrup” means two-thirds of the drink is soda. For example, if you give one view a weight of 2 and another one a weight of 1, the sum is 3, so the first view fills 2/3 of the remaining space and the second view fills the rest. If you add a third view and give it a weight of 1, then the first view (with weight of 2) now gets 1/2 the remaining space, while the remaining two each get 1/4.</em></p>\n<figure class=\"highlight lsl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">权重的值指的是每个部件所占剩余空间的大小，该值与同级部件所占空间大小有关。</span><br><span class=\"line\">就类似于饮料的成分配方：“两份伏特加酒，一份咖啡利口酒”，即该酒中伏特加酒占三分之二</span><br><span class=\"line\">。例如，我们设置一个View的权重是<span class=\"number\">2</span>，另一个View的权重是<span class=\"number\">1</span>，那么总数就是<span class=\"number\">3</span>，这时第一个View占据<span class=\"number\">2</span>/<span class=\"number\">3</span>的空间，第二个占据<span class=\"number\">1</span>/<span class=\"number\">3</span>的空间。如果你再加入第三个View，权重设为<span class=\"number\">1</span>，那么第一个View(权重为<span class=\"number\">2</span>的)会占据<span class=\"number\">1</span>/<span class=\"number\">2</span>的空间，剩余的另外两个View各占<span class=\"number\">1</span>/<span class=\"number\">4</span>。(请注意，使用权重的前提一般是给View的宽或者高的大小设置为<span class=\"number\">0</span>dp，然后系统根据上面的权重规则来计算View应该占据的空间。</span><br><span class=\"line\">但是很多情况下，如果给View设置了match_parent的属性，那么上面计算权重时则不是通常的正比，而是反比，也就是权重值大的反而占据空间小)。</span><br><span class=\"line\">对于所有的View默认的权重是<span class=\"number\">0</span>，如果只设置了一个View的权重大于<span class=\"number\">0</span>，则该View将占据除去别的View本身占据的空间的所有剩余空间。</span><br><span class=\"line\">因此这里设置EditText的权重为<span class=\"number\">1</span>，使其能够占据除了按钮之外的所有空间。</span><br><span class=\"line\">目前全中仅被用在LinearLayout中。</span><br></pre></td></tr></table></figure>\n<p><strong>总结：权值PK，此消彼长。</strong></p>\n<h3 id=\"activity-间传递及拉起\"><a class=\"markdownIt-Anchor\" href=\"#activity-间传递及拉起\"></a> Activity 间传递及拉起</h3>\n<p>两个界面 （Activity） 之间如果要传值或者一个拉起另一个的操作，都需要 Intent做为媒介（哪怕不传值，只是拉起下游 Activity 也要使用 Intet 源码中这里没有任何处理，只要你不传它就报 NPE）。Intent 特别类似于网络请求中的 Request 对象，如果服务端没接到 Request 对象，后面的业务也不会被拉起。同样的像 Request 一样，Intent 也可以做为信息传递的载体，putExtra方法和 Request 中的 setAttribute 一样。用 K-&gt;V 的方式存储信息。</p>\n<hr>\n<h2 id=\"适配\"><a class=\"markdownIt-Anchor\" href=\"#适配\"></a> 适配</h2>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//判断指定版本下才可以运行，柔性可用</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.HONEYCOMB) &#123;</span><br><span class=\"line\">    ActionBar actionBar = getActionBar();</span><br><span class=\"line\">    actionBar.setDisplayHomeAsUpEnabled(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>有4种普遍尺寸：小(small)，普通(normal)，大(large)，超大(xlarge)</li>\n<li>4种普遍分辨率：低精度(ldpi), 中精度(mdpi), 高精度(hdpi), 超高精度(xhdpi)</li>\n</ul>\n<p><strong>layout\\国际化(语言)\\图片 这些差别都是用目录来区分的。系统会根据设置或者默认拉起对应的配置。</strong></p>\n<h2 id=\"activity-的生命周期\"><a class=\"markdownIt-Anchor\" href=\"#activity-的生命周期\"></a> Activity 的生命周期</h2>\n<p><img src=\"http://developer.android.com/images/training/basics/basic-lifecycle-paused.png\" alt=\"图1\"></p>\n<p>上图显示：当用户离开我们的activity时，系统会调用onStop()来停止activity (1). 这个时候如果用户返回，系统会调用onRestart()(2), 之后会迅速调用onStart()(3)与onResume()(4). 请注意：无论什么原因导致activity停止，系统总是会在onStop()之前调用onPause()方法。</p>\n<ul>\n<li>onResume: 初始化操作一般在这里做，onCreate 不要初始化太多东西，不然打开应用会很久看不到界面。</li>\n<li>onStop: 当 activity 隐藏以后要执行的heavy-load操作一般会在 onStop 中。不要把heavy-load操作放到 onPasue 这样会影响界面切换速度。写 DB 建议在此方法中实现，任何heavy-load操作再生命周期中执行，要多考虑异步执行，否则容易引起主线程假死。</li>\n</ul>\n<p>几种会调用onDestroy的情况:</p>\n<blockquote>\n<ul>\n<li>用户点击 back 按钮</li>\n<li>程序里调用了 finish() 方法</li>\n<li>资源紧张时（后台长期 stop 状态或者前台需要更多内存），系统可能会干掉它。系统在 destroy 时把现场存到一个 Bundle 对象中的键值对中(instance state)，当用户要回到这个 Activity 时，系统会重建一个 Activity 实例（此 Activity 已是物是人非，非彼 Activity!）</li>\n<li>Activity 会在每次旋转屏幕时被 destroyed 与 recreated 。当屏幕改变方向时，系统会 Destory 与 Recreate 前台的 activity ，因为屏幕配置被改变，Activity 可能需要加载另一些替代的资源(例如layout)。为了让所有信息顺利</li>\n</ul>\n</blockquote>\n<p><img src=\"http://developer.android.com/images/training/basics/basic-lifecycle-savestate.png\" alt=\"图2\"></p>\n<p><strong>调用 onSaveInstanceState 的时机：</strong><br>\nonSaveInstanceState()的调用遵循一个重要原则，即当系统存在“未经你许可”时销毁了我们的activity的<strong>可能</strong>时，则onSaveInstanceState()<strong>可能</strong>会被系统调用，这是系统的责任，因为它必须要提供一个机会让你保存你的数据（当然你不保存那就随便你了）。如果调用，调用将发生在onPause()之后、onStop()方法之前。注：如果你kill或者kill -9，系统都不会调用此方法，因为它没机会执行就被干掉了，做不到。<br>\n　<br>\n以下情况都仅仅是可能会触发该方法的，</p>\n<blockquote>\n<ul>\n<li>用户按下HOME键时。</li>\n<li>长按HOME键，选择运行其他的程序时。</li>\n<li>按下电源按键（关闭屏幕显示）时。</li>\n<li>从activity A中启动一个新的activity时。</li>\n<li>屏幕方向切换时，例如从竖屏切换到横屏时。</li>\n</ul>\n</blockquote>\n<p><strong>调用 onRestoreInstanceState 的时机：</strong><br>\n只有在Activity真的被系统非正常干掉过，恢复显示Activity的时候，才会调用onRestoreInstanceState。</p>\n<h2 id=\"fragments\"><a class=\"markdownIt-Anchor\" href=\"#fragments\"></a> Fragments</h2>\n<p><img src=\"http://developer.android.com/images/fundamentals/fragments.png\" alt=\"图3\"></p>\n<p>Fragment是为了activity的模块化而出现的概念，它拥有自己的生命周期，接收自己的输入事件，可以在acvitity运行过程中添加或者移除（有点像&quot;子activity&quot;，可以在不同的activity里面重复使用，当通过XML布局文件的方式将Fragment添加进activity时，Fragment是不能被动态移除的。如果想要在用户交互的时候把fragment切入与切出，必须在activity启动后，再将fragment添加进activity。）。</p>\n<p><img src=\"http://developer.android.com/images/fragment_lifecycle.png\" alt=\"图4\"></p>\n<ul>\n<li>\n<p>为了执行fragment的增加或者移除操作，必须通过 FragmentManager 创建一个FragmentTransaction对象,FragmentTransaction提供了用来增加、移除、替换以及其它一些操作的APIs。</p>\n</li>\n<li>\n<p>如果我们的activity允许fragment移除或者替换，我们应该在activity的onCreate()方法中添加初始化fragment(s).</p>\n</li>\n<li>\n<p>fragment其实只是一个虚拟的框，它里面不装东西它就什么也不是。所以必须有一个View把它撑起来（inflate）。</p>\n</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">inflater.inflate(R.layout.article_view, container, <span class=\"keyword\">false</span>);</span><br></pre></td></tr></table></figure>\n<p>移除或者替换Fragment，如果要适当地让用户可以向后导航与&quot;撤销&quot;这次改变。为了让用户向后导航fragment事务，我们必须在FragmentTransaction提交前调用addToBackStack()方法。（如果不加到栈顶，点返回键栈里没东西时，会直接返回到桌面）</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">transaction.addToBackStack(<span class=\"keyword\">null</span>);</span><br></pre></td></tr></table></figure>\n<h2 id=\"数据持久化\"><a class=\"markdownIt-Anchor\" href=\"#数据持久化\"></a> 数据持久化</h2>\n<p>为了能方便这里的实验，手机root以后。可以用以下两种方式查看系统文件：</p>\n<blockquote>\n<ul>\n<li>手机连usb后将android sdk的platform加到PATH中，执行adb shell，su - root。就可以切到root下，为所欲为（君子有所为有所不为）。</li>\n<li>也可以在手机端安装一个ssh server软件（如：SSHDriodPro）,启动服务，在确认软件拿到root权限同时pc和手机在相同网段后，pc上使用ssh root@[ip] -p [port]连上，再su - root。效果同上。</li>\n</ul>\n</blockquote>\n<h3 id=\"保存到preference\"><a class=\"markdownIt-Anchor\" href=\"#保存到preference\"></a> 保存到Preference</h3>\n<p>preference有些类似cookie。每个Prefernece文件就是存一些k-&gt;v。</p>\n<ul>\n<li>getSharedPreferences() 可以取多个带名文件，当文件不存在的时间，get时会自动创建。</li>\n<li>getPreference() 不需要名，只取一个文件。</li>\n<li>当写文件时，Preference的Editor对象要commit一下才会生效。</li>\n</ul>\n<blockquote>\n<p>当我们用root登录到手机上，cd /data/data/com.example.android.fragments/ (包名根据具体app配置决定)，之后我们能看到一个叫shared_prefs文件夹。<br>\n进入这个文件夹后看到：MainActivity.xml和preference_file_key.xml。</p>\n</blockquote>\n<p>单个文件，无需指定文件名方式</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!--MainActivity.xml--&gt;</span></span><br><span class=\"line\"><span class=\"php\"><span class=\"meta\">&lt;?</span>xml version=<span class=\"string\">'1.0'</span> encoding=<span class=\"string\">'utf-8'</span> standalone=<span class=\"string\">'yes'</span> <span class=\"meta\">?&gt;</span></span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">map</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">string</span> <span class=\"attr\">name</span>=<span class=\"string\">\"preference\"</span>&gt;</span>preference1<span class=\"tag\">&lt;/<span class=\"name\">string</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">map</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>自己指定文件名来存储</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!--preference_file_key.xml--&gt;</span></span><br><span class=\"line\"><span class=\"php\"><span class=\"meta\">&lt;?</span>xml version=<span class=\"string\">'1.0'</span> encoding=<span class=\"string\">'utf-8'</span> standalone=<span class=\"string\">'yes'</span> <span class=\"meta\">?&gt;</span></span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">map</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">string</span> <span class=\"attr\">name</span>=<span class=\"string\">\"sharedPref\"</span>&gt;</span>SharedPreferences1<span class=\"tag\">&lt;/<span class=\"name\">string</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">map</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>再对比一下代码，司马昭之心路人皆知：<em><strong>所谓的Preference就是一个xml文件而已</strong></em></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">saveData</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    SharedPreferences sharedPref = getSharedPreferences();</span><br><span class=\"line\">    SharedPreferences preference = getPreference();</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (sharedPref.getString(<span class=\"string\">\"sharedPref\"</span>, <span class=\"keyword\">null</span>) == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        SharedPreferences.Editor editor = sharedPref.edit();</span><br><span class=\"line\">        editor.putString(<span class=\"string\">\"sharedPref\"</span>, <span class=\"string\">\"SharedPreferences1\"</span>);</span><br><span class=\"line\">        editor.commit();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (preference.getString(<span class=\"string\">\"preference\"</span>, <span class=\"keyword\">null</span>) == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        SharedPreferences.Editor editor = preference.edit();</span><br><span class=\"line\">        editor.putString(<span class=\"string\">\"preference\"</span>, <span class=\"string\">\"preference1\"</span>);</span><br><span class=\"line\">        editor.commit();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 获取preferences</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> SharedPreferences <span class=\"title\">getSharedPreferences</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> getActivity().getSharedPreferences(getString(R.string.preference_file_key), Context.MODE_PRIVATE);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 获取单个文件</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> SharedPreferences <span class=\"title\">getPreference</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> getActivity().getPreferences(Context.MODE_PRIVATE);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"存文件\"><a class=\"markdownIt-Anchor\" href=\"#存文件\"></a> 存文件</h3>\n<p>也可以直接操作文件来读写，分为External和Internal两种文件操作。使用的API都是java操作文件IO的标准API。当写完文件以后，可以用adb在上面提到的shared_prefs同级目录中查看到一个files和caches目录分别存储用来存普通文件和临时文件。<br>\n写文件不仅可以写到应用/data/data/package_name/files/下，还可以写到外部存储路径，即sdcard中。</p>\n<blockquote>\n<p>在写入文件时，目录是可以指定的。但是一般情况下的权限只能指定自己app所对应的目录。其他程序目录如果强制被chmod授权，当前程序也可以写到那个目录，或者当前程序拿到root权限也可随便写。</p>\n</blockquote>\n<h3 id=\"写db\"><a class=\"markdownIt-Anchor\" href=\"#写db\"></a> 写DB</h3>\n<p>Android的自带DB规范是sqlite。操作和java中的一些操作DB方式基本相同。DB文件存在/data/data/[应用]/databases下。可以使用sqlite3命令查看。如果手机上没有安装，可以从模拟器中pull出来，再push到手机上。前提是手机得root。</p>\n<p>搞定以后直接sqlite3 xxx.db。然后sql语句就ok.</p>\n<blockquote>\n<p>在调试过程中，经常会有查询DB中的数据需要。除了命令行，也可以使用一个sqlite editor pro的软件。它可以帮你搜索整个手机中的DB数据，直观查看。</p>\n</blockquote>\n<p>查询</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//要查哪些列</span></span><br><span class=\"line\">String[] projection = &#123;</span><br><span class=\"line\">        FeedReaderContract.FeedEntry._ID,</span><br><span class=\"line\">        FeedReaderContract.FeedEntry.COLUMN_NAME_TITLE</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"comment\">//排序参数，也可以加各种where</span></span><br><span class=\"line\">String sortOrder = FeedReaderContract.FeedEntry._ID + <span class=\"string\">\" DESC\"</span>;</span><br><span class=\"line\"><span class=\"comment\">//拿到游标</span></span><br><span class=\"line\">Cursor cursor = db.query(</span><br><span class=\"line\">        FeedReaderContract.FeedEntry.TABLE_NAME,  <span class=\"comment\">// The table to query</span></span><br><span class=\"line\">        projection,                               <span class=\"comment\">// The columns to return</span></span><br><span class=\"line\">        <span class=\"keyword\">null</span>,                                <span class=\"comment\">// The columns for the WHERE clause</span></span><br><span class=\"line\">        <span class=\"keyword\">null</span>,                            <span class=\"comment\">// The values for the WHERE clause</span></span><br><span class=\"line\">        <span class=\"keyword\">null</span>,                                     <span class=\"comment\">// don't group the rows</span></span><br><span class=\"line\">        <span class=\"keyword\">null</span>,                                     <span class=\"comment\">// don't filter by row groups</span></span><br><span class=\"line\">        sortOrder                                 <span class=\"comment\">// The sort order</span></span><br><span class=\"line\">);</span><br><span class=\"line\"><span class=\"comment\">//移到头</span></span><br><span class=\"line\">cursor.moveToFirst();</span><br><span class=\"line\"><span class=\"comment\">//一般于用do while，判断isLast，然后moveToNext。相当于jdbc中的rs.next()。</span></span><br><span class=\"line\">cursor.moveToNext();</span><br></pre></td></tr></table></figure>\n<p>写</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ContentValues values = <span class=\"keyword\">new</span> ContentValues();</span><br><span class=\"line\">values.put(FeedReaderContract.FeedEntry.COLUMN_NAME_ENTRY_ID, i);</span><br><span class=\"line\">values.put(FeedReaderContract.FeedEntry.COLUMN_NAME_TITLE, <span class=\"string\">\"title\"</span> + i);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">long</span> newRowId = db.insert(FeedReaderContract.FeedEntry.TABLE_NAME, <span class=\"keyword\">null</span>, values);</span><br><span class=\"line\"></span><br><span class=\"line\">list.add(newRowId);</span><br></pre></td></tr></table></figure>\n<p>删除</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">db.delete</span><br></pre></td></tr></table></figure>\n<p>更新</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">db.update</span><br></pre></td></tr></table></figure>\n"},{"title":"chapter-03-bitmap-and-background-threads","catalog":true,"date":"2016-02-22T09:21:29.000Z","header-img":"/img/06.jpg","_content":"\n# chapter-03-bitmap-and-background-threads\n\nTags:Training-for-Android-developers\n\n---\n\n## 位图（Bitmap）\n和Drawable的区别：一个Bitmap对象是一张bitmap格式图片的表示(类似于Java.awt.image）。一个Drawable对象是“那些能够在其上面画的任意对象”，它也许是一个bitmap对象，也可能是一个solid color、一个其他Drawable对象的集合。 大多数Android UI框架喜欢用Drawable对象，而不是Bitmap对象。一个View可以接受任何Drawable对象作为background。\n\n>*    Mobile devices typically have constrained system resources. Android devices can have as little as 16MB of memory available to a single application. The Android Compatibility Definition Document (CDD), Section 3.7. Virtual Machine Compatibility gives the required minimum application memory for various screen sizes and densities. Applications should be optimized to perform under this minimum memory limit. However, keep in mind many devices are configured with higher limits.\n\nAndroid设备为每个app分配16MB的内存空间，虽然厂商会更改rom，定制更高的单个App内存空间，但是开发者应该依据最小的内存限制即16MB控制内存开销。\n \n>*    Android设备屏幕大小不一，分辨率各不相同。如果在UI中需要加载一副大图片，明智的做法是先获取屏幕的分辨率，然后再决定加载图片的大小。在一款低分辨率的设备上加载高分辨率图片除了增加内存消耗，别无他用。因为设备最大能展示的清晰度为本身的屏幕分辨率。所以，如果一个不需要放大图片的控件需要加载图片，最大只需要加载该控件本身宽高的图片即可。\n\nBitmapFactory提供了一些解码（decode）的方法（decodeByteArray(), decodeFile(), decodeResource()等），用来从不同的资源中创建一个Bitmap。\n\n设置 inJustDecodeBounds 属性为true可以在解码的时候避免内存的分配，它会返回一个null的Bitmap，但是可以获取到 outWidth, outHeight 与 outMimeType。这样可以允许你在构造Bitmap之前优先读图片的尺寸与类型。\n\n>*    BitmapFactory.Options 中设置 inSampleSize 的值。例如, 一个分辨率为2048x1536的图片，如果设置 inSampleSize 为4，那么会产出一个大约512x384大小的Bitmap。大小只是原来的1/16。\n\n```java\n// Calculate inSampleSize\noptions.inSampleSize = calculateInSampleSize(options, reqWidth, reqHeight);\n```\n\n在处理图片时，一般防止图将主线程卡住。一般会使用AsyncTask，将处理图片的过程放到单独的线程中处理。使用弱、软引用时，要注意到目前的虚拟机中GC的频率很高，在API LEVEL 11以前bitmap是放到native内存中，这样被回收后的状态是不可预知的，可能会产生crash。所以要慎重使用这两种引用方式。\n\n使用缓存是处理图片时的常用方式，一般分为两种方式，内存缓存可以使用LruCache（本质就是一个LinkedHashMap）。也可以使用DiskLruCache。\n\n## Android后台任务\n\n### IntentService\n>* The IntentService class provides a straightforward structure for running an operation on a single background thread.\nIntentService类提供了一个简单的后台单线程的实现。\n\n但是IntentService有下面几个局限性：\nAn IntentService has a few limitations:\n>* It can't interact directly with your user interface. To put its results in the UI, you have to send them to an Activity.\n不可以直接和UI做交互。为了把他执行的结果体现在UI上，需要把结果返回给Activity。\n\n>* Work requests run sequentially. If an operation is running in an IntentService, and you send it another request, the request waits until the first operation is finished.\n工作任务队列是顺序执行的，如果一个任务正在IntentService中执行，此时你再发送一个新的任务请求，这个新的任务会一直等待直到前面一个任务执行完毕才开始执行。\n\n>* An operation ru\n\n```javanning on an IntentService can't be interrupted.\n正在执行的任务无法打断。\n\n>* **这么一大堆，其实就是在说：这只是一个方便使用的单线程。**\n\n主线程拉起一个Inservice线程，并和IntentService来来回回没完没了的交互。总（long）共分四步：\n\n* 建一个IntentService子类，实现里面的回调方法onHandleIntent。\n* 在主线程创建一个IntentService子类的对象。并拉起来。\n* 建一个Receiver，并实现回调。\n* 把Receiver注册上。（把冰箱门关上）\n\n#### Let's Go !\n\n1, 创建一个IntentService class\n```xml\n<application\n    android:icon=\"@drawable/icon\"\n    android:label=\"@string/app_name\">\n    ...\n    <!--\n        Because android:exported is set to \"false\",\n        the service is only available to this app.\n    -->\n    <service\n        android:name=\".RSSPullService\"\n        android:exported=\"false\"/>\n    ...\n<application/>\n```\njava code\n\n\n```java\npublic class RSSPullService extends IntentService {\n    @Override\n    protected void onHandleIntent(Intent workIntent) {\n        // Gets data from the incoming Intent\n        String dataString = workIntent.getDataString();\n        // to do something bala bala...\n    }\n}\n```\n2, 创建一个具体的Intent对象，并用来启动IntentService。\n\n\n```java\n/*\n * Creates a new Intent to start the RSSPullService\n * IntentService. Passes a URI in the\n * Intent's \"data\" field.\n */\nmServiceIntent = new Intent(getActivity(), RSSPullService.class);\nmServiceIntent.setData(Uri.parse(dataUrl));\n// Let's go!\ngetActivity().startService(mServiceIntent);\n```\n3, 如果需要发送数据给主线程\n\n\n```java\nIntent localIntent = new Intent(Constants.BROADCAST_ACTION);\n// Puts the status into the Intent\nlocalIntent.putExtra(Constants.EXTENDED_DATA_STATUS, status);\noadcastManager.getInstance(this).sendBroadcast(localIntent);\n```\n定义主线程接收消息的类，需要一个BroadcastReceiver的子类。并复写onReceive。\n\n```java\n// Broadcast receiver for receiving status updates from the IntentService\nprivate class ResponseReceiver extends BroadcastReceiver\n{\n    // Prevents instantiation\n    private DownloadStateReceiver() {\n    }\n    // Called when the BroadcastReceiver gets an Intent it's registered to receive\n    @\n    public void onReceive(Context context, Intent intent) {\n...\n        /*\n         * Handle Intents here.\n         */\n...\n    }\n}\n```\n4, 即使有了receiver类，如果想要收到子线程发的消息。还要让程序知道，接收什么样的消息，用谁来接收。\n\n\n```java\n// 接收什么样的消息\nIntentFilter statusIntentFilter = new IntentFilter(Constants.BROADCAST_ACTION);\nstatusIntentFilter.addCategory(Intent.CATEGORY_DEFAULT);\n\n// 用谁来接收（注册receiver）\nmDownloadStateReceiver = new ResponseReceiver();\nLocalBroadcastManager.getInstance(this).registerReceiver(mDownloadStateReceiver, statusIntentFilter);\n```\n\n### 点亮屏幕\n\n\n```java\ngetWindow().addFlags(WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON);\n//清除flag回到正常状态\ngetWindow().clearFlags(WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON)\n```\n也可以AndroidManifest.xml里定义该属性，由于在AndroidManifest里定义的内容不能动态改变。所以设了就不能反悔。\n\n\n","source":"_posts/chapter-03-bitmap-and-background-threads.md","raw":"---\ntitle: 'chapter-03-bitmap-and-background-threads'\ncatalog: true\ndate: 2016-02-22 17:21:29\nheader-img: \"/img/06.jpg\"\ntags: \"android\"\n---\n\n# chapter-03-bitmap-and-background-threads\n\nTags:Training-for-Android-developers\n\n---\n\n## 位图（Bitmap）\n和Drawable的区别：一个Bitmap对象是一张bitmap格式图片的表示(类似于Java.awt.image）。一个Drawable对象是“那些能够在其上面画的任意对象”，它也许是一个bitmap对象，也可能是一个solid color、一个其他Drawable对象的集合。 大多数Android UI框架喜欢用Drawable对象，而不是Bitmap对象。一个View可以接受任何Drawable对象作为background。\n\n>*    Mobile devices typically have constrained system resources. Android devices can have as little as 16MB of memory available to a single application. The Android Compatibility Definition Document (CDD), Section 3.7. Virtual Machine Compatibility gives the required minimum application memory for various screen sizes and densities. Applications should be optimized to perform under this minimum memory limit. However, keep in mind many devices are configured with higher limits.\n\nAndroid设备为每个app分配16MB的内存空间，虽然厂商会更改rom，定制更高的单个App内存空间，但是开发者应该依据最小的内存限制即16MB控制内存开销。\n \n>*    Android设备屏幕大小不一，分辨率各不相同。如果在UI中需要加载一副大图片，明智的做法是先获取屏幕的分辨率，然后再决定加载图片的大小。在一款低分辨率的设备上加载高分辨率图片除了增加内存消耗，别无他用。因为设备最大能展示的清晰度为本身的屏幕分辨率。所以，如果一个不需要放大图片的控件需要加载图片，最大只需要加载该控件本身宽高的图片即可。\n\nBitmapFactory提供了一些解码（decode）的方法（decodeByteArray(), decodeFile(), decodeResource()等），用来从不同的资源中创建一个Bitmap。\n\n设置 inJustDecodeBounds 属性为true可以在解码的时候避免内存的分配，它会返回一个null的Bitmap，但是可以获取到 outWidth, outHeight 与 outMimeType。这样可以允许你在构造Bitmap之前优先读图片的尺寸与类型。\n\n>*    BitmapFactory.Options 中设置 inSampleSize 的值。例如, 一个分辨率为2048x1536的图片，如果设置 inSampleSize 为4，那么会产出一个大约512x384大小的Bitmap。大小只是原来的1/16。\n\n```java\n// Calculate inSampleSize\noptions.inSampleSize = calculateInSampleSize(options, reqWidth, reqHeight);\n```\n\n在处理图片时，一般防止图将主线程卡住。一般会使用AsyncTask，将处理图片的过程放到单独的线程中处理。使用弱、软引用时，要注意到目前的虚拟机中GC的频率很高，在API LEVEL 11以前bitmap是放到native内存中，这样被回收后的状态是不可预知的，可能会产生crash。所以要慎重使用这两种引用方式。\n\n使用缓存是处理图片时的常用方式，一般分为两种方式，内存缓存可以使用LruCache（本质就是一个LinkedHashMap）。也可以使用DiskLruCache。\n\n## Android后台任务\n\n### IntentService\n>* The IntentService class provides a straightforward structure for running an operation on a single background thread.\nIntentService类提供了一个简单的后台单线程的实现。\n\n但是IntentService有下面几个局限性：\nAn IntentService has a few limitations:\n>* It can't interact directly with your user interface. To put its results in the UI, you have to send them to an Activity.\n不可以直接和UI做交互。为了把他执行的结果体现在UI上，需要把结果返回给Activity。\n\n>* Work requests run sequentially. If an operation is running in an IntentService, and you send it another request, the request waits until the first operation is finished.\n工作任务队列是顺序执行的，如果一个任务正在IntentService中执行，此时你再发送一个新的任务请求，这个新的任务会一直等待直到前面一个任务执行完毕才开始执行。\n\n>* An operation ru\n\n```javanning on an IntentService can't be interrupted.\n正在执行的任务无法打断。\n\n>* **这么一大堆，其实就是在说：这只是一个方便使用的单线程。**\n\n主线程拉起一个Inservice线程，并和IntentService来来回回没完没了的交互。总（long）共分四步：\n\n* 建一个IntentService子类，实现里面的回调方法onHandleIntent。\n* 在主线程创建一个IntentService子类的对象。并拉起来。\n* 建一个Receiver，并实现回调。\n* 把Receiver注册上。（把冰箱门关上）\n\n#### Let's Go !\n\n1, 创建一个IntentService class\n```xml\n<application\n    android:icon=\"@drawable/icon\"\n    android:label=\"@string/app_name\">\n    ...\n    <!--\n        Because android:exported is set to \"false\",\n        the service is only available to this app.\n    -->\n    <service\n        android:name=\".RSSPullService\"\n        android:exported=\"false\"/>\n    ...\n<application/>\n```\njava code\n\n\n```java\npublic class RSSPullService extends IntentService {\n    @Override\n    protected void onHandleIntent(Intent workIntent) {\n        // Gets data from the incoming Intent\n        String dataString = workIntent.getDataString();\n        // to do something bala bala...\n    }\n}\n```\n2, 创建一个具体的Intent对象，并用来启动IntentService。\n\n\n```java\n/*\n * Creates a new Intent to start the RSSPullService\n * IntentService. Passes a URI in the\n * Intent's \"data\" field.\n */\nmServiceIntent = new Intent(getActivity(), RSSPullService.class);\nmServiceIntent.setData(Uri.parse(dataUrl));\n// Let's go!\ngetActivity().startService(mServiceIntent);\n```\n3, 如果需要发送数据给主线程\n\n\n```java\nIntent localIntent = new Intent(Constants.BROADCAST_ACTION);\n// Puts the status into the Intent\nlocalIntent.putExtra(Constants.EXTENDED_DATA_STATUS, status);\noadcastManager.getInstance(this).sendBroadcast(localIntent);\n```\n定义主线程接收消息的类，需要一个BroadcastReceiver的子类。并复写onReceive。\n\n```java\n// Broadcast receiver for receiving status updates from the IntentService\nprivate class ResponseReceiver extends BroadcastReceiver\n{\n    // Prevents instantiation\n    private DownloadStateReceiver() {\n    }\n    // Called when the BroadcastReceiver gets an Intent it's registered to receive\n    @\n    public void onReceive(Context context, Intent intent) {\n...\n        /*\n         * Handle Intents here.\n         */\n...\n    }\n}\n```\n4, 即使有了receiver类，如果想要收到子线程发的消息。还要让程序知道，接收什么样的消息，用谁来接收。\n\n\n```java\n// 接收什么样的消息\nIntentFilter statusIntentFilter = new IntentFilter(Constants.BROADCAST_ACTION);\nstatusIntentFilter.addCategory(Intent.CATEGORY_DEFAULT);\n\n// 用谁来接收（注册receiver）\nmDownloadStateReceiver = new ResponseReceiver();\nLocalBroadcastManager.getInstance(this).registerReceiver(mDownloadStateReceiver, statusIntentFilter);\n```\n\n### 点亮屏幕\n\n\n```java\ngetWindow().addFlags(WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON);\n//清除flag回到正常状态\ngetWindow().clearFlags(WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON)\n```\n也可以AndroidManifest.xml里定义该属性，由于在AndroidManifest里定义的内容不能动态改变。所以设了就不能反悔。\n\n\n","slug":"chapter-03-bitmap-and-background-threads","published":1,"updated":"2017-11-25T06:38:21.371Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjahvvnxw000tpv4nzbnuri2f","content":"<h1><span id=\"chapter-03-bitmap-and-background-threads\"> chapter-03-bitmap-and-background-threads</span></h1>\n<p>Tags:Training-for-Android-developers</p>\n<hr>\n<h2><span id=\"位图bitmap\"> 位图（Bitmap）</span></h2>\n<p>和Drawable的区别：一个Bitmap对象是一张bitmap格式图片的表示(类似于Java.awt.image）。一个Drawable对象是“那些能够在其上面画的任意对象”，它也许是一个bitmap对象，也可能是一个solid color、一个其他Drawable对象的集合。 大多数Android UI框架喜欢用Drawable对象，而不是Bitmap对象。一个View可以接受任何Drawable对象作为background。</p>\n<blockquote>\n<ul>\n<li>Mobile devices typically have constrained system resources. Android devices can have as little as 16MB of memory available to a single application. The Android Compatibility Definition Document (CDD), Section 3.7. Virtual Machine Compatibility gives the required minimum application memory for various screen sizes and densities. Applications should be optimized to perform under this minimum memory limit. However, keep in mind many devices are configured with higher limits.</li>\n</ul>\n</blockquote>\n<p>Android设备为每个app分配16MB的内存空间，虽然厂商会更改rom，定制更高的单个App内存空间，但是开发者应该依据最小的内存限制即16MB控制内存开销。</p>\n<blockquote>\n<ul>\n<li>Android设备屏幕大小不一，分辨率各不相同。如果在UI中需要加载一副大图片，明智的做法是先获取屏幕的分辨率，然后再决定加载图片的大小。在一款低分辨率的设备上加载高分辨率图片除了增加内存消耗，别无他用。因为设备最大能展示的清晰度为本身的屏幕分辨率。所以，如果一个不需要放大图片的控件需要加载图片，最大只需要加载该控件本身宽高的图片即可。</li>\n</ul>\n</blockquote>\n<p>BitmapFactory提供了一些解码（decode）的方法（decodeByteArray(), decodeFile(), decodeResource()等），用来从不同的资源中创建一个Bitmap。</p>\n<p>设置 inJustDecodeBounds 属性为true可以在解码的时候避免内存的分配，它会返回一个null的Bitmap，但是可以获取到 outWidth, outHeight 与 outMimeType。这样可以允许你在构造Bitmap之前优先读图片的尺寸与类型。</p>\n<blockquote>\n<ul>\n<li>BitmapFactory.Options 中设置 inSampleSize 的值。例如, 一个分辨率为2048x1536的图片，如果设置 inSampleSize 为4，那么会产出一个大约512x384大小的Bitmap。大小只是原来的1/16。</li>\n</ul>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Calculate inSampleSize</span></span><br><span class=\"line\">options.inSampleSize = calculateInSampleSize(options, reqWidth, reqHeight);</span><br></pre></td></tr></table></figure>\n<p>在处理图片时，一般防止图将主线程卡住。一般会使用AsyncTask，将处理图片的过程放到单独的线程中处理。使用弱、软引用时，要注意到目前的虚拟机中GC的频率很高，在API LEVEL 11以前bitmap是放到native内存中，这样被回收后的状态是不可预知的，可能会产生crash。所以要慎重使用这两种引用方式。</p>\n<p>使用缓存是处理图片时的常用方式，一般分为两种方式，内存缓存可以使用LruCache（本质就是一个LinkedHashMap）。也可以使用DiskLruCache。</p>\n<h2><span id=\"android后台任务\"> Android后台任务</span></h2>\n<h3><span id=\"intentservice\"> IntentService</span></h3>\n<blockquote>\n<ul>\n<li>The IntentService class provides a straightforward structure for running an operation on a single background thread.<br>\nIntentService类提供了一个简单的后台单线程的实现。</li>\n</ul>\n</blockquote>\n<p>但是IntentService有下面几个局限性：<br>\nAn IntentService has a few limitations:</p>\n<blockquote>\n<ul>\n<li>It can’t interact directly with your user interface. To put its results in the UI, you have to send them to an Activity.<br>\n不可以直接和UI做交互。为了把他执行的结果体现在UI上，需要把结果返回给Activity。</li>\n</ul>\n</blockquote>\n<blockquote>\n<ul>\n<li>Work requests run sequentially. If an operation is running in an IntentService, and you send it another request, the request waits until the first operation is finished.<br>\n工作任务队列是顺序执行的，如果一个任务正在IntentService中执行，此时你再发送一个新的任务请求，这个新的任务会一直等待直到前面一个任务执行完毕才开始执行。</li>\n</ul>\n</blockquote>\n<blockquote>\n<ul>\n<li>An operation ru</li>\n</ul>\n</blockquote>\n<figure class=\"highlight plain\"><figcaption><span>on an IntentService can't be interrupted.</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">正在执行的任务无法打断。</span><br><span class=\"line\"></span><br><span class=\"line\">&gt;* **这么一大堆，其实就是在说：这只是一个方便使用的单线程。**</span><br><span class=\"line\"></span><br><span class=\"line\">主线程拉起一个Inservice线程，并和IntentService来来回回没完没了的交互。总（long）共分四步：</span><br><span class=\"line\"></span><br><span class=\"line\">* 建一个IntentService子类，实现里面的回调方法onHandleIntent。</span><br><span class=\"line\">* 在主线程创建一个IntentService子类的对象。并拉起来。</span><br><span class=\"line\">* 建一个Receiver，并实现回调。</span><br><span class=\"line\">* 把Receiver注册上。（把冰箱门关上）</span><br><span class=\"line\"></span><br><span class=\"line\">#### Let&apos;s Go !</span><br><span class=\"line\"></span><br><span class=\"line\">1, 创建一个IntentService class</span><br><span class=\"line\">```xml</span><br><span class=\"line\">&lt;application</span><br><span class=\"line\">    android:icon=&quot;@drawable/icon&quot;</span><br><span class=\"line\">    android:label=&quot;@string/app_name&quot;&gt;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    &lt;!--</span><br><span class=\"line\">        Because android:exported is set to &quot;false&quot;,</span><br><span class=\"line\">        the service is only available to this app.</span><br><span class=\"line\">    --&gt;</span><br><span class=\"line\">    &lt;service</span><br><span class=\"line\">        android:name=&quot;.RSSPullService&quot;</span><br><span class=\"line\">        android:exported=&quot;false&quot;/&gt;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&lt;application/&gt;</span><br></pre></td></tr></table></figure>\n<p>java code</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RSSPullService</span> <span class=\"keyword\">extends</span> <span class=\"title\">IntentService</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onHandleIntent</span><span class=\"params\">(Intent workIntent)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// Gets data from the incoming Intent</span></span><br><span class=\"line\">        String dataString = workIntent.getDataString();</span><br><span class=\"line\">        <span class=\"comment\">// to do something bala bala...</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>2, 创建一个具体的Intent对象，并用来启动IntentService。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> * Creates a new Intent to start the RSSPullService</span></span><br><span class=\"line\"><span class=\"comment\"> * IntentService. Passes a URI in the</span></span><br><span class=\"line\"><span class=\"comment\"> * Intent's \"data\" field.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">mServiceIntent = <span class=\"keyword\">new</span> Intent(getActivity(), RSSPullService.class);</span><br><span class=\"line\">mServiceIntent.setData(Uri.parse(dataUrl));</span><br><span class=\"line\"><span class=\"comment\">// Let's go!</span></span><br><span class=\"line\">getActivity().startService(mServiceIntent);</span><br></pre></td></tr></table></figure>\n<p>3, 如果需要发送数据给主线程</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Intent localIntent = <span class=\"keyword\">new</span> Intent(Constants.BROADCAST_ACTION);</span><br><span class=\"line\"><span class=\"comment\">// Puts the status into the Intent</span></span><br><span class=\"line\">localIntent.putExtra(Constants.EXTENDED_DATA_STATUS, status);</span><br><span class=\"line\">oadcastManager.getInstance(<span class=\"keyword\">this</span>).sendBroadcast(localIntent);</span><br></pre></td></tr></table></figure>\n<p>定义主线程接收消息的类，需要一个BroadcastReceiver的子类。并复写onReceive。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Broadcast receiver for receiving status updates from the IntentService</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ResponseReceiver</span> <span class=\"keyword\">extends</span> <span class=\"title\">BroadcastReceiver</span></span></span><br><span class=\"line\"><span class=\"class\"></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// Prevents instantiation</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">DownloadStateReceiver</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// Called when the BroadcastReceiver gets an Intent it's registered to receive</span></span><br><span class=\"line\">    @</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onReceive</span><span class=\"params\">(Context context, Intent intent)</span> </span>&#123;</span><br><span class=\"line\">...</span><br><span class=\"line\">        <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">         * Handle Intents here.</span></span><br><span class=\"line\"><span class=\"comment\">         */</span></span><br><span class=\"line\">...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>4, 即使有了receiver类，如果想要收到子线程发的消息。还要让程序知道，接收什么样的消息，用谁来接收。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 接收什么样的消息</span></span><br><span class=\"line\">IntentFilter statusIntentFilter = <span class=\"keyword\">new</span> IntentFilter(Constants.BROADCAST_ACTION);</span><br><span class=\"line\">statusIntentFilter.addCategory(Intent.CATEGORY_DEFAULT);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 用谁来接收（注册receiver）</span></span><br><span class=\"line\">mDownloadStateReceiver = <span class=\"keyword\">new</span> ResponseReceiver();</span><br><span class=\"line\">LocalBroadcastManager.getInstance(<span class=\"keyword\">this</span>).registerReceiver(mDownloadStateReceiver, statusIntentFilter);</span><br></pre></td></tr></table></figure>\n<h3><span id=\"点亮屏幕\"> 点亮屏幕</span></h3>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">getWindow().addFlags(WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON);</span><br><span class=\"line\"><span class=\"comment\">//清除flag回到正常状态</span></span><br><span class=\"line\">getWindow().clearFlags(WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON)</span><br></pre></td></tr></table></figure>\n<p>也可以AndroidManifest.xml里定义该属性，由于在AndroidManifest里定义的内容不能动态改变。所以设了就不能反悔。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"chapter-03-bitmap-and-background-threads\"><a class=\"markdownIt-Anchor\" href=\"#chapter-03-bitmap-and-background-threads\"></a> chapter-03-bitmap-and-background-threads</h1>\n<p>Tags:Training-for-Android-developers</p>\n<hr>\n<h2 id=\"位图bitmap\"><a class=\"markdownIt-Anchor\" href=\"#位图bitmap\"></a> 位图（Bitmap）</h2>\n<p>和Drawable的区别：一个Bitmap对象是一张bitmap格式图片的表示(类似于Java.awt.image）。一个Drawable对象是“那些能够在其上面画的任意对象”，它也许是一个bitmap对象，也可能是一个solid color、一个其他Drawable对象的集合。 大多数Android UI框架喜欢用Drawable对象，而不是Bitmap对象。一个View可以接受任何Drawable对象作为background。</p>\n<blockquote>\n<ul>\n<li>Mobile devices typically have constrained system resources. Android devices can have as little as 16MB of memory available to a single application. The Android Compatibility Definition Document (CDD), Section 3.7. Virtual Machine Compatibility gives the required minimum application memory for various screen sizes and densities. Applications should be optimized to perform under this minimum memory limit. However, keep in mind many devices are configured with higher limits.</li>\n</ul>\n</blockquote>\n<p>Android设备为每个app分配16MB的内存空间，虽然厂商会更改rom，定制更高的单个App内存空间，但是开发者应该依据最小的内存限制即16MB控制内存开销。</p>\n<blockquote>\n<ul>\n<li>Android设备屏幕大小不一，分辨率各不相同。如果在UI中需要加载一副大图片，明智的做法是先获取屏幕的分辨率，然后再决定加载图片的大小。在一款低分辨率的设备上加载高分辨率图片除了增加内存消耗，别无他用。因为设备最大能展示的清晰度为本身的屏幕分辨率。所以，如果一个不需要放大图片的控件需要加载图片，最大只需要加载该控件本身宽高的图片即可。</li>\n</ul>\n</blockquote>\n<p>BitmapFactory提供了一些解码（decode）的方法（decodeByteArray(), decodeFile(), decodeResource()等），用来从不同的资源中创建一个Bitmap。</p>\n<p>设置 inJustDecodeBounds 属性为true可以在解码的时候避免内存的分配，它会返回一个null的Bitmap，但是可以获取到 outWidth, outHeight 与 outMimeType。这样可以允许你在构造Bitmap之前优先读图片的尺寸与类型。</p>\n<blockquote>\n<ul>\n<li>BitmapFactory.Options 中设置 inSampleSize 的值。例如, 一个分辨率为2048x1536的图片，如果设置 inSampleSize 为4，那么会产出一个大约512x384大小的Bitmap。大小只是原来的1/16。</li>\n</ul>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Calculate inSampleSize</span></span><br><span class=\"line\">options.inSampleSize = calculateInSampleSize(options, reqWidth, reqHeight);</span><br></pre></td></tr></table></figure>\n<p>在处理图片时，一般防止图将主线程卡住。一般会使用AsyncTask，将处理图片的过程放到单独的线程中处理。使用弱、软引用时，要注意到目前的虚拟机中GC的频率很高，在API LEVEL 11以前bitmap是放到native内存中，这样被回收后的状态是不可预知的，可能会产生crash。所以要慎重使用这两种引用方式。</p>\n<p>使用缓存是处理图片时的常用方式，一般分为两种方式，内存缓存可以使用LruCache（本质就是一个LinkedHashMap）。也可以使用DiskLruCache。</p>\n<h2 id=\"android后台任务\"><a class=\"markdownIt-Anchor\" href=\"#android后台任务\"></a> Android后台任务</h2>\n<h3 id=\"intentservice\"><a class=\"markdownIt-Anchor\" href=\"#intentservice\"></a> IntentService</h3>\n<blockquote>\n<ul>\n<li>The IntentService class provides a straightforward structure for running an operation on a single background thread.<br>\nIntentService类提供了一个简单的后台单线程的实现。</li>\n</ul>\n</blockquote>\n<p>但是IntentService有下面几个局限性：<br>\nAn IntentService has a few limitations:</p>\n<blockquote>\n<ul>\n<li>It can’t interact directly with your user interface. To put its results in the UI, you have to send them to an Activity.<br>\n不可以直接和UI做交互。为了把他执行的结果体现在UI上，需要把结果返回给Activity。</li>\n</ul>\n</blockquote>\n<blockquote>\n<ul>\n<li>Work requests run sequentially. If an operation is running in an IntentService, and you send it another request, the request waits until the first operation is finished.<br>\n工作任务队列是顺序执行的，如果一个任务正在IntentService中执行，此时你再发送一个新的任务请求，这个新的任务会一直等待直到前面一个任务执行完毕才开始执行。</li>\n</ul>\n</blockquote>\n<blockquote>\n<ul>\n<li>An operation ru</li>\n</ul>\n</blockquote>\n<figure class=\"highlight plain\"><figcaption><span>on an IntentService can't be interrupted.</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">正在执行的任务无法打断。</span><br><span class=\"line\"></span><br><span class=\"line\">&gt;* **这么一大堆，其实就是在说：这只是一个方便使用的单线程。**</span><br><span class=\"line\"></span><br><span class=\"line\">主线程拉起一个Inservice线程，并和IntentService来来回回没完没了的交互。总（long）共分四步：</span><br><span class=\"line\"></span><br><span class=\"line\">* 建一个IntentService子类，实现里面的回调方法onHandleIntent。</span><br><span class=\"line\">* 在主线程创建一个IntentService子类的对象。并拉起来。</span><br><span class=\"line\">* 建一个Receiver，并实现回调。</span><br><span class=\"line\">* 把Receiver注册上。（把冰箱门关上）</span><br><span class=\"line\"></span><br><span class=\"line\">#### Let&apos;s Go !</span><br><span class=\"line\"></span><br><span class=\"line\">1, 创建一个IntentService class</span><br><span class=\"line\">```xml</span><br><span class=\"line\">&lt;application</span><br><span class=\"line\">    android:icon=&quot;@drawable/icon&quot;</span><br><span class=\"line\">    android:label=&quot;@string/app_name&quot;&gt;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    &lt;!--</span><br><span class=\"line\">        Because android:exported is set to &quot;false&quot;,</span><br><span class=\"line\">        the service is only available to this app.</span><br><span class=\"line\">    --&gt;</span><br><span class=\"line\">    &lt;service</span><br><span class=\"line\">        android:name=&quot;.RSSPullService&quot;</span><br><span class=\"line\">        android:exported=&quot;false&quot;/&gt;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&lt;application/&gt;</span><br></pre></td></tr></table></figure>\n<p>java code</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RSSPullService</span> <span class=\"keyword\">extends</span> <span class=\"title\">IntentService</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onHandleIntent</span><span class=\"params\">(Intent workIntent)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// Gets data from the incoming Intent</span></span><br><span class=\"line\">        String dataString = workIntent.getDataString();</span><br><span class=\"line\">        <span class=\"comment\">// to do something bala bala...</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>2, 创建一个具体的Intent对象，并用来启动IntentService。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> * Creates a new Intent to start the RSSPullService</span></span><br><span class=\"line\"><span class=\"comment\"> * IntentService. Passes a URI in the</span></span><br><span class=\"line\"><span class=\"comment\"> * Intent's \"data\" field.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">mServiceIntent = <span class=\"keyword\">new</span> Intent(getActivity(), RSSPullService.class);</span><br><span class=\"line\">mServiceIntent.setData(Uri.parse(dataUrl));</span><br><span class=\"line\"><span class=\"comment\">// Let's go!</span></span><br><span class=\"line\">getActivity().startService(mServiceIntent);</span><br></pre></td></tr></table></figure>\n<p>3, 如果需要发送数据给主线程</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Intent localIntent = <span class=\"keyword\">new</span> Intent(Constants.BROADCAST_ACTION);</span><br><span class=\"line\"><span class=\"comment\">// Puts the status into the Intent</span></span><br><span class=\"line\">localIntent.putExtra(Constants.EXTENDED_DATA_STATUS, status);</span><br><span class=\"line\">oadcastManager.getInstance(<span class=\"keyword\">this</span>).sendBroadcast(localIntent);</span><br></pre></td></tr></table></figure>\n<p>定义主线程接收消息的类，需要一个BroadcastReceiver的子类。并复写onReceive。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Broadcast receiver for receiving status updates from the IntentService</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ResponseReceiver</span> <span class=\"keyword\">extends</span> <span class=\"title\">BroadcastReceiver</span></span></span><br><span class=\"line\"><span class=\"class\"></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// Prevents instantiation</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">DownloadStateReceiver</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// Called when the BroadcastReceiver gets an Intent it's registered to receive</span></span><br><span class=\"line\">    @</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onReceive</span><span class=\"params\">(Context context, Intent intent)</span> </span>&#123;</span><br><span class=\"line\">...</span><br><span class=\"line\">        <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">         * Handle Intents here.</span></span><br><span class=\"line\"><span class=\"comment\">         */</span></span><br><span class=\"line\">...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>4, 即使有了receiver类，如果想要收到子线程发的消息。还要让程序知道，接收什么样的消息，用谁来接收。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 接收什么样的消息</span></span><br><span class=\"line\">IntentFilter statusIntentFilter = <span class=\"keyword\">new</span> IntentFilter(Constants.BROADCAST_ACTION);</span><br><span class=\"line\">statusIntentFilter.addCategory(Intent.CATEGORY_DEFAULT);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 用谁来接收（注册receiver）</span></span><br><span class=\"line\">mDownloadStateReceiver = <span class=\"keyword\">new</span> ResponseReceiver();</span><br><span class=\"line\">LocalBroadcastManager.getInstance(<span class=\"keyword\">this</span>).registerReceiver(mDownloadStateReceiver, statusIntentFilter);</span><br></pre></td></tr></table></figure>\n<h3 id=\"点亮屏幕\"><a class=\"markdownIt-Anchor\" href=\"#点亮屏幕\"></a> 点亮屏幕</h3>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">getWindow().addFlags(WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON);</span><br><span class=\"line\"><span class=\"comment\">//清除flag回到正常状态</span></span><br><span class=\"line\">getWindow().clearFlags(WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON)</span><br></pre></td></tr></table></figure>\n<p>也可以AndroidManifest.xml里定义该属性，由于在AndroidManifest里定义的内容不能动态改变。所以设了就不能反悔。</p>\n"},{"title":"chapter-04-best-practices-for-memory","catalog":true,"date":"2016-02-22T09:21:29.000Z","header-img":"/img/06.jpg","_content":"\n# chapter-04-best-practices-for-memory\n\nTags:Training-for-Android-developers\n\n---\n\n## 管理内存\n\nAndroid没有使用Linux中的swap的文件交换区方式。但是还是使用了纯内存paging（以下称内存页）和mmapped（文件内存映射）。为了满足每个app对RAM的需要，Android在进程间共享内存页。\n\n### 共享内存\n\n**通常遵循下面方式实现：**\n\n>* 每一个app的进程都是从一个被叫做Zygote的进程中fork出来的（Android也是基于COW，所以性能还不错）。那么理所当然的继承了父进程内存页。\n    \n具体过程是：\n\n    1、开机后系统会通过init.rc配置（例如小米4：service zygote /system/bin/app_process -Xzygote /system/bin --zygote --start-system-server）先拉起Zygote进程\n    2、这个进程启动后自动加载android框架代码和资源（例如activity themes）\n    3、然后再fork出具体的app进程，那这样一来就可以让所有的android app进程共享框架load的内存资源。\n\n大多数静态数据被映射到进程中。这样让的数据在进程间共享。\n\n    静态数据包括：\n    1、Dalvik 代码 (放在一个预链接好的.odex 文件中以便直接mapping)\n    2、App Resources(它们被组织成资源映射表的结构，然后把APK中的文件做对齐的操作来，以便更容易做内存映射）\n    3、native代码如.so文件。\n\n>* 用户显示的分配内存如：ashmem pmem gralloc等方式。\n    \n如要查看分析共享内存：\nhttp://developer.android.com/tools/debugging/debugging-memory.html\n\n### Android系统对内存的分配和回收\n>* Android虚拟机和java的结构非常类似，主要对象的存储也是在堆上。(不过Android是跑在别人的手机里。所以你不能像服务器随便设置虚拟机堆的各项参数。虚拟机又不是咱们家的，当然不可以这么干)。系统会限制单个应用的堆内存大小。\n\n>* heap的逻辑大小和实际使用的物理内存大小是不相同的。假设共享内存大小是10M，一共有20个Process在共享使用，根据权重，可能认为其中有0.3M才是你的进程所使用的大小。这个实际的值叫PSS（Proportional Set Size）。所以我们只需要查看Total Pss的值就可以知道该应用运行时所占的内存的大小。\n\n>* 系统不会做内存碎片整理，android只会清一下堆的未端不使用的内存。虽然不做碎片整理，但是它会在GC之后，挑出整块不使用的内存页干掉。不过，如果是共有的，很小的内存就不行了。\n\nadb shell dumpsys meminfo com.baidu.vsfinance -d\n\n```bash\nApplications Memory Usage (kB):\nUptime: 18460072 Realtime: 105595846\n\n** MEMINFO in pid 19441 [com.baidu.vsfinance] **\n                   Pss  Private  Private  Swapped     Heap     Heap     Heap\n                 Total    Dirty    Clean    Dirty     Size    Alloc     Free\n                ------   ------   ------   ------   ------   ------   ------\n  Native Heap       24       24        0        0    15920     7033      502\n  Dalvik Heap    20988    20604        0        0    42724    40882     1842\n Dalvik Other     3404     3352        0        0                           \n        Stack      192      192        0        0                           \n    Other dev    12400     9444        4        0                           \n     .so mmap     2527     1436      524        0                           \n    .jar mmap        4        0        4        0                           \n    .apk mmap      344        0      228        0                           \n    .ttf mmap      390        0      136        0                           \n    .dex mmap     3778       72     3324        0                           \n   Other mmap       62       12       36        0                           \n      Unknown     3843     3840        0        0                           \n        TOTAL    47956    38976     4256        0    58644    47915     2344\n \n Objects\n               Views:      263         ViewRootImpl:        6\n         AppContexts:        6           Activities:        3\n              Assets:        5        AssetManagers:        5\n       Local Binders:       19        Proxy Binders:       25\n    Death Recipients:        1\n     OpenSSL Sockets:        0\n \n SQL\n         MEMORY_USED:      291\n  PAGECACHE_OVERFLOW:       77          MALLOC_SIZE:       62\n \n DATABASES\n      pgsz     dbsz   Lookaside(b)          cache  Dbname\n         4       32             45         2/17/3  /data/data/com.baidu.vsfinance/databases/afinal.db\n```\n\n### API获取内存相关信息\n\n除了使用dumpsys命令外，也可以使用ActivityManager类的查看各种内存信息，这个方式好在它可以实时查，另外使用getMemoryClass()可以查看当前系统对单个app的最大内存限制。\n        \n>    在一些特殊的情景下，可以通过在manifest的application标签下添加largeHeap=true的属性来声明一个更大的heap空间。如果这样做你可以通过getLargeMemoryClass())来获取到一个更大的heap size。\n不要轻易的因为你需要使用大量的内存而去请求一个大的heap size。只有当你清楚的知道哪里会使用大量的内存并且为什么这些内存必须被保留时才去使用large heap。\n另外, large heap并不一定能够获取到更大的heap。在某些有严格限制的机器上，large heap的大小和通常的heap size是一样的。因此即使你申请了large heap，你还是应该通过执行getMemoryClass()来检查实际获取到的heap大小。\n\nComponentCallbacks2类有一个onTrimMemory(int)回调，接受的int值表示现在的内存状态。比如ComponentCallbacks2.TRIM_MEMORY_RUNNING_MODERATE表示app正在运行并且不会被列为可杀死的。但是设备此时正运行于低内存状态下，系统开始触发杀死LRU Cache中的Process的机制。\n具体还有很多值，都在：http://developer.android.com/reference/android/content/ComponentCallbacks2.html#onTrimMemory(int)\n\n因为android的内存不像java一样舒爽，所以有些内存数据也要适当关注一下：\n\nEnums often require more than twice as much memory as static constants. You should strictly avoid using enums on Android.\nEvery class in Java (including anonymous inner classes) uses about 500 bytes of code.\nEvery class instance has 12-16 bytes of RAM overhead.\nPutting a single entry into a HashMap requires the allocation of an additional entry object that takes 32 bytes.\n\n>* Enums的内存消耗通常是static constants的2倍。你应该尽量避免在Android上使用enums。\n>* 在Java中的每一个类(包括匿名内部类)都会使用大概500 bytes。\n>* 每一个类的实例花销至少是12-16 bytes。\n>* 往HashMap添加一个entry需要额一个额外占用的32 bytes的entry对象。\n\nOften, developers use abstractions simply as a \"good programming practice,\" because abstractions can improve code flexibility and maintenance. However, abstractions come at a significant cost: generally they require a fair amount more code that needs to be executed, requiring more time and more RAM for that code to be mapped into memory. So if your abstractions aren't supplying a significant benefit, you should avoid them.\n\n>* 更不爽的是，在google文档中居然还明确指出，没有特别明显的优化效果，不要使用抽象。这在设计时不免可惜。\n\n>* 为了降低内存占用，将部分内容放在服务端，同时google推荐使用他们的“homebrew(家酿)”产品protobuf的微缩版nano protobuf。\n\n>* 为了节省资源，google也不建议你使用类似spring的诸如Guice、RoboGuice等依赖注入框架（还有天理吗）。\n\n每次限定使用时，google都非常open的告诉你这个东西好。然后跟一个but:它耗资源。然并卵！\n\n>* ProGuard能够通过移除不需要的代码，重命名类，域与方法等方对代码进行压缩，优化与混淆。使用ProGuard可以使得你的代码更加紧凑，这样能够使用更少mapped代码所需要的RAM。http://developer.android.com/tools/help/proguard.html\n\nzipalign这个东西可以帮你的apk做对齐，这个进内存的效率提升和空间节省都会有的。而且有些图片儿啥的不能做内存mapped。必须要对齐一下。而且Google Play不接受没有经过zipalign的APK。\nhttp://developer.android.com/tools/help/zipalign.html","source":"_posts/chapter-04-best-practices-for-memory.md","raw":"---\ntitle: 'chapter-04-best-practices-for-memory'\ncatalog: true\ndate: 2016-02-22 17:21:29\nheader-img: \"/img/06.jpg\"\ntags: \"android\"\n---\n\n# chapter-04-best-practices-for-memory\n\nTags:Training-for-Android-developers\n\n---\n\n## 管理内存\n\nAndroid没有使用Linux中的swap的文件交换区方式。但是还是使用了纯内存paging（以下称内存页）和mmapped（文件内存映射）。为了满足每个app对RAM的需要，Android在进程间共享内存页。\n\n### 共享内存\n\n**通常遵循下面方式实现：**\n\n>* 每一个app的进程都是从一个被叫做Zygote的进程中fork出来的（Android也是基于COW，所以性能还不错）。那么理所当然的继承了父进程内存页。\n    \n具体过程是：\n\n    1、开机后系统会通过init.rc配置（例如小米4：service zygote /system/bin/app_process -Xzygote /system/bin --zygote --start-system-server）先拉起Zygote进程\n    2、这个进程启动后自动加载android框架代码和资源（例如activity themes）\n    3、然后再fork出具体的app进程，那这样一来就可以让所有的android app进程共享框架load的内存资源。\n\n大多数静态数据被映射到进程中。这样让的数据在进程间共享。\n\n    静态数据包括：\n    1、Dalvik 代码 (放在一个预链接好的.odex 文件中以便直接mapping)\n    2、App Resources(它们被组织成资源映射表的结构，然后把APK中的文件做对齐的操作来，以便更容易做内存映射）\n    3、native代码如.so文件。\n\n>* 用户显示的分配内存如：ashmem pmem gralloc等方式。\n    \n如要查看分析共享内存：\nhttp://developer.android.com/tools/debugging/debugging-memory.html\n\n### Android系统对内存的分配和回收\n>* Android虚拟机和java的结构非常类似，主要对象的存储也是在堆上。(不过Android是跑在别人的手机里。所以你不能像服务器随便设置虚拟机堆的各项参数。虚拟机又不是咱们家的，当然不可以这么干)。系统会限制单个应用的堆内存大小。\n\n>* heap的逻辑大小和实际使用的物理内存大小是不相同的。假设共享内存大小是10M，一共有20个Process在共享使用，根据权重，可能认为其中有0.3M才是你的进程所使用的大小。这个实际的值叫PSS（Proportional Set Size）。所以我们只需要查看Total Pss的值就可以知道该应用运行时所占的内存的大小。\n\n>* 系统不会做内存碎片整理，android只会清一下堆的未端不使用的内存。虽然不做碎片整理，但是它会在GC之后，挑出整块不使用的内存页干掉。不过，如果是共有的，很小的内存就不行了。\n\nadb shell dumpsys meminfo com.baidu.vsfinance -d\n\n```bash\nApplications Memory Usage (kB):\nUptime: 18460072 Realtime: 105595846\n\n** MEMINFO in pid 19441 [com.baidu.vsfinance] **\n                   Pss  Private  Private  Swapped     Heap     Heap     Heap\n                 Total    Dirty    Clean    Dirty     Size    Alloc     Free\n                ------   ------   ------   ------   ------   ------   ------\n  Native Heap       24       24        0        0    15920     7033      502\n  Dalvik Heap    20988    20604        0        0    42724    40882     1842\n Dalvik Other     3404     3352        0        0                           \n        Stack      192      192        0        0                           \n    Other dev    12400     9444        4        0                           \n     .so mmap     2527     1436      524        0                           \n    .jar mmap        4        0        4        0                           \n    .apk mmap      344        0      228        0                           \n    .ttf mmap      390        0      136        0                           \n    .dex mmap     3778       72     3324        0                           \n   Other mmap       62       12       36        0                           \n      Unknown     3843     3840        0        0                           \n        TOTAL    47956    38976     4256        0    58644    47915     2344\n \n Objects\n               Views:      263         ViewRootImpl:        6\n         AppContexts:        6           Activities:        3\n              Assets:        5        AssetManagers:        5\n       Local Binders:       19        Proxy Binders:       25\n    Death Recipients:        1\n     OpenSSL Sockets:        0\n \n SQL\n         MEMORY_USED:      291\n  PAGECACHE_OVERFLOW:       77          MALLOC_SIZE:       62\n \n DATABASES\n      pgsz     dbsz   Lookaside(b)          cache  Dbname\n         4       32             45         2/17/3  /data/data/com.baidu.vsfinance/databases/afinal.db\n```\n\n### API获取内存相关信息\n\n除了使用dumpsys命令外，也可以使用ActivityManager类的查看各种内存信息，这个方式好在它可以实时查，另外使用getMemoryClass()可以查看当前系统对单个app的最大内存限制。\n        \n>    在一些特殊的情景下，可以通过在manifest的application标签下添加largeHeap=true的属性来声明一个更大的heap空间。如果这样做你可以通过getLargeMemoryClass())来获取到一个更大的heap size。\n不要轻易的因为你需要使用大量的内存而去请求一个大的heap size。只有当你清楚的知道哪里会使用大量的内存并且为什么这些内存必须被保留时才去使用large heap。\n另外, large heap并不一定能够获取到更大的heap。在某些有严格限制的机器上，large heap的大小和通常的heap size是一样的。因此即使你申请了large heap，你还是应该通过执行getMemoryClass()来检查实际获取到的heap大小。\n\nComponentCallbacks2类有一个onTrimMemory(int)回调，接受的int值表示现在的内存状态。比如ComponentCallbacks2.TRIM_MEMORY_RUNNING_MODERATE表示app正在运行并且不会被列为可杀死的。但是设备此时正运行于低内存状态下，系统开始触发杀死LRU Cache中的Process的机制。\n具体还有很多值，都在：http://developer.android.com/reference/android/content/ComponentCallbacks2.html#onTrimMemory(int)\n\n因为android的内存不像java一样舒爽，所以有些内存数据也要适当关注一下：\n\nEnums often require more than twice as much memory as static constants. You should strictly avoid using enums on Android.\nEvery class in Java (including anonymous inner classes) uses about 500 bytes of code.\nEvery class instance has 12-16 bytes of RAM overhead.\nPutting a single entry into a HashMap requires the allocation of an additional entry object that takes 32 bytes.\n\n>* Enums的内存消耗通常是static constants的2倍。你应该尽量避免在Android上使用enums。\n>* 在Java中的每一个类(包括匿名内部类)都会使用大概500 bytes。\n>* 每一个类的实例花销至少是12-16 bytes。\n>* 往HashMap添加一个entry需要额一个额外占用的32 bytes的entry对象。\n\nOften, developers use abstractions simply as a \"good programming practice,\" because abstractions can improve code flexibility and maintenance. However, abstractions come at a significant cost: generally they require a fair amount more code that needs to be executed, requiring more time and more RAM for that code to be mapped into memory. So if your abstractions aren't supplying a significant benefit, you should avoid them.\n\n>* 更不爽的是，在google文档中居然还明确指出，没有特别明显的优化效果，不要使用抽象。这在设计时不免可惜。\n\n>* 为了降低内存占用，将部分内容放在服务端，同时google推荐使用他们的“homebrew(家酿)”产品protobuf的微缩版nano protobuf。\n\n>* 为了节省资源，google也不建议你使用类似spring的诸如Guice、RoboGuice等依赖注入框架（还有天理吗）。\n\n每次限定使用时，google都非常open的告诉你这个东西好。然后跟一个but:它耗资源。然并卵！\n\n>* ProGuard能够通过移除不需要的代码，重命名类，域与方法等方对代码进行压缩，优化与混淆。使用ProGuard可以使得你的代码更加紧凑，这样能够使用更少mapped代码所需要的RAM。http://developer.android.com/tools/help/proguard.html\n\nzipalign这个东西可以帮你的apk做对齐，这个进内存的效率提升和空间节省都会有的。而且有些图片儿啥的不能做内存mapped。必须要对齐一下。而且Google Play不接受没有经过zipalign的APK。\nhttp://developer.android.com/tools/help/zipalign.html","slug":"chapter-04-best-practices-for-memory","published":1,"updated":"2017-11-25T06:38:21.372Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjahvvnxy000vpv4ny6xd5ubd","content":"<h1><span id=\"chapter-04-best-practices-for-memory\"> chapter-04-best-practices-for-memory</span></h1>\n<p>Tags:Training-for-Android-developers</p>\n<hr>\n<h2><span id=\"管理内存\"> 管理内存</span></h2>\n<p>Android没有使用Linux中的swap的文件交换区方式。但是还是使用了纯内存paging（以下称内存页）和mmapped（文件内存映射）。为了满足每个app对RAM的需要，Android在进程间共享内存页。</p>\n<h3><span id=\"共享内存\"> 共享内存</span></h3>\n<p><strong>通常遵循下面方式实现：</strong></p>\n<blockquote>\n<ul>\n<li>每一个app的进程都是从一个被叫做Zygote的进程中fork出来的（Android也是基于COW，所以性能还不错）。那么理所当然的继承了父进程内存页。</li>\n</ul>\n</blockquote>\n<p>具体过程是：</p>\n<pre><code>1、开机后系统会通过init.rc配置（例如小米4：service zygote /system/bin/app_process -Xzygote /system/bin --zygote --start-system-server）先拉起Zygote进程\n2、这个进程启动后自动加载android框架代码和资源（例如activity themes）\n3、然后再fork出具体的app进程，那这样一来就可以让所有的android app进程共享框架load的内存资源。\n</code></pre>\n<p>大多数静态数据被映射到进程中。这样让的数据在进程间共享。</p>\n<pre><code>静态数据包括：\n1、Dalvik 代码 (放在一个预链接好的.odex 文件中以便直接mapping)\n2、App Resources(它们被组织成资源映射表的结构，然后把APK中的文件做对齐的操作来，以便更容易做内存映射）\n3、native代码如.so文件。\n</code></pre>\n<blockquote>\n<ul>\n<li>用户显示的分配内存如：ashmem pmem gralloc等方式。</li>\n</ul>\n</blockquote>\n<p>如要查看分析共享内存：<br>\n<a href=\"http://developer.android.com/tools/debugging/debugging-memory.html\" target=\"_blank\" rel=\"noopener\">http://developer.android.com/tools/debugging/debugging-memory.html</a></p>\n<h3><span id=\"android系统对内存的分配和回收\"> Android系统对内存的分配和回收</span></h3>\n<blockquote>\n<ul>\n<li>Android虚拟机和java的结构非常类似，主要对象的存储也是在堆上。(不过Android是跑在别人的手机里。所以你不能像服务器随便设置虚拟机堆的各项参数。虚拟机又不是咱们家的，当然不可以这么干)。系统会限制单个应用的堆内存大小。</li>\n</ul>\n</blockquote>\n<blockquote>\n<ul>\n<li>heap的逻辑大小和实际使用的物理内存大小是不相同的。假设共享内存大小是10M，一共有20个Process在共享使用，根据权重，可能认为其中有0.3M才是你的进程所使用的大小。这个实际的值叫PSS（Proportional Set Size）。所以我们只需要查看Total Pss的值就可以知道该应用运行时所占的内存的大小。</li>\n</ul>\n</blockquote>\n<blockquote>\n<ul>\n<li>系统不会做内存碎片整理，android只会清一下堆的未端不使用的内存。虽然不做碎片整理，但是它会在GC之后，挑出整块不使用的内存页干掉。不过，如果是共有的，很小的内存就不行了。</li>\n</ul>\n</blockquote>\n<p>adb shell dumpsys meminfo com.baidu.vsfinance -d</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Applications Memory Usage (kB):</span><br><span class=\"line\">Uptime: 18460072 Realtime: 105595846</span><br><span class=\"line\"></span><br><span class=\"line\">** MEMINFO <span class=\"keyword\">in</span> pid 19441 [com.baidu.vsfinance] **</span><br><span class=\"line\">                   Pss  Private  Private  Swapped     Heap     Heap     Heap</span><br><span class=\"line\">                 Total    Dirty    Clean    Dirty     Size    Alloc     Free</span><br><span class=\"line\">                ------   ------   ------   ------   ------   ------   ------</span><br><span class=\"line\">  Native Heap       24       24        0        0    15920     7033      502</span><br><span class=\"line\">  Dalvik Heap    20988    20604        0        0    42724    40882     1842</span><br><span class=\"line\"> Dalvik Other     3404     3352        0        0                           </span><br><span class=\"line\">        Stack      192      192        0        0                           </span><br><span class=\"line\">    Other dev    12400     9444        4        0                           </span><br><span class=\"line\">     .so mmap     2527     1436      524        0                           </span><br><span class=\"line\">    .jar mmap        4        0        4        0                           </span><br><span class=\"line\">    .apk mmap      344        0      228        0                           </span><br><span class=\"line\">    .ttf mmap      390        0      136        0                           </span><br><span class=\"line\">    .dex mmap     3778       72     3324        0                           </span><br><span class=\"line\">   Other mmap       62       12       36        0                           </span><br><span class=\"line\">      Unknown     3843     3840        0        0                           </span><br><span class=\"line\">        TOTAL    47956    38976     4256        0    58644    47915     2344</span><br><span class=\"line\"> </span><br><span class=\"line\"> Objects</span><br><span class=\"line\">               Views:      263         ViewRootImpl:        6</span><br><span class=\"line\">         AppContexts:        6           Activities:        3</span><br><span class=\"line\">              Assets:        5        AssetManagers:        5</span><br><span class=\"line\">       Local Binders:       19        Proxy Binders:       25</span><br><span class=\"line\">    Death Recipients:        1</span><br><span class=\"line\">     OpenSSL Sockets:        0</span><br><span class=\"line\"> </span><br><span class=\"line\"> SQL</span><br><span class=\"line\">         MEMORY_USED:      291</span><br><span class=\"line\">  PAGECACHE_OVERFLOW:       77          MALLOC_SIZE:       62</span><br><span class=\"line\"> </span><br><span class=\"line\"> DATABASES</span><br><span class=\"line\">      pgsz     dbsz   Lookaside(b)          cache  Dbname</span><br><span class=\"line\">         4       32             45         2/17/3  /data/data/com.baidu.vsfinance/databases/afinal.db</span><br></pre></td></tr></table></figure>\n<h3><span id=\"api获取内存相关信息\"> API获取内存相关信息</span></h3>\n<p>除了使用dumpsys命令外，也可以使用ActivityManager类的查看各种内存信息，这个方式好在它可以实时查，另外使用getMemoryClass()可以查看当前系统对单个app的最大内存限制。</p>\n<blockquote>\n<p>在一些特殊的情景下，可以通过在manifest的application标签下添加largeHeap=true的属性来声明一个更大的heap空间。如果这样做你可以通过getLargeMemoryClass())来获取到一个更大的heap size。<br>\n不要轻易的因为你需要使用大量的内存而去请求一个大的heap size。只有当你清楚的知道哪里会使用大量的内存并且为什么这些内存必须被保留时才去使用large heap。<br>\n另外, large heap并不一定能够获取到更大的heap。在某些有严格限制的机器上，large heap的大小和通常的heap size是一样的。因此即使你申请了large heap，你还是应该通过执行getMemoryClass()来检查实际获取到的heap大小。</p>\n</blockquote>\n<p>ComponentCallbacks2类有一个onTrimMemory(int)回调，接受的int值表示现在的内存状态。比如ComponentCallbacks2.TRIM_MEMORY_RUNNING_MODERATE表示app正在运行并且不会被列为可杀死的。但是设备此时正运行于低内存状态下，系统开始触发杀死LRU Cache中的Process的机制。<br>\n具体还有很多值，都在：<a href=\"http://developer.android.com/reference/android/content/ComponentCallbacks2.html#onTrimMemory(int)\" target=\"_blank\" rel=\"noopener\">http://developer.android.com/reference/android/content/ComponentCallbacks2.html#onTrimMemory(int)</a></p>\n<p>因为android的内存不像java一样舒爽，所以有些内存数据也要适当关注一下：</p>\n<p>Enums often require more than twice as much memory as static constants. You should strictly avoid using enums on Android.<br>\nEvery class in Java (including anonymous inner classes) uses about 500 bytes of code.<br>\nEvery class instance has 12-16 bytes of RAM overhead.<br>\nPutting a single entry into a HashMap requires the allocation of an additional entry object that takes 32 bytes.</p>\n<blockquote>\n<ul>\n<li>Enums的内存消耗通常是static constants的2倍。你应该尽量避免在Android上使用enums。</li>\n<li>在Java中的每一个类(包括匿名内部类)都会使用大概500 bytes。</li>\n<li>每一个类的实例花销至少是12-16 bytes。</li>\n<li>往HashMap添加一个entry需要额一个额外占用的32 bytes的entry对象。</li>\n</ul>\n</blockquote>\n<p>Often, developers use abstractions simply as a “good programming practice,” because abstractions can improve code flexibility and maintenance. However, abstractions come at a significant cost: generally they require a fair amount more code that needs to be executed, requiring more time and more RAM for that code to be mapped into memory. So if your abstractions aren’t supplying a significant benefit, you should avoid them.</p>\n<blockquote>\n<ul>\n<li>更不爽的是，在google文档中居然还明确指出，没有特别明显的优化效果，不要使用抽象。这在设计时不免可惜。</li>\n</ul>\n</blockquote>\n<blockquote>\n<ul>\n<li>为了降低内存占用，将部分内容放在服务端，同时google推荐使用他们的“homebrew(家酿)”产品protobuf的微缩版nano protobuf。</li>\n</ul>\n</blockquote>\n<blockquote>\n<ul>\n<li>为了节省资源，google也不建议你使用类似spring的诸如Guice、RoboGuice等依赖注入框架（还有天理吗）。</li>\n</ul>\n</blockquote>\n<p>每次限定使用时，google都非常open的告诉你这个东西好。然后跟一个but:它耗资源。然并卵！</p>\n<blockquote>\n<ul>\n<li>ProGuard能够通过移除不需要的代码，重命名类，域与方法等方对代码进行压缩，优化与混淆。使用ProGuard可以使得你的代码更加紧凑，这样能够使用更少mapped代码所需要的RAM。<a href=\"http://developer.android.com/tools/help/proguard.html\" target=\"_blank\" rel=\"noopener\">http://developer.android.com/tools/help/proguard.html</a></li>\n</ul>\n</blockquote>\n<p>zipalign这个东西可以帮你的apk做对齐，这个进内存的效率提升和空间节省都会有的。而且有些图片儿啥的不能做内存mapped。必须要对齐一下。而且Google Play不接受没有经过zipalign的APK。<br>\n<a href=\"http://developer.android.com/tools/help/zipalign.html\" target=\"_blank\" rel=\"noopener\">http://developer.android.com/tools/help/zipalign.html</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"chapter-04-best-practices-for-memory\"><a class=\"markdownIt-Anchor\" href=\"#chapter-04-best-practices-for-memory\"></a> chapter-04-best-practices-for-memory</h1>\n<p>Tags:Training-for-Android-developers</p>\n<hr>\n<h2 id=\"管理内存\"><a class=\"markdownIt-Anchor\" href=\"#管理内存\"></a> 管理内存</h2>\n<p>Android没有使用Linux中的swap的文件交换区方式。但是还是使用了纯内存paging（以下称内存页）和mmapped（文件内存映射）。为了满足每个app对RAM的需要，Android在进程间共享内存页。</p>\n<h3 id=\"共享内存\"><a class=\"markdownIt-Anchor\" href=\"#共享内存\"></a> 共享内存</h3>\n<p><strong>通常遵循下面方式实现：</strong></p>\n<blockquote>\n<ul>\n<li>每一个app的进程都是从一个被叫做Zygote的进程中fork出来的（Android也是基于COW，所以性能还不错）。那么理所当然的继承了父进程内存页。</li>\n</ul>\n</blockquote>\n<p>具体过程是：</p>\n<pre><code>1、开机后系统会通过init.rc配置（例如小米4：service zygote /system/bin/app_process -Xzygote /system/bin --zygote --start-system-server）先拉起Zygote进程\n2、这个进程启动后自动加载android框架代码和资源（例如activity themes）\n3、然后再fork出具体的app进程，那这样一来就可以让所有的android app进程共享框架load的内存资源。\n</code></pre>\n<p>大多数静态数据被映射到进程中。这样让的数据在进程间共享。</p>\n<pre><code>静态数据包括：\n1、Dalvik 代码 (放在一个预链接好的.odex 文件中以便直接mapping)\n2、App Resources(它们被组织成资源映射表的结构，然后把APK中的文件做对齐的操作来，以便更容易做内存映射）\n3、native代码如.so文件。\n</code></pre>\n<blockquote>\n<ul>\n<li>用户显示的分配内存如：ashmem pmem gralloc等方式。</li>\n</ul>\n</blockquote>\n<p>如要查看分析共享内存：<br>\n<a href=\"http://developer.android.com/tools/debugging/debugging-memory.html\" target=\"_blank\" rel=\"noopener\">http://developer.android.com/tools/debugging/debugging-memory.html</a></p>\n<h3 id=\"android系统对内存的分配和回收\"><a class=\"markdownIt-Anchor\" href=\"#android系统对内存的分配和回收\"></a> Android系统对内存的分配和回收</h3>\n<blockquote>\n<ul>\n<li>Android虚拟机和java的结构非常类似，主要对象的存储也是在堆上。(不过Android是跑在别人的手机里。所以你不能像服务器随便设置虚拟机堆的各项参数。虚拟机又不是咱们家的，当然不可以这么干)。系统会限制单个应用的堆内存大小。</li>\n</ul>\n</blockquote>\n<blockquote>\n<ul>\n<li>heap的逻辑大小和实际使用的物理内存大小是不相同的。假设共享内存大小是10M，一共有20个Process在共享使用，根据权重，可能认为其中有0.3M才是你的进程所使用的大小。这个实际的值叫PSS（Proportional Set Size）。所以我们只需要查看Total Pss的值就可以知道该应用运行时所占的内存的大小。</li>\n</ul>\n</blockquote>\n<blockquote>\n<ul>\n<li>系统不会做内存碎片整理，android只会清一下堆的未端不使用的内存。虽然不做碎片整理，但是它会在GC之后，挑出整块不使用的内存页干掉。不过，如果是共有的，很小的内存就不行了。</li>\n</ul>\n</blockquote>\n<p>adb shell dumpsys meminfo com.baidu.vsfinance -d</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Applications Memory Usage (kB):</span><br><span class=\"line\">Uptime: 18460072 Realtime: 105595846</span><br><span class=\"line\"></span><br><span class=\"line\">** MEMINFO <span class=\"keyword\">in</span> pid 19441 [com.baidu.vsfinance] **</span><br><span class=\"line\">                   Pss  Private  Private  Swapped     Heap     Heap     Heap</span><br><span class=\"line\">                 Total    Dirty    Clean    Dirty     Size    Alloc     Free</span><br><span class=\"line\">                ------   ------   ------   ------   ------   ------   ------</span><br><span class=\"line\">  Native Heap       24       24        0        0    15920     7033      502</span><br><span class=\"line\">  Dalvik Heap    20988    20604        0        0    42724    40882     1842</span><br><span class=\"line\"> Dalvik Other     3404     3352        0        0                           </span><br><span class=\"line\">        Stack      192      192        0        0                           </span><br><span class=\"line\">    Other dev    12400     9444        4        0                           </span><br><span class=\"line\">     .so mmap     2527     1436      524        0                           </span><br><span class=\"line\">    .jar mmap        4        0        4        0                           </span><br><span class=\"line\">    .apk mmap      344        0      228        0                           </span><br><span class=\"line\">    .ttf mmap      390        0      136        0                           </span><br><span class=\"line\">    .dex mmap     3778       72     3324        0                           </span><br><span class=\"line\">   Other mmap       62       12       36        0                           </span><br><span class=\"line\">      Unknown     3843     3840        0        0                           </span><br><span class=\"line\">        TOTAL    47956    38976     4256        0    58644    47915     2344</span><br><span class=\"line\"> </span><br><span class=\"line\"> Objects</span><br><span class=\"line\">               Views:      263         ViewRootImpl:        6</span><br><span class=\"line\">         AppContexts:        6           Activities:        3</span><br><span class=\"line\">              Assets:        5        AssetManagers:        5</span><br><span class=\"line\">       Local Binders:       19        Proxy Binders:       25</span><br><span class=\"line\">    Death Recipients:        1</span><br><span class=\"line\">     OpenSSL Sockets:        0</span><br><span class=\"line\"> </span><br><span class=\"line\"> SQL</span><br><span class=\"line\">         MEMORY_USED:      291</span><br><span class=\"line\">  PAGECACHE_OVERFLOW:       77          MALLOC_SIZE:       62</span><br><span class=\"line\"> </span><br><span class=\"line\"> DATABASES</span><br><span class=\"line\">      pgsz     dbsz   Lookaside(b)          cache  Dbname</span><br><span class=\"line\">         4       32             45         2/17/3  /data/data/com.baidu.vsfinance/databases/afinal.db</span><br></pre></td></tr></table></figure>\n<h3 id=\"api获取内存相关信息\"><a class=\"markdownIt-Anchor\" href=\"#api获取内存相关信息\"></a> API获取内存相关信息</h3>\n<p>除了使用dumpsys命令外，也可以使用ActivityManager类的查看各种内存信息，这个方式好在它可以实时查，另外使用getMemoryClass()可以查看当前系统对单个app的最大内存限制。</p>\n<blockquote>\n<p>在一些特殊的情景下，可以通过在manifest的application标签下添加largeHeap=true的属性来声明一个更大的heap空间。如果这样做你可以通过getLargeMemoryClass())来获取到一个更大的heap size。<br>\n不要轻易的因为你需要使用大量的内存而去请求一个大的heap size。只有当你清楚的知道哪里会使用大量的内存并且为什么这些内存必须被保留时才去使用large heap。<br>\n另外, large heap并不一定能够获取到更大的heap。在某些有严格限制的机器上，large heap的大小和通常的heap size是一样的。因此即使你申请了large heap，你还是应该通过执行getMemoryClass()来检查实际获取到的heap大小。</p>\n</blockquote>\n<p>ComponentCallbacks2类有一个onTrimMemory(int)回调，接受的int值表示现在的内存状态。比如ComponentCallbacks2.TRIM_MEMORY_RUNNING_MODERATE表示app正在运行并且不会被列为可杀死的。但是设备此时正运行于低内存状态下，系统开始触发杀死LRU Cache中的Process的机制。<br>\n具体还有很多值，都在：<a href=\"http://developer.android.com/reference/android/content/ComponentCallbacks2.html#onTrimMemory(int)\" target=\"_blank\" rel=\"noopener\">http://developer.android.com/reference/android/content/ComponentCallbacks2.html#onTrimMemory(int)</a></p>\n<p>因为android的内存不像java一样舒爽，所以有些内存数据也要适当关注一下：</p>\n<p>Enums often require more than twice as much memory as static constants. You should strictly avoid using enums on Android.<br>\nEvery class in Java (including anonymous inner classes) uses about 500 bytes of code.<br>\nEvery class instance has 12-16 bytes of RAM overhead.<br>\nPutting a single entry into a HashMap requires the allocation of an additional entry object that takes 32 bytes.</p>\n<blockquote>\n<ul>\n<li>Enums的内存消耗通常是static constants的2倍。你应该尽量避免在Android上使用enums。</li>\n<li>在Java中的每一个类(包括匿名内部类)都会使用大概500 bytes。</li>\n<li>每一个类的实例花销至少是12-16 bytes。</li>\n<li>往HashMap添加一个entry需要额一个额外占用的32 bytes的entry对象。</li>\n</ul>\n</blockquote>\n<p>Often, developers use abstractions simply as a “good programming practice,” because abstractions can improve code flexibility and maintenance. However, abstractions come at a significant cost: generally they require a fair amount more code that needs to be executed, requiring more time and more RAM for that code to be mapped into memory. So if your abstractions aren’t supplying a significant benefit, you should avoid them.</p>\n<blockquote>\n<ul>\n<li>更不爽的是，在google文档中居然还明确指出，没有特别明显的优化效果，不要使用抽象。这在设计时不免可惜。</li>\n</ul>\n</blockquote>\n<blockquote>\n<ul>\n<li>为了降低内存占用，将部分内容放在服务端，同时google推荐使用他们的“homebrew(家酿)”产品protobuf的微缩版nano protobuf。</li>\n</ul>\n</blockquote>\n<blockquote>\n<ul>\n<li>为了节省资源，google也不建议你使用类似spring的诸如Guice、RoboGuice等依赖注入框架（还有天理吗）。</li>\n</ul>\n</blockquote>\n<p>每次限定使用时，google都非常open的告诉你这个东西好。然后跟一个but:它耗资源。然并卵！</p>\n<blockquote>\n<ul>\n<li>ProGuard能够通过移除不需要的代码，重命名类，域与方法等方对代码进行压缩，优化与混淆。使用ProGuard可以使得你的代码更加紧凑，这样能够使用更少mapped代码所需要的RAM。<a href=\"http://developer.android.com/tools/help/proguard.html\" target=\"_blank\" rel=\"noopener\">http://developer.android.com/tools/help/proguard.html</a></li>\n</ul>\n</blockquote>\n<p>zipalign这个东西可以帮你的apk做对齐，这个进内存的效率提升和空间节省都会有的。而且有些图片儿啥的不能做内存mapped。必须要对齐一下。而且Google Play不接受没有经过zipalign的APK。<br>\n<a href=\"http://developer.android.com/tools/help/zipalign.html\" target=\"_blank\" rel=\"noopener\">http://developer.android.com/tools/help/zipalign.html</a></p>\n"},{"title":"书法基础理论","catalog":true,"date":"2017-11-22T09:21:29.000Z","subtitle":"聚焦王羲之","header-img":"/img/03.jpg","_content":"\n# 1 基础理论\n\n标签： 书法\n\n---\n\n## 三种字体\n就汉字而论字体，有三种不同的含义：\n\n* 一指文字的形体叫字体，如：篆字，隶字，草字。汉字有篆隶楷行草5种字体。\n* 二指书写的字体叫书体，篆书中的“玉箸篆”，线条细的“铁线篆”，又比如英文里边，可以写出各种书体，在电脑中我们称为字型。主要书体有大篆，小篆，刻符，虫书，署书，殳书，摹印，隶书。\n* 三指书法家的字体叫书风。颜体、柳体。\n\n## 什么是书法\n书写某一个字体，并不是书法。 \n> 书写：结构对不对 \n书法：形体美不美\n\n\n## 学书法从哪里入手\n古人学书法，先求笔法。\n笔法是有共性的。\n王羲之笔法是典范。\n# 聚焦王羲之\n\n![image_1bgaphumq1m1ucao1hdrr2q19s013.png-207.7kB][1]\n王羲之笔法不外传，智永之前，是家族传授，不授外人，智永是王羲之的第七代孙，他本身是杰出的书法家，光是《真草千字文》就写了八百本。智永之后，才开始师徒传授。\n\n![image_1bgapg3a8cijuqhc56ra11hafm.png-219.5kB][2]\n\n韩方明记录下了王羲之家族笔法：**而至张旭始弘八法，次演五势，更备九用，则万字无不该于此，墨道之妙，无不由之以成也。**\n\n张旭讲授笔法，有四个内容，学书法，就是要弄清楚这些最重要的内容，《玉堂禁经》中记载了韩方明所提及的五势、九用：\n>* 五执笔\n>* 永字八法\n>* 五势\n>* 九用\n\n## 书法三要素\n###书法第一个要素是用笔\n用笔分为执笔和用锋。 用笔调锋习惯上称为**“小圈”**。\n九用和五执笔就是讲如何用笔，九用讲如何运转笔锋，五执笔就是执管、族（CU2）管、撮(chuo1)管、握管、搦(ni4)管。执管最常用，其他不建议。\n\n所谓九用，就是九种用锋方法。\n一曰顿笔，\n二曰挫笔，\n三曰驭锋，\n四曰蹲锋，\n五曰【足存】锋，\n六曰衄锋（nu4），\n七曰趯(yue4)锋，\n八曰按锋，\n九曰揭笔。\n\n**九用可以分为两类：挫笔和趯锋是书写动作，其他都是调锋动作。毛笔和硬笔不同，时时会散，会扭起来，所以要一边写，一边调锋。调锋以后，笔锋就顺了。**\n\n### 第二个书法要素是识势\n点画的姿态，取决于笔锋的走势。        \n变化姿态，只要改变走势就可以了。\n 1.单一笔势。永字八法是取一个“永”为例子，把它拆开，就是八个单一笔势。在书法中各有名称，这是最简也是最基本的笔势。\n2.在书法中，还有复合笔势，由单一笔势所组成，用处非常之大。复合笔势。所谓五势，就是五种复合笔势。\n![image_1bga21fbckg11eq4r1lc2anvu2a.png-56.9kB][3]\n复合笔势是单一笔势的组合。比如横画加竖画，就成为一个复合笔势。称为曲尺势。举例：王羲之《二谢贴》。\n\n![image_1bga23j78pge1v721lst1m871b612n.png-86.1kB][4]\n交争势，这是撇捺的结合。看起来好象一个“人”字。王羲之《丧乱贴》中有一个“哀”字，这个“哀”的最后，就是一个交争势。\n\n![image_1bga26eiq1dlt19os1a2d1krsf033h.png-104.7kB][5]\n飞带势，两撇一捺，这是非常有用的笔势。王羲之《丧乱贴》中一个“复”字，可以看到，最后他就写了一个飞带势。\n\n![image_1bga27o1v18601uic1071asa15603u.png-101.1kB][6]\n顾盼势，一共三笔，先写中间一笔，然后左右两笔，看起来好像一个“小”字。举例来说，王羲之《兰亭序》中有一个“丝”字，最后，用了顾盼势。\n\n所谓识势，就是懂得笔锋的走势\n永字八法，包括八个单一笔势\n笔锋行走的路线，习惯上称为大圈。\n\n### 书法第三个要素是裹束\n用笔调锋是小圈，笔锋走势是大圈，裹束就是小圈加大圈。\n\n禇遂良这个“沉”字，在书法中是分为三个复合笔势。沉的三点水，名字叫散水势，右旁的上面，称为幂头势。右旁的下面是凤翅势。\n![image_1bga2io1holj1arp9ci11im13dn4b.png-169.4kB][7]\n\n这三个笔势写出来之后，只要加以裹束，就组成了“沉”字。\n\n> - 书法三要素用笔、 识势、 裹束；    \n - 用笔：五执笔+九用。（小圈）    \n - 识势：永字八法+五势。（大圈）    \n - 裹束：大圈+小圈。\n\n\n  [1]: http://static.zybuluo.com/allon6/q5r5fyfz8w1dxoxm6d7uu5my/image_1bgaphumq1m1ucao1hdrr2q19s013.png\n  [2]: http://static.zybuluo.com/allon6/of7il599il0n8ttmwtrrpkvz/image_1bgapg3a8cijuqhc56ra11hafm.png\n  [3]: http://static.zybuluo.com/allon6/4t6dplscjoigxs1c1vsakst2/image_1bga21fbckg11eq4r1lc2anvu2a.png\n  [4]: http://static.zybuluo.com/allon6/vjtxvijycsmzsgpeb5x2fdk6/image_1bga23j78pge1v721lst1m871b612n.png\n  [5]: http://static.zybuluo.com/allon6/0sk1yvsbqs06gkf3ipibtg6g/image_1bga26eiq1dlt19os1a2d1krsf033h.png\n  [6]: http://static.zybuluo.com/allon6/0vah11z71jpgzoan5pwhl5vc/image_1bga27o1v18601uic1071asa15603u.png\n  [7]: http://static.zybuluo.com/allon6/sv4h4nnyuigigt2da0xyw4yi/image_1bga2io1holj1arp9ci11im13dn4b.png\n\n\n","source":"_posts/书法基础理论.md","raw":"---\ntitle: 书法基础理论\ncatalog: true\ndate: 2017-11-22 17:21:29\nsubtitle: \"聚焦王羲之\"\nheader-img: \"/img/03.jpg\"\ntags: \"书法\"\n---\n\n# 1 基础理论\n\n标签： 书法\n\n---\n\n## 三种字体\n就汉字而论字体，有三种不同的含义：\n\n* 一指文字的形体叫字体，如：篆字，隶字，草字。汉字有篆隶楷行草5种字体。\n* 二指书写的字体叫书体，篆书中的“玉箸篆”，线条细的“铁线篆”，又比如英文里边，可以写出各种书体，在电脑中我们称为字型。主要书体有大篆，小篆，刻符，虫书，署书，殳书，摹印，隶书。\n* 三指书法家的字体叫书风。颜体、柳体。\n\n## 什么是书法\n书写某一个字体，并不是书法。 \n> 书写：结构对不对 \n书法：形体美不美\n\n\n## 学书法从哪里入手\n古人学书法，先求笔法。\n笔法是有共性的。\n王羲之笔法是典范。\n# 聚焦王羲之\n\n![image_1bgaphumq1m1ucao1hdrr2q19s013.png-207.7kB][1]\n王羲之笔法不外传，智永之前，是家族传授，不授外人，智永是王羲之的第七代孙，他本身是杰出的书法家，光是《真草千字文》就写了八百本。智永之后，才开始师徒传授。\n\n![image_1bgapg3a8cijuqhc56ra11hafm.png-219.5kB][2]\n\n韩方明记录下了王羲之家族笔法：**而至张旭始弘八法，次演五势，更备九用，则万字无不该于此，墨道之妙，无不由之以成也。**\n\n张旭讲授笔法，有四个内容，学书法，就是要弄清楚这些最重要的内容，《玉堂禁经》中记载了韩方明所提及的五势、九用：\n>* 五执笔\n>* 永字八法\n>* 五势\n>* 九用\n\n## 书法三要素\n###书法第一个要素是用笔\n用笔分为执笔和用锋。 用笔调锋习惯上称为**“小圈”**。\n九用和五执笔就是讲如何用笔，九用讲如何运转笔锋，五执笔就是执管、族（CU2）管、撮(chuo1)管、握管、搦(ni4)管。执管最常用，其他不建议。\n\n所谓九用，就是九种用锋方法。\n一曰顿笔，\n二曰挫笔，\n三曰驭锋，\n四曰蹲锋，\n五曰【足存】锋，\n六曰衄锋（nu4），\n七曰趯(yue4)锋，\n八曰按锋，\n九曰揭笔。\n\n**九用可以分为两类：挫笔和趯锋是书写动作，其他都是调锋动作。毛笔和硬笔不同，时时会散，会扭起来，所以要一边写，一边调锋。调锋以后，笔锋就顺了。**\n\n### 第二个书法要素是识势\n点画的姿态，取决于笔锋的走势。        \n变化姿态，只要改变走势就可以了。\n 1.单一笔势。永字八法是取一个“永”为例子，把它拆开，就是八个单一笔势。在书法中各有名称，这是最简也是最基本的笔势。\n2.在书法中，还有复合笔势，由单一笔势所组成，用处非常之大。复合笔势。所谓五势，就是五种复合笔势。\n![image_1bga21fbckg11eq4r1lc2anvu2a.png-56.9kB][3]\n复合笔势是单一笔势的组合。比如横画加竖画，就成为一个复合笔势。称为曲尺势。举例：王羲之《二谢贴》。\n\n![image_1bga23j78pge1v721lst1m871b612n.png-86.1kB][4]\n交争势，这是撇捺的结合。看起来好象一个“人”字。王羲之《丧乱贴》中有一个“哀”字，这个“哀”的最后，就是一个交争势。\n\n![image_1bga26eiq1dlt19os1a2d1krsf033h.png-104.7kB][5]\n飞带势，两撇一捺，这是非常有用的笔势。王羲之《丧乱贴》中一个“复”字，可以看到，最后他就写了一个飞带势。\n\n![image_1bga27o1v18601uic1071asa15603u.png-101.1kB][6]\n顾盼势，一共三笔，先写中间一笔，然后左右两笔，看起来好像一个“小”字。举例来说，王羲之《兰亭序》中有一个“丝”字，最后，用了顾盼势。\n\n所谓识势，就是懂得笔锋的走势\n永字八法，包括八个单一笔势\n笔锋行走的路线，习惯上称为大圈。\n\n### 书法第三个要素是裹束\n用笔调锋是小圈，笔锋走势是大圈，裹束就是小圈加大圈。\n\n禇遂良这个“沉”字，在书法中是分为三个复合笔势。沉的三点水，名字叫散水势，右旁的上面，称为幂头势。右旁的下面是凤翅势。\n![image_1bga2io1holj1arp9ci11im13dn4b.png-169.4kB][7]\n\n这三个笔势写出来之后，只要加以裹束，就组成了“沉”字。\n\n> - 书法三要素用笔、 识势、 裹束；    \n - 用笔：五执笔+九用。（小圈）    \n - 识势：永字八法+五势。（大圈）    \n - 裹束：大圈+小圈。\n\n\n  [1]: http://static.zybuluo.com/allon6/q5r5fyfz8w1dxoxm6d7uu5my/image_1bgaphumq1m1ucao1hdrr2q19s013.png\n  [2]: http://static.zybuluo.com/allon6/of7il599il0n8ttmwtrrpkvz/image_1bgapg3a8cijuqhc56ra11hafm.png\n  [3]: http://static.zybuluo.com/allon6/4t6dplscjoigxs1c1vsakst2/image_1bga21fbckg11eq4r1lc2anvu2a.png\n  [4]: http://static.zybuluo.com/allon6/vjtxvijycsmzsgpeb5x2fdk6/image_1bga23j78pge1v721lst1m871b612n.png\n  [5]: http://static.zybuluo.com/allon6/0sk1yvsbqs06gkf3ipibtg6g/image_1bga26eiq1dlt19os1a2d1krsf033h.png\n  [6]: http://static.zybuluo.com/allon6/0vah11z71jpgzoan5pwhl5vc/image_1bga27o1v18601uic1071asa15603u.png\n  [7]: http://static.zybuluo.com/allon6/sv4h4nnyuigigt2da0xyw4yi/image_1bga2io1holj1arp9ci11im13dn4b.png\n\n\n","slug":"书法基础理论","published":1,"updated":"2017-11-22T10:40:14.149Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjahvvnxz000xpv4nf6tcx9bj","content":"<h1><span id=\"1-基础理论\"> 1 基础理论</span></h1>\n<p>标签： 书法</p>\n<hr>\n<h2><span id=\"三种字体\"> 三种字体</span></h2>\n<p>就汉字而论字体，有三种不同的含义：</p>\n<ul>\n<li>一指文字的形体叫字体，如：篆字，隶字，草字。汉字有篆隶楷行草5种字体。</li>\n<li>二指书写的字体叫书体，篆书中的“玉箸篆”，线条细的“铁线篆”，又比如英文里边，可以写出各种书体，在电脑中我们称为字型。主要书体有大篆，小篆，刻符，虫书，署书，殳书，摹印，隶书。</li>\n<li>三指书法家的字体叫书风。颜体、柳体。</li>\n</ul>\n<h2><span id=\"什么是书法\"> 什么是书法</span></h2>\n<p>书写某一个字体，并不是书法。</p>\n<blockquote>\n<p>书写：结构对不对 <br>\n书法：形体美不美</p>\n</blockquote>\n<h2><span id=\"学书法从哪里入手\"> 学书法从哪里入手</span></h2>\n<p>古人学书法，先求笔法。<br>\n笔法是有共性的。<br>\n王羲之笔法是典范。</p>\n<h1><span id=\"聚焦王羲之\"> 聚焦王羲之</span></h1>\n<p><img src=\"http://static.zybuluo.com/allon6/q5r5fyfz8w1dxoxm6d7uu5my/image_1bgaphumq1m1ucao1hdrr2q19s013.png\" alt=\"image_1bgaphumq1m1ucao1hdrr2q19s013.png-207.7kB\"><br>\n王羲之笔法不外传，智永之前，是家族传授，不授外人，智永是王羲之的第七代孙，他本身是杰出的书法家，光是《真草千字文》就写了八百本。智永之后，才开始师徒传授。</p>\n<p><img src=\"http://static.zybuluo.com/allon6/of7il599il0n8ttmwtrrpkvz/image_1bgapg3a8cijuqhc56ra11hafm.png\" alt=\"image_1bgapg3a8cijuqhc56ra11hafm.png-219.5kB\"></p>\n<p>韩方明记录下了王羲之家族笔法：<strong>而至张旭始弘八法，次演五势，更备九用，则万字无不该于此，墨道之妙，无不由之以成也。</strong></p>\n<p>张旭讲授笔法，有四个内容，学书法，就是要弄清楚这些最重要的内容，《玉堂禁经》中记载了韩方明所提及的五势、九用：</p>\n<blockquote>\n<ul>\n<li>五执笔</li>\n<li>永字八法</li>\n<li>五势</li>\n<li>九用</li>\n</ul>\n</blockquote>\n<h2><span id=\"书法三要素\"> 书法三要素</span></h2>\n<p>###书法第一个要素是用笔<br>\n用笔分为执笔和用锋。 用笔调锋习惯上称为**“小圈”**。<br>\n九用和五执笔就是讲如何用笔，九用讲如何运转笔锋，五执笔就是执管、族（CU2）管、撮(chuo1)管、握管、搦(ni4)管。执管最常用，其他不建议。</p>\n<p>所谓九用，就是九种用锋方法。<br>\n一曰顿笔，<br>\n二曰挫笔，<br>\n三曰驭锋，<br>\n四曰蹲锋，<br>\n五曰【足存】锋，<br>\n六曰衄锋（nu4），<br>\n七曰趯(yue4)锋，<br>\n八曰按锋，<br>\n九曰揭笔。</p>\n<p><strong>九用可以分为两类：挫笔和趯锋是书写动作，其他都是调锋动作。毛笔和硬笔不同，时时会散，会扭起来，所以要一边写，一边调锋。调锋以后，笔锋就顺了。</strong></p>\n<h3><span id=\"第二个书法要素是识势\"> 第二个书法要素是识势</span></h3>\n<p>点画的姿态，取决于笔锋的走势。        <br>\n变化姿态，只要改变走势就可以了。<br>\n1.单一笔势。永字八法是取一个“永”为例子，把它拆开，就是八个单一笔势。在书法中各有名称，这是最简也是最基本的笔势。<br>\n2.在书法中，还有复合笔势，由单一笔势所组成，用处非常之大。复合笔势。所谓五势，就是五种复合笔势。<br>\n<img src=\"http://static.zybuluo.com/allon6/4t6dplscjoigxs1c1vsakst2/image_1bga21fbckg11eq4r1lc2anvu2a.png\" alt=\"image_1bga21fbckg11eq4r1lc2anvu2a.png-56.9kB\"><br>\n复合笔势是单一笔势的组合。比如横画加竖画，就成为一个复合笔势。称为曲尺势。举例：王羲之《二谢贴》。</p>\n<p><img src=\"http://static.zybuluo.com/allon6/vjtxvijycsmzsgpeb5x2fdk6/image_1bga23j78pge1v721lst1m871b612n.png\" alt=\"image_1bga23j78pge1v721lst1m871b612n.png-86.1kB\"><br>\n交争势，这是撇捺的结合。看起来好象一个“人”字。王羲之《丧乱贴》中有一个“哀”字，这个“哀”的最后，就是一个交争势。</p>\n<p><img src=\"http://static.zybuluo.com/allon6/0sk1yvsbqs06gkf3ipibtg6g/image_1bga26eiq1dlt19os1a2d1krsf033h.png\" alt=\"image_1bga26eiq1dlt19os1a2d1krsf033h.png-104.7kB\"><br>\n飞带势，两撇一捺，这是非常有用的笔势。王羲之《丧乱贴》中一个“复”字，可以看到，最后他就写了一个飞带势。</p>\n<p><img src=\"http://static.zybuluo.com/allon6/0vah11z71jpgzoan5pwhl5vc/image_1bga27o1v18601uic1071asa15603u.png\" alt=\"image_1bga27o1v18601uic1071asa15603u.png-101.1kB\"><br>\n顾盼势，一共三笔，先写中间一笔，然后左右两笔，看起来好像一个“小”字。举例来说，王羲之《兰亭序》中有一个“丝”字，最后，用了顾盼势。</p>\n<p>所谓识势，就是懂得笔锋的走势<br>\n永字八法，包括八个单一笔势<br>\n笔锋行走的路线，习惯上称为大圈。</p>\n<h3><span id=\"书法第三个要素是裹束\"> 书法第三个要素是裹束</span></h3>\n<p>用笔调锋是小圈，笔锋走势是大圈，裹束就是小圈加大圈。</p>\n<p>禇遂良这个“沉”字，在书法中是分为三个复合笔势。沉的三点水，名字叫散水势，右旁的上面，称为幂头势。右旁的下面是凤翅势。<br>\n<img src=\"http://static.zybuluo.com/allon6/sv4h4nnyuigigt2da0xyw4yi/image_1bga2io1holj1arp9ci11im13dn4b.png\" alt=\"image_1bga2io1holj1arp9ci11im13dn4b.png-169.4kB\"></p>\n<p>这三个笔势写出来之后，只要加以裹束，就组成了“沉”字。</p>\n<blockquote>\n<ul>\n<li>书法三要素用笔、 识势、 裹束；</li>\n</ul>\n</blockquote>\n<ul>\n<li>用笔：五执笔+九用。（小圈）</li>\n<li>识势：永字八法+五势。（大圈）</li>\n<li>裹束：大圈+小圈。</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"1-基础理论\"><a class=\"markdownIt-Anchor\" href=\"#1-基础理论\"></a> 1 基础理论</h1>\n<p>标签： 书法</p>\n<hr>\n<h2 id=\"三种字体\"><a class=\"markdownIt-Anchor\" href=\"#三种字体\"></a> 三种字体</h2>\n<p>就汉字而论字体，有三种不同的含义：</p>\n<ul>\n<li>一指文字的形体叫字体，如：篆字，隶字，草字。汉字有篆隶楷行草5种字体。</li>\n<li>二指书写的字体叫书体，篆书中的“玉箸篆”，线条细的“铁线篆”，又比如英文里边，可以写出各种书体，在电脑中我们称为字型。主要书体有大篆，小篆，刻符，虫书，署书，殳书，摹印，隶书。</li>\n<li>三指书法家的字体叫书风。颜体、柳体。</li>\n</ul>\n<h2 id=\"什么是书法\"><a class=\"markdownIt-Anchor\" href=\"#什么是书法\"></a> 什么是书法</h2>\n<p>书写某一个字体，并不是书法。</p>\n<blockquote>\n<p>书写：结构对不对 <br>\n书法：形体美不美</p>\n</blockquote>\n<h2 id=\"学书法从哪里入手\"><a class=\"markdownIt-Anchor\" href=\"#学书法从哪里入手\"></a> 学书法从哪里入手</h2>\n<p>古人学书法，先求笔法。<br>\n笔法是有共性的。<br>\n王羲之笔法是典范。</p>\n<h1 id=\"聚焦王羲之\"><a class=\"markdownIt-Anchor\" href=\"#聚焦王羲之\"></a> 聚焦王羲之</h1>\n<p><img src=\"http://static.zybuluo.com/allon6/q5r5fyfz8w1dxoxm6d7uu5my/image_1bgaphumq1m1ucao1hdrr2q19s013.png\" alt=\"image_1bgaphumq1m1ucao1hdrr2q19s013.png-207.7kB\"><br>\n王羲之笔法不外传，智永之前，是家族传授，不授外人，智永是王羲之的第七代孙，他本身是杰出的书法家，光是《真草千字文》就写了八百本。智永之后，才开始师徒传授。</p>\n<p><img src=\"http://static.zybuluo.com/allon6/of7il599il0n8ttmwtrrpkvz/image_1bgapg3a8cijuqhc56ra11hafm.png\" alt=\"image_1bgapg3a8cijuqhc56ra11hafm.png-219.5kB\"></p>\n<p>韩方明记录下了王羲之家族笔法：<strong>而至张旭始弘八法，次演五势，更备九用，则万字无不该于此，墨道之妙，无不由之以成也。</strong></p>\n<p>张旭讲授笔法，有四个内容，学书法，就是要弄清楚这些最重要的内容，《玉堂禁经》中记载了韩方明所提及的五势、九用：</p>\n<blockquote>\n<ul>\n<li>五执笔</li>\n<li>永字八法</li>\n<li>五势</li>\n<li>九用</li>\n</ul>\n</blockquote>\n<h2 id=\"书法三要素\"><a class=\"markdownIt-Anchor\" href=\"#书法三要素\"></a> 书法三要素</h2>\n<p>###书法第一个要素是用笔<br>\n用笔分为执笔和用锋。 用笔调锋习惯上称为**“小圈”**。<br>\n九用和五执笔就是讲如何用笔，九用讲如何运转笔锋，五执笔就是执管、族（CU2）管、撮(chuo1)管、握管、搦(ni4)管。执管最常用，其他不建议。</p>\n<p>所谓九用，就是九种用锋方法。<br>\n一曰顿笔，<br>\n二曰挫笔，<br>\n三曰驭锋，<br>\n四曰蹲锋，<br>\n五曰【足存】锋，<br>\n六曰衄锋（nu4），<br>\n七曰趯(yue4)锋，<br>\n八曰按锋，<br>\n九曰揭笔。</p>\n<p><strong>九用可以分为两类：挫笔和趯锋是书写动作，其他都是调锋动作。毛笔和硬笔不同，时时会散，会扭起来，所以要一边写，一边调锋。调锋以后，笔锋就顺了。</strong></p>\n<h3 id=\"第二个书法要素是识势\"><a class=\"markdownIt-Anchor\" href=\"#第二个书法要素是识势\"></a> 第二个书法要素是识势</h3>\n<p>点画的姿态，取决于笔锋的走势。        <br>\n变化姿态，只要改变走势就可以了。<br>\n1.单一笔势。永字八法是取一个“永”为例子，把它拆开，就是八个单一笔势。在书法中各有名称，这是最简也是最基本的笔势。<br>\n2.在书法中，还有复合笔势，由单一笔势所组成，用处非常之大。复合笔势。所谓五势，就是五种复合笔势。<br>\n<img src=\"http://static.zybuluo.com/allon6/4t6dplscjoigxs1c1vsakst2/image_1bga21fbckg11eq4r1lc2anvu2a.png\" alt=\"image_1bga21fbckg11eq4r1lc2anvu2a.png-56.9kB\"><br>\n复合笔势是单一笔势的组合。比如横画加竖画，就成为一个复合笔势。称为曲尺势。举例：王羲之《二谢贴》。</p>\n<p><img src=\"http://static.zybuluo.com/allon6/vjtxvijycsmzsgpeb5x2fdk6/image_1bga23j78pge1v721lst1m871b612n.png\" alt=\"image_1bga23j78pge1v721lst1m871b612n.png-86.1kB\"><br>\n交争势，这是撇捺的结合。看起来好象一个“人”字。王羲之《丧乱贴》中有一个“哀”字，这个“哀”的最后，就是一个交争势。</p>\n<p><img src=\"http://static.zybuluo.com/allon6/0sk1yvsbqs06gkf3ipibtg6g/image_1bga26eiq1dlt19os1a2d1krsf033h.png\" alt=\"image_1bga26eiq1dlt19os1a2d1krsf033h.png-104.7kB\"><br>\n飞带势，两撇一捺，这是非常有用的笔势。王羲之《丧乱贴》中一个“复”字，可以看到，最后他就写了一个飞带势。</p>\n<p><img src=\"http://static.zybuluo.com/allon6/0vah11z71jpgzoan5pwhl5vc/image_1bga27o1v18601uic1071asa15603u.png\" alt=\"image_1bga27o1v18601uic1071asa15603u.png-101.1kB\"><br>\n顾盼势，一共三笔，先写中间一笔，然后左右两笔，看起来好像一个“小”字。举例来说，王羲之《兰亭序》中有一个“丝”字，最后，用了顾盼势。</p>\n<p>所谓识势，就是懂得笔锋的走势<br>\n永字八法，包括八个单一笔势<br>\n笔锋行走的路线，习惯上称为大圈。</p>\n<h3 id=\"书法第三个要素是裹束\"><a class=\"markdownIt-Anchor\" href=\"#书法第三个要素是裹束\"></a> 书法第三个要素是裹束</h3>\n<p>用笔调锋是小圈，笔锋走势是大圈，裹束就是小圈加大圈。</p>\n<p>禇遂良这个“沉”字，在书法中是分为三个复合笔势。沉的三点水，名字叫散水势，右旁的上面，称为幂头势。右旁的下面是凤翅势。<br>\n<img src=\"http://static.zybuluo.com/allon6/sv4h4nnyuigigt2da0xyw4yi/image_1bga2io1holj1arp9ci11im13dn4b.png\" alt=\"image_1bga2io1holj1arp9ci11im13dn4b.png-169.4kB\"></p>\n<p>这三个笔势写出来之后，只要加以裹束，就组成了“沉”字。</p>\n<blockquote>\n<ul>\n<li>书法三要素用笔、 识势、 裹束；</li>\n</ul>\n</blockquote>\n<ul>\n<li>用笔：五执笔+九用。（小圈）</li>\n<li>识势：永字八法+五势。（大圈）</li>\n<li>裹束：大圈+小圈。</li>\n</ul>\n"},{"title":"书法工具","catalog":true,"date":"2017-11-22T09:21:29.000Z","subtitle":"笔墨纸砚","header-img":"/img/03.jpg","_content":"\n# 2 工具\n\n标签： 书法\n\n---\n## 认识毛笔\n#### 外扎式\n    最简单最原始的作法。早期的毛笔好象扫帚。\n#### 夹扎式\n    后来就聪明点了，把笔杆一头劈开，把笔毛夹在里面了。\n    这样一改进，笔毛就靠在一起了，也就是说笔头中间不是空的了。\n#### 插入式\n    当时还没有普遍用竹管，笔杆普遍比较细，所以要在笔杆的一端，钻一个洞以纳入笔头。\n    这个洞，我们称为毛腔。\n   \n    要注意，这时候开始先制作笔头了，把笔头的根部扎紧，然后塞入毛腔之中。\n    \n    先做笔头，这在制笔工艺上是重大的进步。但是这种笔没有笔锋，或者说没有一个锐利的尖锋。\n    \n    李柏文书，或者陆机《平复贴》，可以看到，他们所使用的毛笔，没有一个尖锋。\n    这在书法上用起来还是不能如意。\n#### 心副式\n    所以后来，又有了重大的改进，那就是在笔头中间加入一个笔心。\n    笔心是用硬毫做的，有弹性又尖锐，保证有尖锋。笔心的四围再加毛，这我们就称为副毫。\n### 韦诞笔\n真正的书法用笔，称之为有心三副二毫笔。产生于大概是汉末魏晋时期，以韦诞为代表人物。那末这里有四个名词术语：韦诞，有心，三副，二毫。我下面解释一下。\n![image_1bgaqm3nmjqp14ah1b5118cl18fh9.png-114.1kB][1]\n\n![image_1bgaqp6dn16bg1iun1k851b58mdhm.png-59.6kB][2]\n\n#### 二毫\n笔毛分两种。健者为毫，弱者为毳（cuì）。毳就是短毛、弱毛、软毛。好的毛笔，是利用两种毛，一刚一柔，搭配制成。\n古人认为，刚健的毛，最佳的就是野兔毛。通常所说的兔毫，就是野兔背脊上的毛。而且一定要秋天，最好就农历八月所新换的毛，那是最好的。但是要注意兔毫有好几种，最上等的是紫色的，所以我们又叫紫毫。也有杂色的兔毫，比如说黑尖兔毫，颜色就比较杂一些。\n软毛最常用的就是羊毫。羊身上不同的部位，毛的质量也不同，浙江湖州的羊毛，是很适宜做毛笔的，这是选好，不理好的羊毛，就可以做毛笔了。\n用一刚一柔，两种毛做笔，称为叫兼毫笔。\n### 散卓笔(宋代以后)\n韦诞笔好！但韦诞笔制作复杂，成本高。到宋代，就开始流行一种制作简化的毛笔，叫做散卓笔。\n就是解散原来韦诞笔的小笔心，把中心的硬毛和一副、二副的软毛混合在一起，形成一个大笔心，取消了二副，就是取消了墨池，所以散卓笔是没有墨池功能的。简言之：散卓笔的结构，是一心一副，心大，被薄。这种笔，在工艺制作上要简单得多。**现在市场上所卖的毛笔，大多数都是散卓笔。**\n### 用毫范围扩大(宋代以后)\n>* 宋以后不止于用兔毫、羊毫为主，包括：\n    * 狼毫，狼毫刚性不及兔毫，狼是黄鼠狼，是取自黄鼠狼的尾巴，“正冬北地狼毫”，那意思就是冬天取自北方的黄鼠狼毛。\n    * 山马，现在也经常看到山马笔。山马不是马，是水鹿，实际上就是鹿毫。山马笔在日本很普遍，中国古代也用鹿毫，但是现代并不多。\n    *    石貛，石貛是一种小动物，在欧亚大陆都有，都生活在北方，因为现在黄鼠狼数量很少了，所以多用了石貛毛。石貛毛的刚性接近狼毫，日本、大陆都有出产石貛笔。\n\n\n\n>* 毛笔按其所用笔毛，可以分为三种：\n    * 硬毫笔：如纯狼毫笔，刚性很强。用它来画兰竹很好用，写字往往觉得太刚。\n    * 软毫笔：最普遍的就是纯羊毫笔，性质比较软，但笔锋可以很长，做大笔也没问题。纯羊毫，纯狼毫，就是心副都用同一种毛，韦诞笔羊毫只做副毫，不做中心。纯羊毫笔流行很晚，到明清才开始普遍使用。\n       兼毫笔：刚柔适当，最佳。\n\n### 制笔\n同一品牌厚的比薄的笔好用。\n笔芯捆扎的越紧越好，一毛出，即不堪用。\n笔头插入笔管越深越好。\n\n### 购笔\n#### 大小\n大笔还是小笔,取决于要写多大的字。通常学书法,应该从大字开始。\n    \n    大楷,八岁至十岁,《中兴颂》、《东方朔碑》、《万安桥记》”,这是大楷的字帖。 “中楷,十一岁至十三岁,《九成宫铭》、《虞恭公墓志》、《姚恭公墓志《、《遗教经》”, 这些是中楷的字帖。“小楷,十四岁到十六岁,《宣示表》、《戎路表》、《力命表》、《乐 魏表》、《曹娥表》”这是小楷。\n\n以寸楷为标准,大致来说,大过寸楷就是大楷,小过寸楷就是小楷。一般大楷至少要寸楷两倍大。\n\n## 墨法\n一是笔锋实际写过的部分，我称之为笔道。\n二是墨色显示出来的部分，我称之为墨道。\n\n湿墨墨道最宽\n![](media/15011539840051/15056181691411.jpg)\n\n润墨\n![](media/15011539840051/15056182644846.jpg)\n\n![](media/15011539840051/15056182806656.jpg)\n\n干墨\n![](media/15011539840051/15056182954486.jpg)\n\n沙笔、燥锋和枯笔\n![](media/15011539840051/15056183313856.jpg)\n\n\n  [1]: http://static.zybuluo.com/allon6/ghtv62traugll27d1n4auaor/image_1bgaqm3nmjqp14ah1b5118cl18fh9.png\n  [2]: http://static.zybuluo.com/allon6/t2ukt97yz9wnibdrmuc0hk8t/image_1bgaqp6dn16bg1iun1k851b58mdhm.png\n  \n  \n\n\n","source":"_posts/书法工具.md","raw":"---\ntitle: 书法工具 \ncatalog: true\ndate: 2017-11-22 17:21:29\nsubtitle: \"笔墨纸砚\"\nheader-img: \"/img/03.jpg\"\ntags: \"书法\"\n---\n\n# 2 工具\n\n标签： 书法\n\n---\n## 认识毛笔\n#### 外扎式\n    最简单最原始的作法。早期的毛笔好象扫帚。\n#### 夹扎式\n    后来就聪明点了，把笔杆一头劈开，把笔毛夹在里面了。\n    这样一改进，笔毛就靠在一起了，也就是说笔头中间不是空的了。\n#### 插入式\n    当时还没有普遍用竹管，笔杆普遍比较细，所以要在笔杆的一端，钻一个洞以纳入笔头。\n    这个洞，我们称为毛腔。\n   \n    要注意，这时候开始先制作笔头了，把笔头的根部扎紧，然后塞入毛腔之中。\n    \n    先做笔头，这在制笔工艺上是重大的进步。但是这种笔没有笔锋，或者说没有一个锐利的尖锋。\n    \n    李柏文书，或者陆机《平复贴》，可以看到，他们所使用的毛笔，没有一个尖锋。\n    这在书法上用起来还是不能如意。\n#### 心副式\n    所以后来，又有了重大的改进，那就是在笔头中间加入一个笔心。\n    笔心是用硬毫做的，有弹性又尖锐，保证有尖锋。笔心的四围再加毛，这我们就称为副毫。\n### 韦诞笔\n真正的书法用笔，称之为有心三副二毫笔。产生于大概是汉末魏晋时期，以韦诞为代表人物。那末这里有四个名词术语：韦诞，有心，三副，二毫。我下面解释一下。\n![image_1bgaqm3nmjqp14ah1b5118cl18fh9.png-114.1kB][1]\n\n![image_1bgaqp6dn16bg1iun1k851b58mdhm.png-59.6kB][2]\n\n#### 二毫\n笔毛分两种。健者为毫，弱者为毳（cuì）。毳就是短毛、弱毛、软毛。好的毛笔，是利用两种毛，一刚一柔，搭配制成。\n古人认为，刚健的毛，最佳的就是野兔毛。通常所说的兔毫，就是野兔背脊上的毛。而且一定要秋天，最好就农历八月所新换的毛，那是最好的。但是要注意兔毫有好几种，最上等的是紫色的，所以我们又叫紫毫。也有杂色的兔毫，比如说黑尖兔毫，颜色就比较杂一些。\n软毛最常用的就是羊毫。羊身上不同的部位，毛的质量也不同，浙江湖州的羊毛，是很适宜做毛笔的，这是选好，不理好的羊毛，就可以做毛笔了。\n用一刚一柔，两种毛做笔，称为叫兼毫笔。\n### 散卓笔(宋代以后)\n韦诞笔好！但韦诞笔制作复杂，成本高。到宋代，就开始流行一种制作简化的毛笔，叫做散卓笔。\n就是解散原来韦诞笔的小笔心，把中心的硬毛和一副、二副的软毛混合在一起，形成一个大笔心，取消了二副，就是取消了墨池，所以散卓笔是没有墨池功能的。简言之：散卓笔的结构，是一心一副，心大，被薄。这种笔，在工艺制作上要简单得多。**现在市场上所卖的毛笔，大多数都是散卓笔。**\n### 用毫范围扩大(宋代以后)\n>* 宋以后不止于用兔毫、羊毫为主，包括：\n    * 狼毫，狼毫刚性不及兔毫，狼是黄鼠狼，是取自黄鼠狼的尾巴，“正冬北地狼毫”，那意思就是冬天取自北方的黄鼠狼毛。\n    * 山马，现在也经常看到山马笔。山马不是马，是水鹿，实际上就是鹿毫。山马笔在日本很普遍，中国古代也用鹿毫，但是现代并不多。\n    *    石貛，石貛是一种小动物，在欧亚大陆都有，都生活在北方，因为现在黄鼠狼数量很少了，所以多用了石貛毛。石貛毛的刚性接近狼毫，日本、大陆都有出产石貛笔。\n\n\n\n>* 毛笔按其所用笔毛，可以分为三种：\n    * 硬毫笔：如纯狼毫笔，刚性很强。用它来画兰竹很好用，写字往往觉得太刚。\n    * 软毫笔：最普遍的就是纯羊毫笔，性质比较软，但笔锋可以很长，做大笔也没问题。纯羊毫，纯狼毫，就是心副都用同一种毛，韦诞笔羊毫只做副毫，不做中心。纯羊毫笔流行很晚，到明清才开始普遍使用。\n       兼毫笔：刚柔适当，最佳。\n\n### 制笔\n同一品牌厚的比薄的笔好用。\n笔芯捆扎的越紧越好，一毛出，即不堪用。\n笔头插入笔管越深越好。\n\n### 购笔\n#### 大小\n大笔还是小笔,取决于要写多大的字。通常学书法,应该从大字开始。\n    \n    大楷,八岁至十岁,《中兴颂》、《东方朔碑》、《万安桥记》”,这是大楷的字帖。 “中楷,十一岁至十三岁,《九成宫铭》、《虞恭公墓志》、《姚恭公墓志《、《遗教经》”, 这些是中楷的字帖。“小楷,十四岁到十六岁,《宣示表》、《戎路表》、《力命表》、《乐 魏表》、《曹娥表》”这是小楷。\n\n以寸楷为标准,大致来说,大过寸楷就是大楷,小过寸楷就是小楷。一般大楷至少要寸楷两倍大。\n\n## 墨法\n一是笔锋实际写过的部分，我称之为笔道。\n二是墨色显示出来的部分，我称之为墨道。\n\n湿墨墨道最宽\n![](media/15011539840051/15056181691411.jpg)\n\n润墨\n![](media/15011539840051/15056182644846.jpg)\n\n![](media/15011539840051/15056182806656.jpg)\n\n干墨\n![](media/15011539840051/15056182954486.jpg)\n\n沙笔、燥锋和枯笔\n![](media/15011539840051/15056183313856.jpg)\n\n\n  [1]: http://static.zybuluo.com/allon6/ghtv62traugll27d1n4auaor/image_1bgaqm3nmjqp14ah1b5118cl18fh9.png\n  [2]: http://static.zybuluo.com/allon6/t2ukt97yz9wnibdrmuc0hk8t/image_1bgaqp6dn16bg1iun1k851b58mdhm.png\n  \n  \n\n\n","slug":"书法工具","published":1,"updated":"2017-11-22T10:40:27.243Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjahvvny10010pv4nd22b2tuo","content":"<h1><span id=\"2-工具\"> 2 工具</span></h1>\n<p>标签： 书法</p>\n<hr>\n<h2><span id=\"认识毛笔\"> 认识毛笔</span></h2>\n<h4><span id=\"外扎式\"> 外扎式</span></h4>\n<pre><code>最简单最原始的作法。早期的毛笔好象扫帚。\n</code></pre>\n<h4><span id=\"夹扎式\"> 夹扎式</span></h4>\n<pre><code>后来就聪明点了，把笔杆一头劈开，把笔毛夹在里面了。\n这样一改进，笔毛就靠在一起了，也就是说笔头中间不是空的了。\n</code></pre>\n<h4><span id=\"插入式\"> 插入式</span></h4>\n<pre><code>当时还没有普遍用竹管，笔杆普遍比较细，所以要在笔杆的一端，钻一个洞以纳入笔头。\n这个洞，我们称为毛腔。\n\n要注意，这时候开始先制作笔头了，把笔头的根部扎紧，然后塞入毛腔之中。\n\n先做笔头，这在制笔工艺上是重大的进步。但是这种笔没有笔锋，或者说没有一个锐利的尖锋。\n\n李柏文书，或者陆机《平复贴》，可以看到，他们所使用的毛笔，没有一个尖锋。\n这在书法上用起来还是不能如意。\n</code></pre>\n<h4><span id=\"心副式\"> 心副式</span></h4>\n<pre><code>所以后来，又有了重大的改进，那就是在笔头中间加入一个笔心。\n笔心是用硬毫做的，有弹性又尖锐，保证有尖锋。笔心的四围再加毛，这我们就称为副毫。\n</code></pre>\n<h3><span id=\"韦诞笔\"> 韦诞笔</span></h3>\n<p>真正的书法用笔，称之为有心三副二毫笔。产生于大概是汉末魏晋时期，以韦诞为代表人物。那末这里有四个名词术语：韦诞，有心，三副，二毫。我下面解释一下。<br>\n<img src=\"http://static.zybuluo.com/allon6/ghtv62traugll27d1n4auaor/image_1bgaqm3nmjqp14ah1b5118cl18fh9.png\" alt=\"image_1bgaqm3nmjqp14ah1b5118cl18fh9.png-114.1kB\"></p>\n<p><img src=\"http://static.zybuluo.com/allon6/t2ukt97yz9wnibdrmuc0hk8t/image_1bgaqp6dn16bg1iun1k851b58mdhm.png\" alt=\"image_1bgaqp6dn16bg1iun1k851b58mdhm.png-59.6kB\"></p>\n<h4><span id=\"二毫\"> 二毫</span></h4>\n<p>笔毛分两种。健者为毫，弱者为毳（cuì）。毳就是短毛、弱毛、软毛。好的毛笔，是利用两种毛，一刚一柔，搭配制成。<br>\n古人认为，刚健的毛，最佳的就是野兔毛。通常所说的兔毫，就是野兔背脊上的毛。而且一定要秋天，最好就农历八月所新换的毛，那是最好的。但是要注意兔毫有好几种，最上等的是紫色的，所以我们又叫紫毫。也有杂色的兔毫，比如说黑尖兔毫，颜色就比较杂一些。<br>\n软毛最常用的就是羊毫。羊身上不同的部位，毛的质量也不同，浙江湖州的羊毛，是很适宜做毛笔的，这是选好，不理好的羊毛，就可以做毛笔了。<br>\n用一刚一柔，两种毛做笔，称为叫兼毫笔。</p>\n<h3><span id=\"散卓笔宋代以后\"> 散卓笔(宋代以后)</span></h3>\n<p>韦诞笔好！但韦诞笔制作复杂，成本高。到宋代，就开始流行一种制作简化的毛笔，叫做散卓笔。<br>\n就是解散原来韦诞笔的小笔心，把中心的硬毛和一副、二副的软毛混合在一起，形成一个大笔心，取消了二副，就是取消了墨池，所以散卓笔是没有墨池功能的。简言之：散卓笔的结构，是一心一副，心大，被薄。这种笔，在工艺制作上要简单得多。<strong>现在市场上所卖的毛笔，大多数都是散卓笔。</strong></p>\n<h3><span id=\"用毫范围扩大宋代以后\"> 用毫范围扩大(宋代以后)</span></h3>\n<blockquote>\n<ul>\n<li>宋以后不止于用兔毫、羊毫为主，包括：<br>\n* 狼毫，狼毫刚性不及兔毫，狼是黄鼠狼，是取自黄鼠狼的尾巴，“正冬北地狼毫”，那意思就是冬天取自北方的黄鼠狼毛。<br>\n* 山马，现在也经常看到山马笔。山马不是马，是水鹿，实际上就是鹿毫。山马笔在日本很普遍，中国古代也用鹿毫，但是现代并不多。<br>\n*    石貛，石貛是一种小动物，在欧亚大陆都有，都生活在北方，因为现在黄鼠狼数量很少了，所以多用了石貛毛。石貛毛的刚性接近狼毫，日本、大陆都有出产石貛笔。</li>\n</ul>\n</blockquote>\n<blockquote>\n<ul>\n<li>毛笔按其所用笔毛，可以分为三种：<br>\n* 硬毫笔：如纯狼毫笔，刚性很强。用它来画兰竹很好用，写字往往觉得太刚。<br>\n* 软毫笔：最普遍的就是纯羊毫笔，性质比较软，但笔锋可以很长，做大笔也没问题。纯羊毫，纯狼毫，就是心副都用同一种毛，韦诞笔羊毫只做副毫，不做中心。纯羊毫笔流行很晚，到明清才开始普遍使用。<br>\n       兼毫笔：刚柔适当，最佳。</li>\n</ul>\n</blockquote>\n<h3><span id=\"制笔\"> 制笔</span></h3>\n<p>同一品牌厚的比薄的笔好用。<br>\n笔芯捆扎的越紧越好，一毛出，即不堪用。<br>\n笔头插入笔管越深越好。</p>\n<h3><span id=\"购笔\"> 购笔</span></h3>\n<h4><span id=\"大小\"> 大小</span></h4>\n<p>大笔还是小笔,取决于要写多大的字。通常学书法,应该从大字开始。</p>\n<pre><code>大楷,八岁至十岁,《中兴颂》、《东方朔碑》、《万安桥记》”,这是大楷的字帖。 “中楷,十一岁至十三岁,《九成宫铭》、《虞恭公墓志》、《姚恭公墓志《、《遗教经》”, 这些是中楷的字帖。“小楷,十四岁到十六岁,《宣示表》、《戎路表》、《力命表》、《乐 魏表》、《曹娥表》”这是小楷。\n</code></pre>\n<p>以寸楷为标准,大致来说,大过寸楷就是大楷,小过寸楷就是小楷。一般大楷至少要寸楷两倍大。</p>\n<h2><span id=\"墨法\"> 墨法</span></h2>\n<p>一是笔锋实际写过的部分，我称之为笔道。<br>\n二是墨色显示出来的部分，我称之为墨道。</p>\n<p>湿墨墨道最宽<br>\n<img src=\"media/15011539840051/15056181691411.jpg\" alt=\"\"></p>\n<p>润墨<br>\n<img src=\"media/15011539840051/15056182644846.jpg\" alt=\"\"></p>\n<p><img src=\"media/15011539840051/15056182806656.jpg\" alt=\"\"></p>\n<p>干墨<br>\n<img src=\"media/15011539840051/15056182954486.jpg\" alt=\"\"></p>\n<p>沙笔、燥锋和枯笔<br>\n<img src=\"media/15011539840051/15056183313856.jpg\" alt=\"\"></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"2-工具\"><a class=\"markdownIt-Anchor\" href=\"#2-工具\"></a> 2 工具</h1>\n<p>标签： 书法</p>\n<hr>\n<h2 id=\"认识毛笔\"><a class=\"markdownIt-Anchor\" href=\"#认识毛笔\"></a> 认识毛笔</h2>\n<h4 id=\"外扎式\"><a class=\"markdownIt-Anchor\" href=\"#外扎式\"></a> 外扎式</h4>\n<pre><code>最简单最原始的作法。早期的毛笔好象扫帚。\n</code></pre>\n<h4 id=\"夹扎式\"><a class=\"markdownIt-Anchor\" href=\"#夹扎式\"></a> 夹扎式</h4>\n<pre><code>后来就聪明点了，把笔杆一头劈开，把笔毛夹在里面了。\n这样一改进，笔毛就靠在一起了，也就是说笔头中间不是空的了。\n</code></pre>\n<h4 id=\"插入式\"><a class=\"markdownIt-Anchor\" href=\"#插入式\"></a> 插入式</h4>\n<pre><code>当时还没有普遍用竹管，笔杆普遍比较细，所以要在笔杆的一端，钻一个洞以纳入笔头。\n这个洞，我们称为毛腔。\n\n要注意，这时候开始先制作笔头了，把笔头的根部扎紧，然后塞入毛腔之中。\n\n先做笔头，这在制笔工艺上是重大的进步。但是这种笔没有笔锋，或者说没有一个锐利的尖锋。\n\n李柏文书，或者陆机《平复贴》，可以看到，他们所使用的毛笔，没有一个尖锋。\n这在书法上用起来还是不能如意。\n</code></pre>\n<h4 id=\"心副式\"><a class=\"markdownIt-Anchor\" href=\"#心副式\"></a> 心副式</h4>\n<pre><code>所以后来，又有了重大的改进，那就是在笔头中间加入一个笔心。\n笔心是用硬毫做的，有弹性又尖锐，保证有尖锋。笔心的四围再加毛，这我们就称为副毫。\n</code></pre>\n<h3 id=\"韦诞笔\"><a class=\"markdownIt-Anchor\" href=\"#韦诞笔\"></a> 韦诞笔</h3>\n<p>真正的书法用笔，称之为有心三副二毫笔。产生于大概是汉末魏晋时期，以韦诞为代表人物。那末这里有四个名词术语：韦诞，有心，三副，二毫。我下面解释一下。<br>\n<img src=\"http://static.zybuluo.com/allon6/ghtv62traugll27d1n4auaor/image_1bgaqm3nmjqp14ah1b5118cl18fh9.png\" alt=\"image_1bgaqm3nmjqp14ah1b5118cl18fh9.png-114.1kB\"></p>\n<p><img src=\"http://static.zybuluo.com/allon6/t2ukt97yz9wnibdrmuc0hk8t/image_1bgaqp6dn16bg1iun1k851b58mdhm.png\" alt=\"image_1bgaqp6dn16bg1iun1k851b58mdhm.png-59.6kB\"></p>\n<h4 id=\"二毫\"><a class=\"markdownIt-Anchor\" href=\"#二毫\"></a> 二毫</h4>\n<p>笔毛分两种。健者为毫，弱者为毳（cuì）。毳就是短毛、弱毛、软毛。好的毛笔，是利用两种毛，一刚一柔，搭配制成。<br>\n古人认为，刚健的毛，最佳的就是野兔毛。通常所说的兔毫，就是野兔背脊上的毛。而且一定要秋天，最好就农历八月所新换的毛，那是最好的。但是要注意兔毫有好几种，最上等的是紫色的，所以我们又叫紫毫。也有杂色的兔毫，比如说黑尖兔毫，颜色就比较杂一些。<br>\n软毛最常用的就是羊毫。羊身上不同的部位，毛的质量也不同，浙江湖州的羊毛，是很适宜做毛笔的，这是选好，不理好的羊毛，就可以做毛笔了。<br>\n用一刚一柔，两种毛做笔，称为叫兼毫笔。</p>\n<h3 id=\"散卓笔宋代以后\"><a class=\"markdownIt-Anchor\" href=\"#散卓笔宋代以后\"></a> 散卓笔(宋代以后)</h3>\n<p>韦诞笔好！但韦诞笔制作复杂，成本高。到宋代，就开始流行一种制作简化的毛笔，叫做散卓笔。<br>\n就是解散原来韦诞笔的小笔心，把中心的硬毛和一副、二副的软毛混合在一起，形成一个大笔心，取消了二副，就是取消了墨池，所以散卓笔是没有墨池功能的。简言之：散卓笔的结构，是一心一副，心大，被薄。这种笔，在工艺制作上要简单得多。<strong>现在市场上所卖的毛笔，大多数都是散卓笔。</strong></p>\n<h3 id=\"用毫范围扩大宋代以后\"><a class=\"markdownIt-Anchor\" href=\"#用毫范围扩大宋代以后\"></a> 用毫范围扩大(宋代以后)</h3>\n<blockquote>\n<ul>\n<li>宋以后不止于用兔毫、羊毫为主，包括：<br>\n* 狼毫，狼毫刚性不及兔毫，狼是黄鼠狼，是取自黄鼠狼的尾巴，“正冬北地狼毫”，那意思就是冬天取自北方的黄鼠狼毛。<br>\n* 山马，现在也经常看到山马笔。山马不是马，是水鹿，实际上就是鹿毫。山马笔在日本很普遍，中国古代也用鹿毫，但是现代并不多。<br>\n*    石貛，石貛是一种小动物，在欧亚大陆都有，都生活在北方，因为现在黄鼠狼数量很少了，所以多用了石貛毛。石貛毛的刚性接近狼毫，日本、大陆都有出产石貛笔。</li>\n</ul>\n</blockquote>\n<blockquote>\n<ul>\n<li>毛笔按其所用笔毛，可以分为三种：<br>\n* 硬毫笔：如纯狼毫笔，刚性很强。用它来画兰竹很好用，写字往往觉得太刚。<br>\n* 软毫笔：最普遍的就是纯羊毫笔，性质比较软，但笔锋可以很长，做大笔也没问题。纯羊毫，纯狼毫，就是心副都用同一种毛，韦诞笔羊毫只做副毫，不做中心。纯羊毫笔流行很晚，到明清才开始普遍使用。<br>\n       兼毫笔：刚柔适当，最佳。</li>\n</ul>\n</blockquote>\n<h3 id=\"制笔\"><a class=\"markdownIt-Anchor\" href=\"#制笔\"></a> 制笔</h3>\n<p>同一品牌厚的比薄的笔好用。<br>\n笔芯捆扎的越紧越好，一毛出，即不堪用。<br>\n笔头插入笔管越深越好。</p>\n<h3 id=\"购笔\"><a class=\"markdownIt-Anchor\" href=\"#购笔\"></a> 购笔</h3>\n<h4 id=\"大小\"><a class=\"markdownIt-Anchor\" href=\"#大小\"></a> 大小</h4>\n<p>大笔还是小笔,取决于要写多大的字。通常学书法,应该从大字开始。</p>\n<pre><code>大楷,八岁至十岁,《中兴颂》、《东方朔碑》、《万安桥记》”,这是大楷的字帖。 “中楷,十一岁至十三岁,《九成宫铭》、《虞恭公墓志》、《姚恭公墓志《、《遗教经》”, 这些是中楷的字帖。“小楷,十四岁到十六岁,《宣示表》、《戎路表》、《力命表》、《乐 魏表》、《曹娥表》”这是小楷。\n</code></pre>\n<p>以寸楷为标准,大致来说,大过寸楷就是大楷,小过寸楷就是小楷。一般大楷至少要寸楷两倍大。</p>\n<h2 id=\"墨法\"><a class=\"markdownIt-Anchor\" href=\"#墨法\"></a> 墨法</h2>\n<p>一是笔锋实际写过的部分，我称之为笔道。<br>\n二是墨色显示出来的部分，我称之为墨道。</p>\n<p>湿墨墨道最宽<br>\n<img src=\"media/15011539840051/15056181691411.jpg\" alt=\"\"></p>\n<p>润墨<br>\n<img src=\"media/15011539840051/15056182644846.jpg\" alt=\"\"></p>\n<p><img src=\"media/15011539840051/15056182806656.jpg\" alt=\"\"></p>\n<p>干墨<br>\n<img src=\"media/15011539840051/15056182954486.jpg\" alt=\"\"></p>\n<p>沙笔、燥锋和枯笔<br>\n<img src=\"media/15011539840051/15056183313856.jpg\" alt=\"\"></p>\n"},{"title":"微积分","catalog":true,"date":"2017-11-22T07:22:41.000Z","subtitle":null,"header-img":"/img/02.jpg","_content":"\n\n# 微积分\n\n#### 微积分是描述两个函数关系的学科，函数一为原函数，函数二为微分函数。\n\n### 微分 - 从函数一求函数二就是微分\n△y、△x表示很小的一段，dy、dx表示极限小接近0但不是0。             \n\n$$\\frac{dy}{dx} = lim\\frac{\\Delta{y}}{\\Delta{x}}$$\n\n![image_1bbgkn5l9sco1fvgvme1ai1m0u13.png-30kB][1]\n\n**推导$y=x^2$ 的微分函数**\n![image_1bbgkkrg71s4ipt6tfh1c0h1d1d9.png-50.1kB][2]![image_1bbgklarj1r3bchivk6leha4tm.png-11.9kB][3]\n\n>* $\\frac{dy}{dx}$ 简写为 y`，二阶导数简写为y''\n>* 一阶导数正负表示增长，二阶导数正负表示凹凸。凹：向下弯曲；凸：向上弯曲。\n>* 拐点的 y''=0\n\n### 积分 - 从函数二反求函数一就是积分（原函数是其导数的积分）\n\n*   方法一：函数一是函数二倒过来的函数，分别有算术法和代数（字母）法。通过推导哪些函数的微分函数是已知函数。【主要是求和】 \n*   方法二：函数一是函数二图像下的面积。通过面积求原函数，原函数是x到0围成的面积。\n\n### 乘法和除法法则\n**乘法法则**\n若： \n$$P(x) = f(x).g(x)$$\n则有：\n$$\\frac{dP}{dx}=f(x)\\frac{dg}{dx} + g(x)\\frac{df}{dx}$$\n\n非常重要的公式\n\n$$f(x) = x^n$$\n\nf(x)的导数为：\n$$\\frac{df(x)}{dx}=\\frac{d}{dx}x^n=nx^{n-1}$$\n\n**除法法则**\n\n$$\\frac{d}{dx}(\\frac{f(x)}{g(x)})=\\frac{\\frac{g(x).df(x)}{dx}-\\frac{f(x).dg(x)}{f(x)}}{g(x)^2}$$\n\n### 链式法则\n\n$$\\frac{dz}{dx}=\\frac{dz}{dy}\\frac{dy}{dx}$$                                      \n\n\n\n\n  [1]: http://static.zybuluo.com/allon6/n33eezcv4492gc8dt5lc1l2z/image_1bbgkn5l9sco1fvgvme1ai1m0u13.png\n  [2]: http://static.zybuluo.com/allon6/2j6faulyh11r1t0s4n8in6pq/image_1bbgkkrg71s4ipt6tfh1c0h1d1d9.png\n  [3]: http://static.zybuluo.com/allon6/tccb61nlk8faqy27k94k6290/image_1bbgklarj1r3bchivk6leha4tm.png\n  [4]: http://static.zybuluo.com/allon6/ulsbrua9byf7oangfkk2jyyd/image_1bbkh30at9tv10jaln9cfvjbr1g.png\n\n\n","source":"_posts/微积分.md","raw":"---\ntitle: 微积分\ncatalog: true\ndate: 2017-11-22 15:22:41\nsubtitle:\nheader-img: \"/img/02.jpg\"\ntags: \"数学\"\n---\n\n\n# 微积分\n\n#### 微积分是描述两个函数关系的学科，函数一为原函数，函数二为微分函数。\n\n### 微分 - 从函数一求函数二就是微分\n△y、△x表示很小的一段，dy、dx表示极限小接近0但不是0。             \n\n$$\\frac{dy}{dx} = lim\\frac{\\Delta{y}}{\\Delta{x}}$$\n\n![image_1bbgkn5l9sco1fvgvme1ai1m0u13.png-30kB][1]\n\n**推导$y=x^2$ 的微分函数**\n![image_1bbgkkrg71s4ipt6tfh1c0h1d1d9.png-50.1kB][2]![image_1bbgklarj1r3bchivk6leha4tm.png-11.9kB][3]\n\n>* $\\frac{dy}{dx}$ 简写为 y`，二阶导数简写为y''\n>* 一阶导数正负表示增长，二阶导数正负表示凹凸。凹：向下弯曲；凸：向上弯曲。\n>* 拐点的 y''=0\n\n### 积分 - 从函数二反求函数一就是积分（原函数是其导数的积分）\n\n*   方法一：函数一是函数二倒过来的函数，分别有算术法和代数（字母）法。通过推导哪些函数的微分函数是已知函数。【主要是求和】 \n*   方法二：函数一是函数二图像下的面积。通过面积求原函数，原函数是x到0围成的面积。\n\n### 乘法和除法法则\n**乘法法则**\n若： \n$$P(x) = f(x).g(x)$$\n则有：\n$$\\frac{dP}{dx}=f(x)\\frac{dg}{dx} + g(x)\\frac{df}{dx}$$\n\n非常重要的公式\n\n$$f(x) = x^n$$\n\nf(x)的导数为：\n$$\\frac{df(x)}{dx}=\\frac{d}{dx}x^n=nx^{n-1}$$\n\n**除法法则**\n\n$$\\frac{d}{dx}(\\frac{f(x)}{g(x)})=\\frac{\\frac{g(x).df(x)}{dx}-\\frac{f(x).dg(x)}{f(x)}}{g(x)^2}$$\n\n### 链式法则\n\n$$\\frac{dz}{dx}=\\frac{dz}{dy}\\frac{dy}{dx}$$                                      \n\n\n\n\n  [1]: http://static.zybuluo.com/allon6/n33eezcv4492gc8dt5lc1l2z/image_1bbgkn5l9sco1fvgvme1ai1m0u13.png\n  [2]: http://static.zybuluo.com/allon6/2j6faulyh11r1t0s4n8in6pq/image_1bbgkkrg71s4ipt6tfh1c0h1d1d9.png\n  [3]: http://static.zybuluo.com/allon6/tccb61nlk8faqy27k94k6290/image_1bbgklarj1r3bchivk6leha4tm.png\n  [4]: http://static.zybuluo.com/allon6/ulsbrua9byf7oangfkk2jyyd/image_1bbkh30at9tv10jaln9cfvjbr1g.png\n\n\n","slug":"微积分","published":1,"updated":"2017-11-22T10:40:40.148Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjahvvny20012pv4nb2kvzzrd","content":"<h1><span id=\"微积分\"> 微积分</span></h1>\n<h4><span id=\"微积分是描述两个函数关系的学科函数一为原函数函数二为微分函数\"> 微积分是描述两个函数关系的学科，函数一为原函数，函数二为微分函数。</span></h4>\n<h3><span id=\"微分-从函数一求函数二就是微分\"> 微分 - 从函数一求函数二就是微分</span></h3>\n<p>△y、△x表示很小的一段，dy、dx表示极限小接近0但不是0。</p>\n<p><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mfrac><mrow><mi>d</mi><mi>y</mi></mrow><mrow><mi>d</mi><mi>x</mi></mrow></mfrac><mo>=</mo><mi>l</mi><mi>i</mi><mi>m</mi><mfrac><mrow><mi mathvariant=\"normal\">Δ</mi><mrow><mi>y</mi></mrow></mrow><mrow><mi mathvariant=\"normal\">Δ</mi><mrow><mi>x</mi></mrow></mrow></mfrac></mrow><annotation encoding=\"application/x-tex\">\\frac{dy}{dx} = lim\\frac{\\Delta{y}}{\\Delta{x}}\n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"strut\" style=\"height:1.37144em;\"></span><span class=\"strut bottom\" style=\"height:2.05744em;vertical-align:-0.686em;\"></span><span class=\"base displaystyle textstyle uncramped\"><span class=\"mord reset-textstyle displaystyle textstyle uncramped\"><span class=\"sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist\"><span style=\"top:0.686em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"reset-textstyle textstyle cramped\"><span class=\"mord textstyle cramped\"><span class=\"mord mathit\">d</span><span class=\"mord mathit\">x</span></span></span></span><span style=\"top:-0.22999999999999998em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"reset-textstyle textstyle uncramped frac-line\"></span></span><span style=\"top:-0.677em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"reset-textstyle textstyle uncramped\"><span class=\"mord textstyle uncramped\"><span class=\"mord mathit\">d</span><span class=\"mord mathit\" style=\"margin-right:0.03588em;\">y</span></span></span></span><span class=\"baseline-fix\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span>​</span></span></span><span class=\"sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter\"></span></span><span class=\"mrel\">=</span><span class=\"mord mathit\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathit\">i</span><span class=\"mord mathit\">m</span><span class=\"mord reset-textstyle displaystyle textstyle uncramped\"><span class=\"sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist\"><span style=\"top:0.686em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"reset-textstyle textstyle cramped\"><span class=\"mord textstyle cramped\"><span class=\"mord mathrm\">Δ</span><span class=\"mord textstyle cramped\"><span class=\"mord mathit\">x</span></span></span></span></span><span style=\"top:-0.22999999999999998em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"reset-textstyle textstyle uncramped frac-line\"></span></span><span style=\"top:-0.677em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"reset-textstyle textstyle uncramped\"><span class=\"mord textstyle uncramped\"><span class=\"mord mathrm\">Δ</span><span class=\"mord textstyle uncramped\"><span class=\"mord mathit\" style=\"margin-right:0.03588em;\">y</span></span></span></span></span><span class=\"baseline-fix\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span>​</span></span></span><span class=\"sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter\"></span></span></span></span></span></span></p>\n<p><img src=\"http://static.zybuluo.com/allon6/n33eezcv4492gc8dt5lc1l2z/image_1bbgkn5l9sco1fvgvme1ai1m0u13.png\" alt=\"image_1bbgkn5l9sco1fvgvme1ai1m0u13.png-30kB\"></p>\n<p><strong>推导<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>y</mi><mo>=</mo><msup><mi>x</mi><mn>2</mn></msup></mrow><annotation encoding=\"application/x-tex\">y=x^2</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"strut\" style=\"height:0.8141079999999999em;\"></span><span class=\"strut bottom\" style=\"height:1.008548em;vertical-align:-0.19444em;\"></span><span class=\"base textstyle uncramped\"><span class=\"mord mathit\" style=\"margin-right:0.03588em;\">y</span><span class=\"mrel\">=</span><span class=\"mord\"><span class=\"mord mathit\">x</span><span class=\"vlist\"><span style=\"top:-0.363em;margin-right:0.05em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"reset-textstyle scriptstyle uncramped\"><span class=\"mord mathrm\">2</span></span></span><span class=\"baseline-fix\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span>​</span></span></span></span></span></span> 的微分函数</strong><br>\n<img src=\"http://static.zybuluo.com/allon6/2j6faulyh11r1t0s4n8in6pq/image_1bbgkkrg71s4ipt6tfh1c0h1d1d9.png\" alt=\"image_1bbgkkrg71s4ipt6tfh1c0h1d1d9.png-50.1kB\"><img src=\"http://static.zybuluo.com/allon6/tccb61nlk8faqy27k94k6290/image_1bbgklarj1r3bchivk6leha4tm.png\" alt=\"image_1bbgklarj1r3bchivk6leha4tm.png-11.9kB\"></p>\n<blockquote>\n<ul>\n<li><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mfrac><mrow><mi>d</mi><mi>y</mi></mrow><mrow><mi>d</mi><mi>x</mi></mrow></mfrac></mrow><annotation encoding=\"application/x-tex\">\\frac{dy}{dx}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"strut\" style=\"height:0.9322159999999999em;\"></span><span class=\"strut bottom\" style=\"height:1.277216em;vertical-align:-0.345em;\"></span><span class=\"base textstyle uncramped\"><span class=\"mord reset-textstyle textstyle uncramped\"><span class=\"sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist\"><span style=\"top:0.345em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"reset-textstyle scriptstyle cramped\"><span class=\"mord scriptstyle cramped\"><span class=\"mord mathit\">d</span><span class=\"mord mathit\">x</span></span></span></span><span style=\"top:-0.22999999999999998em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"reset-textstyle textstyle uncramped frac-line\"></span></span><span style=\"top:-0.44610799999999995em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"reset-textstyle scriptstyle uncramped\"><span class=\"mord scriptstyle uncramped\"><span class=\"mord mathit\">d</span><span class=\"mord mathit\" style=\"margin-right:0.03588em;\">y</span></span></span></span><span class=\"baseline-fix\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span>​</span></span></span><span class=\"sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter\"></span></span></span></span></span> 简写为 y`，二阶导数简写为y’’</li>\n<li>一阶导数正负表示增长，二阶导数正负表示凹凸。凹：向下弯曲；凸：向上弯曲。</li>\n<li>拐点的 y’’=0</li>\n</ul>\n</blockquote>\n<h3><span id=\"积分-从函数二反求函数一就是积分原函数是其导数的积分\"> 积分 - 从函数二反求函数一就是积分（原函数是其导数的积分）</span></h3>\n<ul>\n<li>方法一：函数一是函数二倒过来的函数，分别有算术法和代数（字母）法。通过推导哪些函数的微分函数是已知函数。【主要是求和】</li>\n<li>方法二：函数一是函数二图像下的面积。通过面积求原函数，原函数是x到0围成的面积。</li>\n</ul>\n<h3><span id=\"乘法和除法法则\"> 乘法和除法法则</span></h3>\n<p><strong>乘法法则</strong><br>\n若：</p>\n<p><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>P</mi><mo>(</mo><mi>x</mi><mo>)</mo><mo>=</mo><mi>f</mi><mo>(</mo><mi>x</mi><mo>)</mo><mi mathvariant=\"normal\">.</mi><mi>g</mi><mo>(</mo><mi>x</mi><mo>)</mo></mrow><annotation encoding=\"application/x-tex\">P(x) = f(x).g(x)\n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"strut\" style=\"height:0.75em;\"></span><span class=\"strut bottom\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"base displaystyle textstyle uncramped\"><span class=\"mord mathit\" style=\"margin-right:0.13889em;\">P</span><span class=\"mopen\">(</span><span class=\"mord mathit\">x</span><span class=\"mclose\">)</span><span class=\"mrel\">=</span><span class=\"mord mathit\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord mathit\">x</span><span class=\"mclose\">)</span><span class=\"mord mathrm\">.</span><span class=\"mord mathit\" style=\"margin-right:0.03588em;\">g</span><span class=\"mopen\">(</span><span class=\"mord mathit\">x</span><span class=\"mclose\">)</span></span></span></span></span></p>\n<p>则有：</p>\n<p><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mfrac><mrow><mi>d</mi><mi>P</mi></mrow><mrow><mi>d</mi><mi>x</mi></mrow></mfrac><mo>=</mo><mi>f</mi><mo>(</mo><mi>x</mi><mo>)</mo><mfrac><mrow><mi>d</mi><mi>g</mi></mrow><mrow><mi>d</mi><mi>x</mi></mrow></mfrac><mo>+</mo><mi>g</mi><mo>(</mo><mi>x</mi><mo>)</mo><mfrac><mrow><mi>d</mi><mi>f</mi></mrow><mrow><mi>d</mi><mi>x</mi></mrow></mfrac></mrow><annotation encoding=\"application/x-tex\">\\frac{dP}{dx}=f(x)\\frac{dg}{dx} + g(x)\\frac{df}{dx}\n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"strut\" style=\"height:1.37144em;\"></span><span class=\"strut bottom\" style=\"height:2.05744em;vertical-align:-0.686em;\"></span><span class=\"base displaystyle textstyle uncramped\"><span class=\"mord reset-textstyle displaystyle textstyle uncramped\"><span class=\"sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist\"><span style=\"top:0.686em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"reset-textstyle textstyle cramped\"><span class=\"mord textstyle cramped\"><span class=\"mord mathit\">d</span><span class=\"mord mathit\">x</span></span></span></span><span style=\"top:-0.22999999999999998em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"reset-textstyle textstyle uncramped frac-line\"></span></span><span style=\"top:-0.677em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"reset-textstyle textstyle uncramped\"><span class=\"mord textstyle uncramped\"><span class=\"mord mathit\">d</span><span class=\"mord mathit\" style=\"margin-right:0.13889em;\">P</span></span></span></span><span class=\"baseline-fix\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span>​</span></span></span><span class=\"sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter\"></span></span><span class=\"mrel\">=</span><span class=\"mord mathit\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord mathit\">x</span><span class=\"mclose\">)</span><span class=\"mord reset-textstyle displaystyle textstyle uncramped\"><span class=\"sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist\"><span style=\"top:0.686em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"reset-textstyle textstyle cramped\"><span class=\"mord textstyle cramped\"><span class=\"mord mathit\">d</span><span class=\"mord mathit\">x</span></span></span></span><span style=\"top:-0.22999999999999998em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"reset-textstyle textstyle uncramped frac-line\"></span></span><span style=\"top:-0.677em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"reset-textstyle textstyle uncramped\"><span class=\"mord textstyle uncramped\"><span class=\"mord mathit\">d</span><span class=\"mord mathit\" style=\"margin-right:0.03588em;\">g</span></span></span></span><span class=\"baseline-fix\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span>​</span></span></span><span class=\"sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter\"></span></span><span class=\"mbin\">+</span><span class=\"mord mathit\" style=\"margin-right:0.03588em;\">g</span><span class=\"mopen\">(</span><span class=\"mord mathit\">x</span><span class=\"mclose\">)</span><span class=\"mord reset-textstyle displaystyle textstyle uncramped\"><span class=\"sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist\"><span style=\"top:0.686em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"reset-textstyle textstyle cramped\"><span class=\"mord textstyle cramped\"><span class=\"mord mathit\">d</span><span class=\"mord mathit\">x</span></span></span></span><span style=\"top:-0.22999999999999998em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"reset-textstyle textstyle uncramped frac-line\"></span></span><span style=\"top:-0.677em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"reset-textstyle textstyle uncramped\"><span class=\"mord textstyle uncramped\"><span class=\"mord mathit\">d</span><span class=\"mord mathit\" style=\"margin-right:0.10764em;\">f</span></span></span></span><span class=\"baseline-fix\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span>​</span></span></span><span class=\"sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter\"></span></span></span></span></span></span></p>\n<p>非常重要的公式</p>\n<p><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>f</mi><mo>(</mo><mi>x</mi><mo>)</mo><mo>=</mo><msup><mi>x</mi><mi>n</mi></msup></mrow><annotation encoding=\"application/x-tex\">f(x) = x^n\n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"strut\" style=\"height:0.75em;\"></span><span class=\"strut bottom\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"base displaystyle textstyle uncramped\"><span class=\"mord mathit\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord mathit\">x</span><span class=\"mclose\">)</span><span class=\"mrel\">=</span><span class=\"mord\"><span class=\"mord mathit\">x</span><span class=\"vlist\"><span style=\"top:-0.413em;margin-right:0.05em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"reset-textstyle scriptstyle uncramped\"><span class=\"mord mathit\">n</span></span></span><span class=\"baseline-fix\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span>​</span></span></span></span></span></span></span></p>\n<p>f(x)的导数为：</p>\n<p><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mfrac><mrow><mi>d</mi><mi>f</mi><mo>(</mo><mi>x</mi><mo>)</mo></mrow><mrow><mi>d</mi><mi>x</mi></mrow></mfrac><mo>=</mo><mfrac><mrow><mi>d</mi></mrow><mrow><mi>d</mi><mi>x</mi></mrow></mfrac><msup><mi>x</mi><mi>n</mi></msup><mo>=</mo><mi>n</mi><msup><mi>x</mi><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></msup></mrow><annotation encoding=\"application/x-tex\">\\frac{df(x)}{dx}=\\frac{d}{dx}x^n=nx^{n-1}\n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"strut\" style=\"height:1.427em;\"></span><span class=\"strut bottom\" style=\"height:2.113em;vertical-align:-0.686em;\"></span><span class=\"base displaystyle textstyle uncramped\"><span class=\"mord reset-textstyle displaystyle textstyle uncramped\"><span class=\"sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist\"><span style=\"top:0.686em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"reset-textstyle textstyle cramped\"><span class=\"mord textstyle cramped\"><span class=\"mord mathit\">d</span><span class=\"mord mathit\">x</span></span></span></span><span style=\"top:-0.22999999999999998em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"reset-textstyle textstyle uncramped frac-line\"></span></span><span style=\"top:-0.677em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"reset-textstyle textstyle uncramped\"><span class=\"mord textstyle uncramped\"><span class=\"mord mathit\">d</span><span class=\"mord mathit\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord mathit\">x</span><span class=\"mclose\">)</span></span></span></span><span class=\"baseline-fix\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span>​</span></span></span><span class=\"sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter\"></span></span><span class=\"mrel\">=</span><span class=\"mord reset-textstyle displaystyle textstyle uncramped\"><span class=\"sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist\"><span style=\"top:0.686em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"reset-textstyle textstyle cramped\"><span class=\"mord textstyle cramped\"><span class=\"mord mathit\">d</span><span class=\"mord mathit\">x</span></span></span></span><span style=\"top:-0.22999999999999998em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"reset-textstyle textstyle uncramped frac-line\"></span></span><span style=\"top:-0.677em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"reset-textstyle textstyle uncramped\"><span class=\"mord textstyle uncramped\"><span class=\"mord mathit\">d</span></span></span></span><span class=\"baseline-fix\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span>​</span></span></span><span class=\"sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter\"></span></span><span class=\"mord\"><span class=\"mord mathit\">x</span><span class=\"vlist\"><span style=\"top:-0.413em;margin-right:0.05em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"reset-textstyle scriptstyle uncramped\"><span class=\"mord mathit\">n</span></span></span><span class=\"baseline-fix\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span>​</span></span></span><span class=\"mrel\">=</span><span class=\"mord mathit\">n</span><span class=\"mord\"><span class=\"mord mathit\">x</span><span class=\"vlist\"><span style=\"top:-0.41300000000000003em;margin-right:0.05em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"reset-textstyle scriptstyle uncramped\"><span class=\"mord scriptstyle uncramped\"><span class=\"mord mathit\">n</span><span class=\"mbin\">−</span><span class=\"mord mathrm\">1</span></span></span></span><span class=\"baseline-fix\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span>​</span></span></span></span></span></span></span></p>\n<p><strong>除法法则</strong></p>\n<p><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mfrac><mrow><mi>d</mi></mrow><mrow><mi>d</mi><mi>x</mi></mrow></mfrac><mo>(</mo><mfrac><mrow><mi>f</mi><mo>(</mo><mi>x</mi><mo>)</mo></mrow><mrow><mi>g</mi><mo>(</mo><mi>x</mi><mo>)</mo></mrow></mfrac><mo>)</mo><mo>=</mo><mfrac><mrow><mfrac><mrow><mi>g</mi><mo>(</mo><mi>x</mi><mo>)</mo><mi mathvariant=\"normal\">.</mi><mi>d</mi><mi>f</mi><mo>(</mo><mi>x</mi><mo>)</mo></mrow><mrow><mi>d</mi><mi>x</mi></mrow></mfrac><mo>−</mo><mfrac><mrow><mi>f</mi><mo>(</mo><mi>x</mi><mo>)</mo><mi mathvariant=\"normal\">.</mi><mi>d</mi><mi>g</mi><mo>(</mo><mi>x</mi><mo>)</mo></mrow><mrow><mi>f</mi><mo>(</mo><mi>x</mi><mo>)</mo></mrow></mfrac></mrow><mrow><mi>g</mi><mo>(</mo><mi>x</mi><msup><mo>)</mo><mn>2</mn></msup></mrow></mfrac></mrow><annotation encoding=\"application/x-tex\">\\frac{d}{dx}(\\frac{f(x)}{g(x)})=\\frac{\\frac{g(x).df(x)}{dx}-\\frac{f(x).dg(x)}{f(x)}}{g(x)^2}\n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"strut\" style=\"height:1.92em;\"></span><span class=\"strut bottom\" style=\"height:2.856em;vertical-align:-0.936em;\"></span><span class=\"base displaystyle textstyle uncramped\"><span class=\"mord reset-textstyle displaystyle textstyle uncramped\"><span class=\"sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist\"><span style=\"top:0.686em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"reset-textstyle textstyle cramped\"><span class=\"mord textstyle cramped\"><span class=\"mord mathit\">d</span><span class=\"mord mathit\">x</span></span></span></span><span style=\"top:-0.22999999999999998em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"reset-textstyle textstyle uncramped frac-line\"></span></span><span style=\"top:-0.677em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"reset-textstyle textstyle uncramped\"><span class=\"mord textstyle uncramped\"><span class=\"mord mathit\">d</span></span></span></span><span class=\"baseline-fix\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span>​</span></span></span><span class=\"sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter\"></span></span><span class=\"mopen\">(</span><span class=\"mord reset-textstyle displaystyle textstyle uncramped\"><span class=\"sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist\"><span style=\"top:0.686em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"reset-textstyle textstyle cramped\"><span class=\"mord textstyle cramped\"><span class=\"mord mathit\" style=\"margin-right:0.03588em;\">g</span><span class=\"mopen\">(</span><span class=\"mord mathit\">x</span><span class=\"mclose\">)</span></span></span></span><span style=\"top:-0.2300000000000001em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"reset-textstyle textstyle uncramped frac-line\"></span></span><span style=\"top:-0.677em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"reset-textstyle textstyle uncramped\"><span class=\"mord textstyle uncramped\"><span class=\"mord mathit\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord mathit\">x</span><span class=\"mclose\">)</span></span></span></span><span class=\"baseline-fix\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span>​</span></span></span><span class=\"sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter\"></span></span><span class=\"mclose\">)</span><span class=\"mrel\">=</span><span class=\"mord reset-textstyle displaystyle textstyle uncramped\"><span class=\"sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist\"><span style=\"top:0.686em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"reset-textstyle textstyle cramped\"><span class=\"mord textstyle cramped\"><span class=\"mord mathit\" style=\"margin-right:0.03588em;\">g</span><span class=\"mopen\">(</span><span class=\"mord mathit\">x</span><span class=\"mclose\"><span class=\"mclose\">)</span><span class=\"vlist\"><span style=\"top:-0.289em;margin-right:0.05em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"reset-textstyle scriptstyle cramped\"><span class=\"mord mathrm\">2</span></span></span><span class=\"baseline-fix\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span>​</span></span></span></span></span></span><span style=\"top:-0.2300000000000001em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"reset-textstyle textstyle uncramped frac-line\"></span></span><span style=\"top:-0.91em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"reset-textstyle textstyle uncramped\"><span class=\"mord textstyle uncramped\"><span class=\"mord reset-textstyle textstyle uncramped\"><span class=\"sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist\"><span style=\"top:0.345em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"reset-textstyle scriptstyle cramped\"><span class=\"mord scriptstyle cramped\"><span class=\"mord mathit\">d</span><span class=\"mord mathit\">x</span></span></span></span><span style=\"top:-0.22999999999999998em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"reset-textstyle textstyle uncramped frac-line\"></span></span><span style=\"top:-0.485em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"reset-textstyle scriptstyle uncramped\"><span class=\"mord scriptstyle uncramped\"><span class=\"mord mathit\" style=\"margin-right:0.03588em;\">g</span><span class=\"mopen\">(</span><span class=\"mord mathit\">x</span><span class=\"mclose\">)</span><span class=\"mord mathrm\">.</span><span class=\"mord mathit\">d</span><span class=\"mord mathit\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord mathit\">x</span><span class=\"mclose\">)</span></span></span></span><span class=\"baseline-fix\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span>​</span></span></span><span class=\"sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter\"></span></span><span class=\"mbin\">−</span><span class=\"mord reset-textstyle textstyle uncramped\"><span class=\"sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist\"><span style=\"top:0.34500000000000003em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"reset-textstyle scriptstyle cramped\"><span class=\"mord scriptstyle cramped\"><span class=\"mord mathit\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord mathit\">x</span><span class=\"mclose\">)</span></span></span></span><span style=\"top:-0.22999999999999998em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"reset-textstyle textstyle uncramped frac-line\"></span></span><span style=\"top:-0.485em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"reset-textstyle scriptstyle uncramped\"><span class=\"mord scriptstyle uncramped\"><span class=\"mord mathit\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord mathit\">x</span><span class=\"mclose\">)</span><span class=\"mord mathrm\">.</span><span class=\"mord mathit\">d</span><span class=\"mord mathit\" style=\"margin-right:0.03588em;\">g</span><span class=\"mopen\">(</span><span class=\"mord mathit\">x</span><span class=\"mclose\">)</span></span></span></span><span class=\"baseline-fix\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span>​</span></span></span><span class=\"sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter\"></span></span></span></span></span><span class=\"baseline-fix\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span>​</span></span></span><span class=\"sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter\"></span></span></span></span></span></span></p>\n<h3><span id=\"链式法则\"> 链式法则</span></h3>\n<p><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mfrac><mrow><mi>d</mi><mi>z</mi></mrow><mrow><mi>d</mi><mi>x</mi></mrow></mfrac><mo>=</mo><mfrac><mrow><mi>d</mi><mi>z</mi></mrow><mrow><mi>d</mi><mi>y</mi></mrow></mfrac><mfrac><mrow><mi>d</mi><mi>y</mi></mrow><mrow><mi>d</mi><mi>x</mi></mrow></mfrac></mrow><annotation encoding=\"application/x-tex\">\\frac{dz}{dx}=\\frac{dz}{dy}\\frac{dy}{dx}\n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"strut\" style=\"height:1.37144em;\"></span><span class=\"strut bottom\" style=\"height:2.25188em;vertical-align:-0.8804400000000001em;\"></span><span class=\"base displaystyle textstyle uncramped\"><span class=\"mord reset-textstyle displaystyle textstyle uncramped\"><span class=\"sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist\"><span style=\"top:0.686em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"reset-textstyle textstyle cramped\"><span class=\"mord textstyle cramped\"><span class=\"mord mathit\">d</span><span class=\"mord mathit\">x</span></span></span></span><span style=\"top:-0.22999999999999998em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"reset-textstyle textstyle uncramped frac-line\"></span></span><span style=\"top:-0.677em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"reset-textstyle textstyle uncramped\"><span class=\"mord textstyle uncramped\"><span class=\"mord mathit\">d</span><span class=\"mord mathit\" style=\"margin-right:0.04398em;\">z</span></span></span></span><span class=\"baseline-fix\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span>​</span></span></span><span class=\"sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter\"></span></span><span class=\"mrel\">=</span><span class=\"mord reset-textstyle displaystyle textstyle uncramped\"><span class=\"sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist\"><span style=\"top:0.6860000000000002em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"reset-textstyle textstyle cramped\"><span class=\"mord textstyle cramped\"><span class=\"mord mathit\">d</span><span class=\"mord mathit\" style=\"margin-right:0.03588em;\">y</span></span></span></span><span style=\"top:-0.22999999999999998em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"reset-textstyle textstyle uncramped frac-line\"></span></span><span style=\"top:-0.677em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"reset-textstyle textstyle uncramped\"><span class=\"mord textstyle uncramped\"><span class=\"mord mathit\">d</span><span class=\"mord mathit\" style=\"margin-right:0.04398em;\">z</span></span></span></span><span class=\"baseline-fix\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span>​</span></span></span><span class=\"sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter\"></span></span><span class=\"mord reset-textstyle displaystyle textstyle uncramped\"><span class=\"sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist\"><span style=\"top:0.686em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"reset-textstyle textstyle cramped\"><span class=\"mord textstyle cramped\"><span class=\"mord mathit\">d</span><span class=\"mord mathit\">x</span></span></span></span><span style=\"top:-0.22999999999999998em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"reset-textstyle textstyle uncramped frac-line\"></span></span><span style=\"top:-0.677em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"reset-textstyle textstyle uncramped\"><span class=\"mord textstyle uncramped\"><span class=\"mord mathit\">d</span><span class=\"mord mathit\" style=\"margin-right:0.03588em;\">y</span></span></span></span><span class=\"baseline-fix\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span>​</span></span></span><span class=\"sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter\"></span></span></span></span></span></span></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"微积分\"><a class=\"markdownIt-Anchor\" href=\"#微积分\"></a> 微积分</h1>\n<h4 id=\"微积分是描述两个函数关系的学科函数一为原函数函数二为微分函数\"><a class=\"markdownIt-Anchor\" href=\"#微积分是描述两个函数关系的学科函数一为原函数函数二为微分函数\"></a> 微积分是描述两个函数关系的学科，函数一为原函数，函数二为微分函数。</h4>\n<h3 id=\"微分-从函数一求函数二就是微分\"><a class=\"markdownIt-Anchor\" href=\"#微分-从函数一求函数二就是微分\"></a> 微分 - 从函数一求函数二就是微分</h3>\n<p>△y、△x表示很小的一段，dy、dx表示极限小接近0但不是0。</p>\n<p><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mfrac><mrow><mi>d</mi><mi>y</mi></mrow><mrow><mi>d</mi><mi>x</mi></mrow></mfrac><mo>=</mo><mi>l</mi><mi>i</mi><mi>m</mi><mfrac><mrow><mi mathvariant=\"normal\">Δ</mi><mrow><mi>y</mi></mrow></mrow><mrow><mi mathvariant=\"normal\">Δ</mi><mrow><mi>x</mi></mrow></mrow></mfrac></mrow><annotation encoding=\"application/x-tex\">\\frac{dy}{dx} = lim\\frac{\\Delta{y}}{\\Delta{x}}\n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"strut\" style=\"height:1.37144em;\"></span><span class=\"strut bottom\" style=\"height:2.05744em;vertical-align:-0.686em;\"></span><span class=\"base displaystyle textstyle uncramped\"><span class=\"mord reset-textstyle displaystyle textstyle uncramped\"><span class=\"sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist\"><span style=\"top:0.686em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"reset-textstyle textstyle cramped\"><span class=\"mord textstyle cramped\"><span class=\"mord mathit\">d</span><span class=\"mord mathit\">x</span></span></span></span><span style=\"top:-0.22999999999999998em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"reset-textstyle textstyle uncramped frac-line\"></span></span><span style=\"top:-0.677em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"reset-textstyle textstyle uncramped\"><span class=\"mord textstyle uncramped\"><span class=\"mord mathit\">d</span><span class=\"mord mathit\" style=\"margin-right:0.03588em;\">y</span></span></span></span><span class=\"baseline-fix\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span>​</span></span></span><span class=\"sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter\"></span></span><span class=\"mrel\">=</span><span class=\"mord mathit\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathit\">i</span><span class=\"mord mathit\">m</span><span class=\"mord reset-textstyle displaystyle textstyle uncramped\"><span class=\"sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist\"><span style=\"top:0.686em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"reset-textstyle textstyle cramped\"><span class=\"mord textstyle cramped\"><span class=\"mord mathrm\">Δ</span><span class=\"mord textstyle cramped\"><span class=\"mord mathit\">x</span></span></span></span></span><span style=\"top:-0.22999999999999998em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"reset-textstyle textstyle uncramped frac-line\"></span></span><span style=\"top:-0.677em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"reset-textstyle textstyle uncramped\"><span class=\"mord textstyle uncramped\"><span class=\"mord mathrm\">Δ</span><span class=\"mord textstyle uncramped\"><span class=\"mord mathit\" style=\"margin-right:0.03588em;\">y</span></span></span></span></span><span class=\"baseline-fix\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span>​</span></span></span><span class=\"sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter\"></span></span></span></span></span></span></p>\n<p><img src=\"http://static.zybuluo.com/allon6/n33eezcv4492gc8dt5lc1l2z/image_1bbgkn5l9sco1fvgvme1ai1m0u13.png\" alt=\"image_1bbgkn5l9sco1fvgvme1ai1m0u13.png-30kB\"></p>\n<p><strong>推导<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>y</mi><mo>=</mo><msup><mi>x</mi><mn>2</mn></msup></mrow><annotation encoding=\"application/x-tex\">y=x^2</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"strut\" style=\"height:0.8141079999999999em;\"></span><span class=\"strut bottom\" style=\"height:1.008548em;vertical-align:-0.19444em;\"></span><span class=\"base textstyle uncramped\"><span class=\"mord mathit\" style=\"margin-right:0.03588em;\">y</span><span class=\"mrel\">=</span><span class=\"mord\"><span class=\"mord mathit\">x</span><span class=\"vlist\"><span style=\"top:-0.363em;margin-right:0.05em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"reset-textstyle scriptstyle uncramped\"><span class=\"mord mathrm\">2</span></span></span><span class=\"baseline-fix\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span>​</span></span></span></span></span></span> 的微分函数</strong><br>\n<img src=\"http://static.zybuluo.com/allon6/2j6faulyh11r1t0s4n8in6pq/image_1bbgkkrg71s4ipt6tfh1c0h1d1d9.png\" alt=\"image_1bbgkkrg71s4ipt6tfh1c0h1d1d9.png-50.1kB\"><img src=\"http://static.zybuluo.com/allon6/tccb61nlk8faqy27k94k6290/image_1bbgklarj1r3bchivk6leha4tm.png\" alt=\"image_1bbgklarj1r3bchivk6leha4tm.png-11.9kB\"></p>\n<blockquote>\n<ul>\n<li><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mfrac><mrow><mi>d</mi><mi>y</mi></mrow><mrow><mi>d</mi><mi>x</mi></mrow></mfrac></mrow><annotation encoding=\"application/x-tex\">\\frac{dy}{dx}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"strut\" style=\"height:0.9322159999999999em;\"></span><span class=\"strut bottom\" style=\"height:1.277216em;vertical-align:-0.345em;\"></span><span class=\"base textstyle uncramped\"><span class=\"mord reset-textstyle textstyle uncramped\"><span class=\"sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist\"><span style=\"top:0.345em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"reset-textstyle scriptstyle cramped\"><span class=\"mord scriptstyle cramped\"><span class=\"mord mathit\">d</span><span class=\"mord mathit\">x</span></span></span></span><span style=\"top:-0.22999999999999998em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"reset-textstyle textstyle uncramped frac-line\"></span></span><span style=\"top:-0.44610799999999995em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"reset-textstyle scriptstyle uncramped\"><span class=\"mord scriptstyle uncramped\"><span class=\"mord mathit\">d</span><span class=\"mord mathit\" style=\"margin-right:0.03588em;\">y</span></span></span></span><span class=\"baseline-fix\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span>​</span></span></span><span class=\"sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter\"></span></span></span></span></span> 简写为 y`，二阶导数简写为y’’</li>\n<li>一阶导数正负表示增长，二阶导数正负表示凹凸。凹：向下弯曲；凸：向上弯曲。</li>\n<li>拐点的 y’’=0</li>\n</ul>\n</blockquote>\n<h3 id=\"积分-从函数二反求函数一就是积分原函数是其导数的积分\"><a class=\"markdownIt-Anchor\" href=\"#积分-从函数二反求函数一就是积分原函数是其导数的积分\"></a> 积分 - 从函数二反求函数一就是积分（原函数是其导数的积分）</h3>\n<ul>\n<li>方法一：函数一是函数二倒过来的函数，分别有算术法和代数（字母）法。通过推导哪些函数的微分函数是已知函数。【主要是求和】</li>\n<li>方法二：函数一是函数二图像下的面积。通过面积求原函数，原函数是x到0围成的面积。</li>\n</ul>\n<h3 id=\"乘法和除法法则\"><a class=\"markdownIt-Anchor\" href=\"#乘法和除法法则\"></a> 乘法和除法法则</h3>\n<p><strong>乘法法则</strong><br>\n若：</p>\n<p><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>P</mi><mo>(</mo><mi>x</mi><mo>)</mo><mo>=</mo><mi>f</mi><mo>(</mo><mi>x</mi><mo>)</mo><mi mathvariant=\"normal\">.</mi><mi>g</mi><mo>(</mo><mi>x</mi><mo>)</mo></mrow><annotation encoding=\"application/x-tex\">P(x) = f(x).g(x)\n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"strut\" style=\"height:0.75em;\"></span><span class=\"strut bottom\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"base displaystyle textstyle uncramped\"><span class=\"mord mathit\" style=\"margin-right:0.13889em;\">P</span><span class=\"mopen\">(</span><span class=\"mord mathit\">x</span><span class=\"mclose\">)</span><span class=\"mrel\">=</span><span class=\"mord mathit\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord mathit\">x</span><span class=\"mclose\">)</span><span class=\"mord mathrm\">.</span><span class=\"mord mathit\" style=\"margin-right:0.03588em;\">g</span><span class=\"mopen\">(</span><span class=\"mord mathit\">x</span><span class=\"mclose\">)</span></span></span></span></span></p>\n<p>则有：</p>\n<p><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mfrac><mrow><mi>d</mi><mi>P</mi></mrow><mrow><mi>d</mi><mi>x</mi></mrow></mfrac><mo>=</mo><mi>f</mi><mo>(</mo><mi>x</mi><mo>)</mo><mfrac><mrow><mi>d</mi><mi>g</mi></mrow><mrow><mi>d</mi><mi>x</mi></mrow></mfrac><mo>+</mo><mi>g</mi><mo>(</mo><mi>x</mi><mo>)</mo><mfrac><mrow><mi>d</mi><mi>f</mi></mrow><mrow><mi>d</mi><mi>x</mi></mrow></mfrac></mrow><annotation encoding=\"application/x-tex\">\\frac{dP}{dx}=f(x)\\frac{dg}{dx} + g(x)\\frac{df}{dx}\n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"strut\" style=\"height:1.37144em;\"></span><span class=\"strut bottom\" style=\"height:2.05744em;vertical-align:-0.686em;\"></span><span class=\"base displaystyle textstyle uncramped\"><span class=\"mord reset-textstyle displaystyle textstyle uncramped\"><span class=\"sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist\"><span style=\"top:0.686em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"reset-textstyle textstyle cramped\"><span class=\"mord textstyle cramped\"><span class=\"mord mathit\">d</span><span class=\"mord mathit\">x</span></span></span></span><span style=\"top:-0.22999999999999998em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"reset-textstyle textstyle uncramped frac-line\"></span></span><span style=\"top:-0.677em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"reset-textstyle textstyle uncramped\"><span class=\"mord textstyle uncramped\"><span class=\"mord mathit\">d</span><span class=\"mord mathit\" style=\"margin-right:0.13889em;\">P</span></span></span></span><span class=\"baseline-fix\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span>​</span></span></span><span class=\"sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter\"></span></span><span class=\"mrel\">=</span><span class=\"mord mathit\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord mathit\">x</span><span class=\"mclose\">)</span><span class=\"mord reset-textstyle displaystyle textstyle uncramped\"><span class=\"sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist\"><span style=\"top:0.686em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"reset-textstyle textstyle cramped\"><span class=\"mord textstyle cramped\"><span class=\"mord mathit\">d</span><span class=\"mord mathit\">x</span></span></span></span><span style=\"top:-0.22999999999999998em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"reset-textstyle textstyle uncramped frac-line\"></span></span><span style=\"top:-0.677em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"reset-textstyle textstyle uncramped\"><span class=\"mord textstyle uncramped\"><span class=\"mord mathit\">d</span><span class=\"mord mathit\" style=\"margin-right:0.03588em;\">g</span></span></span></span><span class=\"baseline-fix\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span>​</span></span></span><span class=\"sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter\"></span></span><span class=\"mbin\">+</span><span class=\"mord mathit\" style=\"margin-right:0.03588em;\">g</span><span class=\"mopen\">(</span><span class=\"mord mathit\">x</span><span class=\"mclose\">)</span><span class=\"mord reset-textstyle displaystyle textstyle uncramped\"><span class=\"sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist\"><span style=\"top:0.686em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"reset-textstyle textstyle cramped\"><span class=\"mord textstyle cramped\"><span class=\"mord mathit\">d</span><span class=\"mord mathit\">x</span></span></span></span><span style=\"top:-0.22999999999999998em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"reset-textstyle textstyle uncramped frac-line\"></span></span><span style=\"top:-0.677em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"reset-textstyle textstyle uncramped\"><span class=\"mord textstyle uncramped\"><span class=\"mord mathit\">d</span><span class=\"mord mathit\" style=\"margin-right:0.10764em;\">f</span></span></span></span><span class=\"baseline-fix\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span>​</span></span></span><span class=\"sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter\"></span></span></span></span></span></span></p>\n<p>非常重要的公式</p>\n<p><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>f</mi><mo>(</mo><mi>x</mi><mo>)</mo><mo>=</mo><msup><mi>x</mi><mi>n</mi></msup></mrow><annotation encoding=\"application/x-tex\">f(x) = x^n\n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"strut\" style=\"height:0.75em;\"></span><span class=\"strut bottom\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"base displaystyle textstyle uncramped\"><span class=\"mord mathit\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord mathit\">x</span><span class=\"mclose\">)</span><span class=\"mrel\">=</span><span class=\"mord\"><span class=\"mord mathit\">x</span><span class=\"vlist\"><span style=\"top:-0.413em;margin-right:0.05em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"reset-textstyle scriptstyle uncramped\"><span class=\"mord mathit\">n</span></span></span><span class=\"baseline-fix\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span>​</span></span></span></span></span></span></span></p>\n<p>f(x)的导数为：</p>\n<p><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mfrac><mrow><mi>d</mi><mi>f</mi><mo>(</mo><mi>x</mi><mo>)</mo></mrow><mrow><mi>d</mi><mi>x</mi></mrow></mfrac><mo>=</mo><mfrac><mrow><mi>d</mi></mrow><mrow><mi>d</mi><mi>x</mi></mrow></mfrac><msup><mi>x</mi><mi>n</mi></msup><mo>=</mo><mi>n</mi><msup><mi>x</mi><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></msup></mrow><annotation encoding=\"application/x-tex\">\\frac{df(x)}{dx}=\\frac{d}{dx}x^n=nx^{n-1}\n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"strut\" style=\"height:1.427em;\"></span><span class=\"strut bottom\" style=\"height:2.113em;vertical-align:-0.686em;\"></span><span class=\"base displaystyle textstyle uncramped\"><span class=\"mord reset-textstyle displaystyle textstyle uncramped\"><span class=\"sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist\"><span style=\"top:0.686em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"reset-textstyle textstyle cramped\"><span class=\"mord textstyle cramped\"><span class=\"mord mathit\">d</span><span class=\"mord mathit\">x</span></span></span></span><span style=\"top:-0.22999999999999998em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"reset-textstyle textstyle uncramped frac-line\"></span></span><span style=\"top:-0.677em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"reset-textstyle textstyle uncramped\"><span class=\"mord textstyle uncramped\"><span class=\"mord mathit\">d</span><span class=\"mord mathit\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord mathit\">x</span><span class=\"mclose\">)</span></span></span></span><span class=\"baseline-fix\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span>​</span></span></span><span class=\"sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter\"></span></span><span class=\"mrel\">=</span><span class=\"mord reset-textstyle displaystyle textstyle uncramped\"><span class=\"sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist\"><span style=\"top:0.686em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"reset-textstyle textstyle cramped\"><span class=\"mord textstyle cramped\"><span class=\"mord mathit\">d</span><span class=\"mord mathit\">x</span></span></span></span><span style=\"top:-0.22999999999999998em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"reset-textstyle textstyle uncramped frac-line\"></span></span><span style=\"top:-0.677em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"reset-textstyle textstyle uncramped\"><span class=\"mord textstyle uncramped\"><span class=\"mord mathit\">d</span></span></span></span><span class=\"baseline-fix\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span>​</span></span></span><span class=\"sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter\"></span></span><span class=\"mord\"><span class=\"mord mathit\">x</span><span class=\"vlist\"><span style=\"top:-0.413em;margin-right:0.05em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"reset-textstyle scriptstyle uncramped\"><span class=\"mord mathit\">n</span></span></span><span class=\"baseline-fix\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span>​</span></span></span><span class=\"mrel\">=</span><span class=\"mord mathit\">n</span><span class=\"mord\"><span class=\"mord mathit\">x</span><span class=\"vlist\"><span style=\"top:-0.41300000000000003em;margin-right:0.05em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"reset-textstyle scriptstyle uncramped\"><span class=\"mord scriptstyle uncramped\"><span class=\"mord mathit\">n</span><span class=\"mbin\">−</span><span class=\"mord mathrm\">1</span></span></span></span><span class=\"baseline-fix\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span>​</span></span></span></span></span></span></span></p>\n<p><strong>除法法则</strong></p>\n<p><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mfrac><mrow><mi>d</mi></mrow><mrow><mi>d</mi><mi>x</mi></mrow></mfrac><mo>(</mo><mfrac><mrow><mi>f</mi><mo>(</mo><mi>x</mi><mo>)</mo></mrow><mrow><mi>g</mi><mo>(</mo><mi>x</mi><mo>)</mo></mrow></mfrac><mo>)</mo><mo>=</mo><mfrac><mrow><mfrac><mrow><mi>g</mi><mo>(</mo><mi>x</mi><mo>)</mo><mi mathvariant=\"normal\">.</mi><mi>d</mi><mi>f</mi><mo>(</mo><mi>x</mi><mo>)</mo></mrow><mrow><mi>d</mi><mi>x</mi></mrow></mfrac><mo>−</mo><mfrac><mrow><mi>f</mi><mo>(</mo><mi>x</mi><mo>)</mo><mi mathvariant=\"normal\">.</mi><mi>d</mi><mi>g</mi><mo>(</mo><mi>x</mi><mo>)</mo></mrow><mrow><mi>f</mi><mo>(</mo><mi>x</mi><mo>)</mo></mrow></mfrac></mrow><mrow><mi>g</mi><mo>(</mo><mi>x</mi><msup><mo>)</mo><mn>2</mn></msup></mrow></mfrac></mrow><annotation encoding=\"application/x-tex\">\\frac{d}{dx}(\\frac{f(x)}{g(x)})=\\frac{\\frac{g(x).df(x)}{dx}-\\frac{f(x).dg(x)}{f(x)}}{g(x)^2}\n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"strut\" style=\"height:1.92em;\"></span><span class=\"strut bottom\" style=\"height:2.856em;vertical-align:-0.936em;\"></span><span class=\"base displaystyle textstyle uncramped\"><span class=\"mord reset-textstyle displaystyle textstyle uncramped\"><span class=\"sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist\"><span style=\"top:0.686em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"reset-textstyle textstyle cramped\"><span class=\"mord textstyle cramped\"><span class=\"mord mathit\">d</span><span class=\"mord mathit\">x</span></span></span></span><span style=\"top:-0.22999999999999998em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"reset-textstyle textstyle uncramped frac-line\"></span></span><span style=\"top:-0.677em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"reset-textstyle textstyle uncramped\"><span class=\"mord textstyle uncramped\"><span class=\"mord mathit\">d</span></span></span></span><span class=\"baseline-fix\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span>​</span></span></span><span class=\"sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter\"></span></span><span class=\"mopen\">(</span><span class=\"mord reset-textstyle displaystyle textstyle uncramped\"><span class=\"sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist\"><span style=\"top:0.686em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"reset-textstyle textstyle cramped\"><span class=\"mord textstyle cramped\"><span class=\"mord mathit\" style=\"margin-right:0.03588em;\">g</span><span class=\"mopen\">(</span><span class=\"mord mathit\">x</span><span class=\"mclose\">)</span></span></span></span><span style=\"top:-0.2300000000000001em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"reset-textstyle textstyle uncramped frac-line\"></span></span><span style=\"top:-0.677em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"reset-textstyle textstyle uncramped\"><span class=\"mord textstyle uncramped\"><span class=\"mord mathit\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord mathit\">x</span><span class=\"mclose\">)</span></span></span></span><span class=\"baseline-fix\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span>​</span></span></span><span class=\"sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter\"></span></span><span class=\"mclose\">)</span><span class=\"mrel\">=</span><span class=\"mord reset-textstyle displaystyle textstyle uncramped\"><span class=\"sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist\"><span style=\"top:0.686em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"reset-textstyle textstyle cramped\"><span class=\"mord textstyle cramped\"><span class=\"mord mathit\" style=\"margin-right:0.03588em;\">g</span><span class=\"mopen\">(</span><span class=\"mord mathit\">x</span><span class=\"mclose\"><span class=\"mclose\">)</span><span class=\"vlist\"><span style=\"top:-0.289em;margin-right:0.05em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"reset-textstyle scriptstyle cramped\"><span class=\"mord mathrm\">2</span></span></span><span class=\"baseline-fix\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span>​</span></span></span></span></span></span><span style=\"top:-0.2300000000000001em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"reset-textstyle textstyle uncramped frac-line\"></span></span><span style=\"top:-0.91em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"reset-textstyle textstyle uncramped\"><span class=\"mord textstyle uncramped\"><span class=\"mord reset-textstyle textstyle uncramped\"><span class=\"sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist\"><span style=\"top:0.345em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"reset-textstyle scriptstyle cramped\"><span class=\"mord scriptstyle cramped\"><span class=\"mord mathit\">d</span><span class=\"mord mathit\">x</span></span></span></span><span style=\"top:-0.22999999999999998em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"reset-textstyle textstyle uncramped frac-line\"></span></span><span style=\"top:-0.485em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"reset-textstyle scriptstyle uncramped\"><span class=\"mord scriptstyle uncramped\"><span class=\"mord mathit\" style=\"margin-right:0.03588em;\">g</span><span class=\"mopen\">(</span><span class=\"mord mathit\">x</span><span class=\"mclose\">)</span><span class=\"mord mathrm\">.</span><span class=\"mord mathit\">d</span><span class=\"mord mathit\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord mathit\">x</span><span class=\"mclose\">)</span></span></span></span><span class=\"baseline-fix\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span>​</span></span></span><span class=\"sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter\"></span></span><span class=\"mbin\">−</span><span class=\"mord reset-textstyle textstyle uncramped\"><span class=\"sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist\"><span style=\"top:0.34500000000000003em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"reset-textstyle scriptstyle cramped\"><span class=\"mord scriptstyle cramped\"><span class=\"mord mathit\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord mathit\">x</span><span class=\"mclose\">)</span></span></span></span><span style=\"top:-0.22999999999999998em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"reset-textstyle textstyle uncramped frac-line\"></span></span><span style=\"top:-0.485em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"reset-textstyle scriptstyle uncramped\"><span class=\"mord scriptstyle uncramped\"><span class=\"mord mathit\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord mathit\">x</span><span class=\"mclose\">)</span><span class=\"mord mathrm\">.</span><span class=\"mord mathit\">d</span><span class=\"mord mathit\" style=\"margin-right:0.03588em;\">g</span><span class=\"mopen\">(</span><span class=\"mord mathit\">x</span><span class=\"mclose\">)</span></span></span></span><span class=\"baseline-fix\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span>​</span></span></span><span class=\"sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter\"></span></span></span></span></span><span class=\"baseline-fix\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span>​</span></span></span><span class=\"sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter\"></span></span></span></span></span></span></p>\n<h3 id=\"链式法则\"><a class=\"markdownIt-Anchor\" href=\"#链式法则\"></a> 链式法则</h3>\n<p><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mfrac><mrow><mi>d</mi><mi>z</mi></mrow><mrow><mi>d</mi><mi>x</mi></mrow></mfrac><mo>=</mo><mfrac><mrow><mi>d</mi><mi>z</mi></mrow><mrow><mi>d</mi><mi>y</mi></mrow></mfrac><mfrac><mrow><mi>d</mi><mi>y</mi></mrow><mrow><mi>d</mi><mi>x</mi></mrow></mfrac></mrow><annotation encoding=\"application/x-tex\">\\frac{dz}{dx}=\\frac{dz}{dy}\\frac{dy}{dx}\n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"strut\" style=\"height:1.37144em;\"></span><span class=\"strut bottom\" style=\"height:2.25188em;vertical-align:-0.8804400000000001em;\"></span><span class=\"base displaystyle textstyle uncramped\"><span class=\"mord reset-textstyle displaystyle textstyle uncramped\"><span class=\"sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist\"><span style=\"top:0.686em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"reset-textstyle textstyle cramped\"><span class=\"mord textstyle cramped\"><span class=\"mord mathit\">d</span><span class=\"mord mathit\">x</span></span></span></span><span style=\"top:-0.22999999999999998em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"reset-textstyle textstyle uncramped frac-line\"></span></span><span style=\"top:-0.677em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"reset-textstyle textstyle uncramped\"><span class=\"mord textstyle uncramped\"><span class=\"mord mathit\">d</span><span class=\"mord mathit\" style=\"margin-right:0.04398em;\">z</span></span></span></span><span class=\"baseline-fix\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span>​</span></span></span><span class=\"sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter\"></span></span><span class=\"mrel\">=</span><span class=\"mord reset-textstyle displaystyle textstyle uncramped\"><span class=\"sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist\"><span style=\"top:0.6860000000000002em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"reset-textstyle textstyle cramped\"><span class=\"mord textstyle cramped\"><span class=\"mord mathit\">d</span><span class=\"mord mathit\" style=\"margin-right:0.03588em;\">y</span></span></span></span><span style=\"top:-0.22999999999999998em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"reset-textstyle textstyle uncramped frac-line\"></span></span><span style=\"top:-0.677em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"reset-textstyle textstyle uncramped\"><span class=\"mord textstyle uncramped\"><span class=\"mord mathit\">d</span><span class=\"mord mathit\" style=\"margin-right:0.04398em;\">z</span></span></span></span><span class=\"baseline-fix\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span>​</span></span></span><span class=\"sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter\"></span></span><span class=\"mord reset-textstyle displaystyle textstyle uncramped\"><span class=\"sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist\"><span style=\"top:0.686em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"reset-textstyle textstyle cramped\"><span class=\"mord textstyle cramped\"><span class=\"mord mathit\">d</span><span class=\"mord mathit\">x</span></span></span></span><span style=\"top:-0.22999999999999998em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"reset-textstyle textstyle uncramped frac-line\"></span></span><span style=\"top:-0.677em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"reset-textstyle textstyle uncramped\"><span class=\"mord textstyle uncramped\"><span class=\"mord mathit\">d</span><span class=\"mord mathit\" style=\"margin-right:0.03588em;\">y</span></span></span></span><span class=\"baseline-fix\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span>​</span></span></span><span class=\"sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter\"></span></span></span></span></span></span></p>\n"},{"title":"第01章 计算机系统漫游","catalog":true,"date":"2017-02-22T09:21:29.000Z","header-img":"/img/05.jpg","_content":"\n#第01章 计算机系统漫游\n\nTags: 深入理解计算机系统\n\n[TOC]\n\n---\n## 第一章\n---\n![image_1beikj90n1f6gv9a1fjbv6n18m49.png-133.7kB][1]\n>* 预编译阶段 - 生成.i文件：  g++ -E hello.c -o hello.i\n>* 编译阶段 - 生成汇编文本.s文件： g++ -S hello.i -o hello.s\n>* 汇编阶段 -  生成.o文件： g++ -c hello.s -o hello.o\n>* 链接阶段 -  生成可执行文件： g++ hello.o -o hello\n\n**g++ gcc编译参数**\n|参数        | 说明   |  \n| ----------| --------| \n| -c    |  只编译不链接，生成*.o文件|  \n| -S        |   生成汇编代码*.s文件   | \n| -E        |   预编译 生成*.i文件   |  \n|-g         |在可执行程序里包含了调试信息，可用 gdb 调试|\n|-o         |把输出文件输出到指定文件里|\n|-static  |链接静态链接库|\n|-library |链接名为library的链接库|\n\n###系统硬件组成\n![image_1beionion1pao1p14p7u5v81kbo13.png-320.4kB][2]\n####总线####\n32位系统总线是4个字节（32个位）\n64位系统总线是8个字节（64个位）\n总线宽度一般就是一个字长\n\n####I/O设备\nI/O设备通过控制器和适配器与I/O总线相连：\n>* 控制器是镶在主板的芯片组，如集显。\n>* 适配器就是插槽，如独显。\n\n####CPU 中央处理单元（Central Processing Unit）\n\n 1. 处理器的核心是一个大小为一个**字**的存储设备（或寄存器），称为程序计数器（PC)。在任何时 刻，PC都指向主存中的某条机器语言指令（即含有该条指令的地址）。\n 2. 从开机到关机，CPU一直更新PC使其指向一下条指令地址。\n 3. 指令是按照严格顺序执行的，执行完一条就更新PC指向下一条。两条指令地址不一定是相邻的。\n\n####主存\n主内存就是一个从index 0开始的字节数组，每个内存字节都有唯一的index也就是唯一的地址。\n\n#### 寄存器\n寄存器文件是一个小的存储设备，由一组单个字长的寄存器组成。每个寄存器都有唯一的名字。\n\n#### CPU指令执行过程\n几乎所有的冯•诺伊曼型计算机的CPU，其工作都可以分为5个阶段：取指令、指令译码、执行指令、访存取数和结果写回\n![image_1bgvo3oi51mtlrjp1ijf1ek4t39m.png-46.2kB][3]\n\n（1）指令周期\n\nCPU取出一条指令并执行该指令所需的时间称为指令周期。\n指令周期的长短与指令的复杂程度有关。\n\n（2）CPU周期\n\n指令周期常常用若干个CPU周期数来表示。\n由于CPU内部的操作速度较快，而CPU访问一次主存所花的时间较长，因此通常用从主存读取一条指令的最短时间来规定CPU周期。\nCPU周期也称为机器周期。\n\n（3）时钟周期\n\n一个CPU周期包含有若干个时钟周期。\n时钟周期是处理操作的最基本时间单位，由机器的主频决定。\n一个CPU周期的时间宽度由若干个时钟周期的总和决定。\n\n![采用定长CPU周期的指令周期示意图][4]\n\n（4）取出和执行任何一条指令所需的最短时间为两个CPU周期。\n\n任何一条指令，它的指令周期至少需要两个CPU周期，而复杂指令的指令周期则需要更多的CPU周期。这是因为，一条指令的取出阶段需要一个CPU周期时间，而一条指令的执行阶段则需要至少一个CPU周期时间。由于不同复杂度指令的执行周期所需的CPU周期数不尽相等，因此，各种指令的指令周期也是不尽相同的。z\n\n#### 一个hello world程序执行过程\n - 利用直接存储器存取（DMA）直接从磁盘不经过cpu拷贝运行文件到主存\n - cpu从主存拷贝字符串到寄存器再从寄存器拷贝到显示器\n \n### 存储器\n####CPU缓存\n运行速度很多消耗在拷贝过程， 由于寄存器越来越快，主存的速度严重跟不上。中间出现了L1 L2 L3这种高速缓存。为CPU提前从主存中获取数据到缓存。\n\n - 寄存器(几百字节)速度最快比主存快100倍\n - L1(几万字节，位于处理器芯片上) 访问速度和寄存器几乎一样\n - L2(数十至百万字节特殊总线连接到处理器)比主存快5-10倍\n - 主存(几十亿字节)\n - 磁盘读取单个字的时间开销比主存大1000万倍\n![image_1bejtnn9t1lp2aiqk2a1hrjes0m.png-138.7kB][5]\n\n#### 结构图\n![image_1bejuddb8lan1ou51l0v93915bp13.png-281kB][6]\n#### 虚拟内存\n虚拟内存和CPU缓存作用一样，它是用来做磁盘的缓存。\n\n### 多核处理器结构\n![image_1bel90rvjdr376a1ag913e84951g.png-433.5kB][7]\n\n* 由高到低：线程级->多指令并行->单指令并行\n#### 超线程\n4核能跑8条线程，就是一种超线程。比如当一个CPU在正等L1缓存的数据，那么这会它也可以跑另一个线程的运算。Intel Core I7就带有超线程技术。\n#### 指令级并行\n一口气执行多条指令，超标量。\n#### 单指令多数据并行（SIMD）\n> SIMD 指令多是为了提高处理影像 、 声音和视频数据应用的执行速度。虽然有些编译器试图从程序中自动抽取 SIMD 并行性，但是更可靠的方法是使用编译器支持的特殊向量数据类型来写程序，例如GCC 就支持向量数据类型。作为对比较通用的程序优化讲述的补充，在网络旁注 OPT:SIMD 中描述了这种编程方式 。\n\n\n  [1]: http://static.zybuluo.com/allon6/qciw23zdgnf96cr1yys34mjo/image_1beikj90n1f6gv9a1fjbv6n18m49.png\n  [2]: http://static.zybuluo.com/allon6/k5g8amzzepo43qi1de8lb2ir/image_1beionion1pao1p14p7u5v81kbo13.png\n  [3]: http://static.zybuluo.com/allon6/hoxu6w8adddrf52uy7a302ap/image_1bgvo3oi51mtlrjp1ijf1ek4t39m.png\n  [4]: http://static.zybuluo.com/allon6/se1cnxl50kpwfdfr1qrk3p7x/image_1bgvp0q9ksh5hdop3n1i2f3g31g.png\n  [5]: http://static.zybuluo.com/allon6/tw906gbl5wwhkrrmrzxmga18/image_1bejtnn9t1lp2aiqk2a1hrjes0m.png\n  [6]: http://static.zybuluo.com/allon6/rbd8q1olikakhvm6lkcibeh1/image_1bejuddb8lan1ou51l0v93915bp13.png\n  [7]: http://static.zybuluo.com/allon6/wgf5sxdj3c7sxuxq4z194v4n/image_1bel90rvjdr376a1ag913e84951g.png\n","source":"_posts/第01章 计算机系统漫游.md","raw":"---\ntitle: \"第01章 计算机系统漫游\"\ncatalog: true\ndate: 2017-02-22 17:21:29\nheader-img: \"/img/05.jpg\"\ntags: \"深入理解计算机系统\"\n---\n\n#第01章 计算机系统漫游\n\nTags: 深入理解计算机系统\n\n[TOC]\n\n---\n## 第一章\n---\n![image_1beikj90n1f6gv9a1fjbv6n18m49.png-133.7kB][1]\n>* 预编译阶段 - 生成.i文件：  g++ -E hello.c -o hello.i\n>* 编译阶段 - 生成汇编文本.s文件： g++ -S hello.i -o hello.s\n>* 汇编阶段 -  生成.o文件： g++ -c hello.s -o hello.o\n>* 链接阶段 -  生成可执行文件： g++ hello.o -o hello\n\n**g++ gcc编译参数**\n|参数        | 说明   |  \n| ----------| --------| \n| -c    |  只编译不链接，生成*.o文件|  \n| -S        |   生成汇编代码*.s文件   | \n| -E        |   预编译 生成*.i文件   |  \n|-g         |在可执行程序里包含了调试信息，可用 gdb 调试|\n|-o         |把输出文件输出到指定文件里|\n|-static  |链接静态链接库|\n|-library |链接名为library的链接库|\n\n###系统硬件组成\n![image_1beionion1pao1p14p7u5v81kbo13.png-320.4kB][2]\n####总线####\n32位系统总线是4个字节（32个位）\n64位系统总线是8个字节（64个位）\n总线宽度一般就是一个字长\n\n####I/O设备\nI/O设备通过控制器和适配器与I/O总线相连：\n>* 控制器是镶在主板的芯片组，如集显。\n>* 适配器就是插槽，如独显。\n\n####CPU 中央处理单元（Central Processing Unit）\n\n 1. 处理器的核心是一个大小为一个**字**的存储设备（或寄存器），称为程序计数器（PC)。在任何时 刻，PC都指向主存中的某条机器语言指令（即含有该条指令的地址）。\n 2. 从开机到关机，CPU一直更新PC使其指向一下条指令地址。\n 3. 指令是按照严格顺序执行的，执行完一条就更新PC指向下一条。两条指令地址不一定是相邻的。\n\n####主存\n主内存就是一个从index 0开始的字节数组，每个内存字节都有唯一的index也就是唯一的地址。\n\n#### 寄存器\n寄存器文件是一个小的存储设备，由一组单个字长的寄存器组成。每个寄存器都有唯一的名字。\n\n#### CPU指令执行过程\n几乎所有的冯•诺伊曼型计算机的CPU，其工作都可以分为5个阶段：取指令、指令译码、执行指令、访存取数和结果写回\n![image_1bgvo3oi51mtlrjp1ijf1ek4t39m.png-46.2kB][3]\n\n（1）指令周期\n\nCPU取出一条指令并执行该指令所需的时间称为指令周期。\n指令周期的长短与指令的复杂程度有关。\n\n（2）CPU周期\n\n指令周期常常用若干个CPU周期数来表示。\n由于CPU内部的操作速度较快，而CPU访问一次主存所花的时间较长，因此通常用从主存读取一条指令的最短时间来规定CPU周期。\nCPU周期也称为机器周期。\n\n（3）时钟周期\n\n一个CPU周期包含有若干个时钟周期。\n时钟周期是处理操作的最基本时间单位，由机器的主频决定。\n一个CPU周期的时间宽度由若干个时钟周期的总和决定。\n\n![采用定长CPU周期的指令周期示意图][4]\n\n（4）取出和执行任何一条指令所需的最短时间为两个CPU周期。\n\n任何一条指令，它的指令周期至少需要两个CPU周期，而复杂指令的指令周期则需要更多的CPU周期。这是因为，一条指令的取出阶段需要一个CPU周期时间，而一条指令的执行阶段则需要至少一个CPU周期时间。由于不同复杂度指令的执行周期所需的CPU周期数不尽相等，因此，各种指令的指令周期也是不尽相同的。z\n\n#### 一个hello world程序执行过程\n - 利用直接存储器存取（DMA）直接从磁盘不经过cpu拷贝运行文件到主存\n - cpu从主存拷贝字符串到寄存器再从寄存器拷贝到显示器\n \n### 存储器\n####CPU缓存\n运行速度很多消耗在拷贝过程， 由于寄存器越来越快，主存的速度严重跟不上。中间出现了L1 L2 L3这种高速缓存。为CPU提前从主存中获取数据到缓存。\n\n - 寄存器(几百字节)速度最快比主存快100倍\n - L1(几万字节，位于处理器芯片上) 访问速度和寄存器几乎一样\n - L2(数十至百万字节特殊总线连接到处理器)比主存快5-10倍\n - 主存(几十亿字节)\n - 磁盘读取单个字的时间开销比主存大1000万倍\n![image_1bejtnn9t1lp2aiqk2a1hrjes0m.png-138.7kB][5]\n\n#### 结构图\n![image_1bejuddb8lan1ou51l0v93915bp13.png-281kB][6]\n#### 虚拟内存\n虚拟内存和CPU缓存作用一样，它是用来做磁盘的缓存。\n\n### 多核处理器结构\n![image_1bel90rvjdr376a1ag913e84951g.png-433.5kB][7]\n\n* 由高到低：线程级->多指令并行->单指令并行\n#### 超线程\n4核能跑8条线程，就是一种超线程。比如当一个CPU在正等L1缓存的数据，那么这会它也可以跑另一个线程的运算。Intel Core I7就带有超线程技术。\n#### 指令级并行\n一口气执行多条指令，超标量。\n#### 单指令多数据并行（SIMD）\n> SIMD 指令多是为了提高处理影像 、 声音和视频数据应用的执行速度。虽然有些编译器试图从程序中自动抽取 SIMD 并行性，但是更可靠的方法是使用编译器支持的特殊向量数据类型来写程序，例如GCC 就支持向量数据类型。作为对比较通用的程序优化讲述的补充，在网络旁注 OPT:SIMD 中描述了这种编程方式 。\n\n\n  [1]: http://static.zybuluo.com/allon6/qciw23zdgnf96cr1yys34mjo/image_1beikj90n1f6gv9a1fjbv6n18m49.png\n  [2]: http://static.zybuluo.com/allon6/k5g8amzzepo43qi1de8lb2ir/image_1beionion1pao1p14p7u5v81kbo13.png\n  [3]: http://static.zybuluo.com/allon6/hoxu6w8adddrf52uy7a302ap/image_1bgvo3oi51mtlrjp1ijf1ek4t39m.png\n  [4]: http://static.zybuluo.com/allon6/se1cnxl50kpwfdfr1qrk3p7x/image_1bgvp0q9ksh5hdop3n1i2f3g31g.png\n  [5]: http://static.zybuluo.com/allon6/tw906gbl5wwhkrrmrzxmga18/image_1bejtnn9t1lp2aiqk2a1hrjes0m.png\n  [6]: http://static.zybuluo.com/allon6/rbd8q1olikakhvm6lkcibeh1/image_1bejuddb8lan1ou51l0v93915bp13.png\n  [7]: http://static.zybuluo.com/allon6/wgf5sxdj3c7sxuxq4z194v4n/image_1bel90rvjdr376a1ag913e84951g.png\n","slug":"第01章 计算机系统漫游","published":1,"updated":"2017-11-25T09:05:35.751Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjahvvny30015pv4nz1he1yd3","content":"<p>#第01章 计算机系统漫游</p>\n<p>Tags: 深入理解计算机系统</p>\n<p>[TOC]</p>\n<hr>\n<h2><span id=\"第一章\"> 第一章</span></h2>\n<hr>\n<p><img src=\"http://static.zybuluo.com/allon6/qciw23zdgnf96cr1yys34mjo/image_1beikj90n1f6gv9a1fjbv6n18m49.png\" alt=\"image_1beikj90n1f6gv9a1fjbv6n18m49.png-133.7kB\"></p>\n<blockquote>\n<ul>\n<li>预编译阶段 - 生成.i文件：  g++ -E hello.c -o hello.i</li>\n<li>编译阶段 - 生成汇编文本.s文件： g++ -S hello.i -o hello.s</li>\n<li>汇编阶段 -  生成.o文件： g++ -c hello.s -o hello.o</li>\n<li>链接阶段 -  生成可执行文件： g++ hello.o -o hello</li>\n</ul>\n</blockquote>\n<p><strong>g++ gcc编译参数</strong></p>\n<table>\n<thead>\n<tr>\n<th>参数</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>-c</td>\n<td>只编译不链接，生成*.o文件</td>\n</tr>\n<tr>\n<td>-S</td>\n<td>生成汇编代码*.s文件</td>\n</tr>\n<tr>\n<td>-E</td>\n<td>预编译 生成*.i文件</td>\n</tr>\n<tr>\n<td>-g</td>\n<td>在可执行程序里包含了调试信息，可用 gdb 调试</td>\n</tr>\n<tr>\n<td>-o</td>\n<td>把输出文件输出到指定文件里</td>\n</tr>\n<tr>\n<td>-static</td>\n<td>链接静态链接库</td>\n</tr>\n<tr>\n<td>-library</td>\n<td>链接名为library的链接库</td>\n</tr>\n</tbody>\n</table>\n<p>###系统硬件组成<br>\n<img src=\"http://static.zybuluo.com/allon6/k5g8amzzepo43qi1de8lb2ir/image_1beionion1pao1p14p7u5v81kbo13.png\" alt=\"image_1beionion1pao1p14p7u5v81kbo13.png-320.4kB\"><br>\n####总线####<br>\n32位系统总线是4个字节（32个位）<br>\n64位系统总线是8个字节（64个位）<br>\n总线宽度一般就是一个字长</p>\n<p>####I/O设备<br>\nI/O设备通过控制器和适配器与I/O总线相连：</p>\n<blockquote>\n<ul>\n<li>控制器是镶在主板的芯片组，如集显。</li>\n<li>适配器就是插槽，如独显。</li>\n</ul>\n</blockquote>\n<p>####CPU 中央处理单元（Central Processing Unit）</p>\n<ol>\n<li>处理器的核心是一个大小为一个<strong>字</strong>的存储设备（或寄存器），称为程序计数器（PC)。在任何时 刻，PC都指向主存中的某条机器语言指令（即含有该条指令的地址）。</li>\n<li>从开机到关机，CPU一直更新PC使其指向一下条指令地址。</li>\n<li>指令是按照严格顺序执行的，执行完一条就更新PC指向下一条。两条指令地址不一定是相邻的。</li>\n</ol>\n<p>####主存<br>\n主内存就是一个从index 0开始的字节数组，每个内存字节都有唯一的index也就是唯一的地址。</p>\n<h4><span id=\"寄存器\"> 寄存器</span></h4>\n<p>寄存器文件是一个小的存储设备，由一组单个字长的寄存器组成。每个寄存器都有唯一的名字。</p>\n<h4><span id=\"cpu指令执行过程\"> CPU指令执行过程</span></h4>\n<p>几乎所有的冯•诺伊曼型计算机的CPU，其工作都可以分为5个阶段：取指令、指令译码、执行指令、访存取数和结果写回<br>\n<img src=\"http://static.zybuluo.com/allon6/hoxu6w8adddrf52uy7a302ap/image_1bgvo3oi51mtlrjp1ijf1ek4t39m.png\" alt=\"image_1bgvo3oi51mtlrjp1ijf1ek4t39m.png-46.2kB\"></p>\n<p>（1）指令周期</p>\n<p>CPU取出一条指令并执行该指令所需的时间称为指令周期。<br>\n指令周期的长短与指令的复杂程度有关。</p>\n<p>（2）CPU周期</p>\n<p>指令周期常常用若干个CPU周期数来表示。<br>\n由于CPU内部的操作速度较快，而CPU访问一次主存所花的时间较长，因此通常用从主存读取一条指令的最短时间来规定CPU周期。<br>\nCPU周期也称为机器周期。</p>\n<p>（3）时钟周期</p>\n<p>一个CPU周期包含有若干个时钟周期。<br>\n时钟周期是处理操作的最基本时间单位，由机器的主频决定。<br>\n一个CPU周期的时间宽度由若干个时钟周期的总和决定。</p>\n<p><img src=\"http://static.zybuluo.com/allon6/se1cnxl50kpwfdfr1qrk3p7x/image_1bgvp0q9ksh5hdop3n1i2f3g31g.png\" alt=\"采用定长CPU周期的指令周期示意图\"></p>\n<p>（4）取出和执行任何一条指令所需的最短时间为两个CPU周期。</p>\n<p>任何一条指令，它的指令周期至少需要两个CPU周期，而复杂指令的指令周期则需要更多的CPU周期。这是因为，一条指令的取出阶段需要一个CPU周期时间，而一条指令的执行阶段则需要至少一个CPU周期时间。由于不同复杂度指令的执行周期所需的CPU周期数不尽相等，因此，各种指令的指令周期也是不尽相同的。z</p>\n<h4><span id=\"一个hello-world程序执行过程\"> 一个hello world程序执行过程</span></h4>\n<ul>\n<li>利用直接存储器存取（DMA）直接从磁盘不经过cpu拷贝运行文件到主存</li>\n<li>cpu从主存拷贝字符串到寄存器再从寄存器拷贝到显示器</li>\n</ul>\n<h3><span id=\"存储器\"> 存储器</span></h3>\n<p>####CPU缓存<br>\n运行速度很多消耗在拷贝过程， 由于寄存器越来越快，主存的速度严重跟不上。中间出现了L1 L2 L3这种高速缓存。为CPU提前从主存中获取数据到缓存。</p>\n<ul>\n<li>寄存器(几百字节)速度最快比主存快100倍</li>\n<li>L1(几万字节，位于处理器芯片上) 访问速度和寄存器几乎一样</li>\n<li>L2(数十至百万字节特殊总线连接到处理器)比主存快5-10倍</li>\n<li>主存(几十亿字节)</li>\n<li>磁盘读取单个字的时间开销比主存大1000万倍<br>\n<img src=\"http://static.zybuluo.com/allon6/tw906gbl5wwhkrrmrzxmga18/image_1bejtnn9t1lp2aiqk2a1hrjes0m.png\" alt=\"image_1bejtnn9t1lp2aiqk2a1hrjes0m.png-138.7kB\"></li>\n</ul>\n<h4><span id=\"结构图\"> 结构图</span></h4>\n<p><img src=\"http://static.zybuluo.com/allon6/rbd8q1olikakhvm6lkcibeh1/image_1bejuddb8lan1ou51l0v93915bp13.png\" alt=\"image_1bejuddb8lan1ou51l0v93915bp13.png-281kB\"></p>\n<h4><span id=\"虚拟内存\"> 虚拟内存</span></h4>\n<p>虚拟内存和CPU缓存作用一样，它是用来做磁盘的缓存。</p>\n<h3><span id=\"多核处理器结构\"> 多核处理器结构</span></h3>\n<p><img src=\"http://static.zybuluo.com/allon6/wgf5sxdj3c7sxuxq4z194v4n/image_1bel90rvjdr376a1ag913e84951g.png\" alt=\"image_1bel90rvjdr376a1ag913e84951g.png-433.5kB\"></p>\n<ul>\n<li>由高到低：线程级-&gt;多指令并行-&gt;单指令并行</li>\n</ul>\n<h4><span id=\"超线程\"> 超线程</span></h4>\n<p>4核能跑8条线程，就是一种超线程。比如当一个CPU在正等L1缓存的数据，那么这会它也可以跑另一个线程的运算。Intel Core I7就带有超线程技术。</p>\n<h4><span id=\"指令级并行\"> 指令级并行</span></h4>\n<p>一口气执行多条指令，超标量。</p>\n<h4><span id=\"单指令多数据并行simd\"> 单指令多数据并行（SIMD）</span></h4>\n<blockquote>\n<p>SIMD 指令多是为了提高处理影像 、 声音和视频数据应用的执行速度。虽然有些编译器试图从程序中自动抽取 SIMD 并行性，但是更可靠的方法是使用编译器支持的特殊向量数据类型来写程序，例如GCC 就支持向量数据类型。作为对比较通用的程序优化讲述的补充，在网络旁注 OPT:SIMD 中描述了这种编程方式 。</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<p>#第01章 计算机系统漫游</p>\n<p>Tags: 深入理解计算机系统</p>\n<p>[TOC]</p>\n<hr>\n<h2 id=\"第一章\"><a class=\"markdownIt-Anchor\" href=\"#第一章\"></a> 第一章</h2>\n<hr>\n<p><img src=\"http://static.zybuluo.com/allon6/qciw23zdgnf96cr1yys34mjo/image_1beikj90n1f6gv9a1fjbv6n18m49.png\" alt=\"image_1beikj90n1f6gv9a1fjbv6n18m49.png-133.7kB\"></p>\n<blockquote>\n<ul>\n<li>预编译阶段 - 生成.i文件：  g++ -E hello.c -o hello.i</li>\n<li>编译阶段 - 生成汇编文本.s文件： g++ -S hello.i -o hello.s</li>\n<li>汇编阶段 -  生成.o文件： g++ -c hello.s -o hello.o</li>\n<li>链接阶段 -  生成可执行文件： g++ hello.o -o hello</li>\n</ul>\n</blockquote>\n<p><strong>g++ gcc编译参数</strong></p>\n<table>\n<thead>\n<tr>\n<th>参数</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>-c</td>\n<td>只编译不链接，生成*.o文件</td>\n</tr>\n<tr>\n<td>-S</td>\n<td>生成汇编代码*.s文件</td>\n</tr>\n<tr>\n<td>-E</td>\n<td>预编译 生成*.i文件</td>\n</tr>\n<tr>\n<td>-g</td>\n<td>在可执行程序里包含了调试信息，可用 gdb 调试</td>\n</tr>\n<tr>\n<td>-o</td>\n<td>把输出文件输出到指定文件里</td>\n</tr>\n<tr>\n<td>-static</td>\n<td>链接静态链接库</td>\n</tr>\n<tr>\n<td>-library</td>\n<td>链接名为library的链接库</td>\n</tr>\n</tbody>\n</table>\n<p>###系统硬件组成<br>\n<img src=\"http://static.zybuluo.com/allon6/k5g8amzzepo43qi1de8lb2ir/image_1beionion1pao1p14p7u5v81kbo13.png\" alt=\"image_1beionion1pao1p14p7u5v81kbo13.png-320.4kB\"><br>\n####总线####<br>\n32位系统总线是4个字节（32个位）<br>\n64位系统总线是8个字节（64个位）<br>\n总线宽度一般就是一个字长</p>\n<p>####I/O设备<br>\nI/O设备通过控制器和适配器与I/O总线相连：</p>\n<blockquote>\n<ul>\n<li>控制器是镶在主板的芯片组，如集显。</li>\n<li>适配器就是插槽，如独显。</li>\n</ul>\n</blockquote>\n<p>####CPU 中央处理单元（Central Processing Unit）</p>\n<ol>\n<li>处理器的核心是一个大小为一个<strong>字</strong>的存储设备（或寄存器），称为程序计数器（PC)。在任何时 刻，PC都指向主存中的某条机器语言指令（即含有该条指令的地址）。</li>\n<li>从开机到关机，CPU一直更新PC使其指向一下条指令地址。</li>\n<li>指令是按照严格顺序执行的，执行完一条就更新PC指向下一条。两条指令地址不一定是相邻的。</li>\n</ol>\n<p>####主存<br>\n主内存就是一个从index 0开始的字节数组，每个内存字节都有唯一的index也就是唯一的地址。</p>\n<h4 id=\"寄存器\"><a class=\"markdownIt-Anchor\" href=\"#寄存器\"></a> 寄存器</h4>\n<p>寄存器文件是一个小的存储设备，由一组单个字长的寄存器组成。每个寄存器都有唯一的名字。</p>\n<h4 id=\"cpu指令执行过程\"><a class=\"markdownIt-Anchor\" href=\"#cpu指令执行过程\"></a> CPU指令执行过程</h4>\n<p>几乎所有的冯•诺伊曼型计算机的CPU，其工作都可以分为5个阶段：取指令、指令译码、执行指令、访存取数和结果写回<br>\n<img src=\"http://static.zybuluo.com/allon6/hoxu6w8adddrf52uy7a302ap/image_1bgvo3oi51mtlrjp1ijf1ek4t39m.png\" alt=\"image_1bgvo3oi51mtlrjp1ijf1ek4t39m.png-46.2kB\"></p>\n<p>（1）指令周期</p>\n<p>CPU取出一条指令并执行该指令所需的时间称为指令周期。<br>\n指令周期的长短与指令的复杂程度有关。</p>\n<p>（2）CPU周期</p>\n<p>指令周期常常用若干个CPU周期数来表示。<br>\n由于CPU内部的操作速度较快，而CPU访问一次主存所花的时间较长，因此通常用从主存读取一条指令的最短时间来规定CPU周期。<br>\nCPU周期也称为机器周期。</p>\n<p>（3）时钟周期</p>\n<p>一个CPU周期包含有若干个时钟周期。<br>\n时钟周期是处理操作的最基本时间单位，由机器的主频决定。<br>\n一个CPU周期的时间宽度由若干个时钟周期的总和决定。</p>\n<p><img src=\"http://static.zybuluo.com/allon6/se1cnxl50kpwfdfr1qrk3p7x/image_1bgvp0q9ksh5hdop3n1i2f3g31g.png\" alt=\"采用定长CPU周期的指令周期示意图\"></p>\n<p>（4）取出和执行任何一条指令所需的最短时间为两个CPU周期。</p>\n<p>任何一条指令，它的指令周期至少需要两个CPU周期，而复杂指令的指令周期则需要更多的CPU周期。这是因为，一条指令的取出阶段需要一个CPU周期时间，而一条指令的执行阶段则需要至少一个CPU周期时间。由于不同复杂度指令的执行周期所需的CPU周期数不尽相等，因此，各种指令的指令周期也是不尽相同的。z</p>\n<h4 id=\"一个hello-world程序执行过程\"><a class=\"markdownIt-Anchor\" href=\"#一个hello-world程序执行过程\"></a> 一个hello world程序执行过程</h4>\n<ul>\n<li>利用直接存储器存取（DMA）直接从磁盘不经过cpu拷贝运行文件到主存</li>\n<li>cpu从主存拷贝字符串到寄存器再从寄存器拷贝到显示器</li>\n</ul>\n<h3 id=\"存储器\"><a class=\"markdownIt-Anchor\" href=\"#存储器\"></a> 存储器</h3>\n<p>####CPU缓存<br>\n运行速度很多消耗在拷贝过程， 由于寄存器越来越快，主存的速度严重跟不上。中间出现了L1 L2 L3这种高速缓存。为CPU提前从主存中获取数据到缓存。</p>\n<ul>\n<li>寄存器(几百字节)速度最快比主存快100倍</li>\n<li>L1(几万字节，位于处理器芯片上) 访问速度和寄存器几乎一样</li>\n<li>L2(数十至百万字节特殊总线连接到处理器)比主存快5-10倍</li>\n<li>主存(几十亿字节)</li>\n<li>磁盘读取单个字的时间开销比主存大1000万倍<br>\n<img src=\"http://static.zybuluo.com/allon6/tw906gbl5wwhkrrmrzxmga18/image_1bejtnn9t1lp2aiqk2a1hrjes0m.png\" alt=\"image_1bejtnn9t1lp2aiqk2a1hrjes0m.png-138.7kB\"></li>\n</ul>\n<h4 id=\"结构图\"><a class=\"markdownIt-Anchor\" href=\"#结构图\"></a> 结构图</h4>\n<p><img src=\"http://static.zybuluo.com/allon6/rbd8q1olikakhvm6lkcibeh1/image_1bejuddb8lan1ou51l0v93915bp13.png\" alt=\"image_1bejuddb8lan1ou51l0v93915bp13.png-281kB\"></p>\n<h4 id=\"虚拟内存\"><a class=\"markdownIt-Anchor\" href=\"#虚拟内存\"></a> 虚拟内存</h4>\n<p>虚拟内存和CPU缓存作用一样，它是用来做磁盘的缓存。</p>\n<h3 id=\"多核处理器结构\"><a class=\"markdownIt-Anchor\" href=\"#多核处理器结构\"></a> 多核处理器结构</h3>\n<p><img src=\"http://static.zybuluo.com/allon6/wgf5sxdj3c7sxuxq4z194v4n/image_1bel90rvjdr376a1ag913e84951g.png\" alt=\"image_1bel90rvjdr376a1ag913e84951g.png-433.5kB\"></p>\n<ul>\n<li>由高到低：线程级-&gt;多指令并行-&gt;单指令并行</li>\n</ul>\n<h4 id=\"超线程\"><a class=\"markdownIt-Anchor\" href=\"#超线程\"></a> 超线程</h4>\n<p>4核能跑8条线程，就是一种超线程。比如当一个CPU在正等L1缓存的数据，那么这会它也可以跑另一个线程的运算。Intel Core I7就带有超线程技术。</p>\n<h4 id=\"指令级并行\"><a class=\"markdownIt-Anchor\" href=\"#指令级并行\"></a> 指令级并行</h4>\n<p>一口气执行多条指令，超标量。</p>\n<h4 id=\"单指令多数据并行simd\"><a class=\"markdownIt-Anchor\" href=\"#单指令多数据并行simd\"></a> 单指令多数据并行（SIMD）</h4>\n<blockquote>\n<p>SIMD 指令多是为了提高处理影像 、 声音和视频数据应用的执行速度。虽然有些编译器试图从程序中自动抽取 SIMD 并行性，但是更可靠的方法是使用编译器支持的特殊向量数据类型来写程序，例如GCC 就支持向量数据类型。作为对比较通用的程序优化讲述的补充，在网络旁注 OPT:SIMD 中描述了这种编程方式 。</p>\n</blockquote>\n"},{"title":"第02章 程序结构和执行","catalog":true,"date":"2017-02-22T09:21:29.000Z","header-img":"/img/05.jpg","_content":"\n# 第02章 程序结构和执行\n\nTags: 深入理解计算机系统\n\n[TOC]\n\n---\n\n## 信息的存储\n总线宽度一般就是一个字长，一个字长的位数，就决定着这个系统的寻址宽度。\n字长为 $n$ 那么它的寻址宽度为：$0$ ~ $(2^n - 1)$  程序最多访问$2^n$个字节。\n\nlittle endian(小端）目前android和ios都采用的是little endian。linux和windows也一样。\nbig endian(大端）  java是继承了SUN的系统规则属于小端。所以在java网络传输时尤其注意。\n![image_1benbhdpfh541jgr13s3fs1qs39.png-172.3kB][1]\n\nC、C++都支持无符号类型，java仅支持有符号。\n\n## 整数的表示\n![image_1bep6k353hh3apb1a1j12hn1oilm.png-271.8kB][2]\n<br>\n### 无符号编码\n全是正的，所以表示的正数值域很宽。\n$$B2U_4([1111]) = 1\\cdot2^3+1\\cdot2^2+1\\cdot2^1+1\\cdot2^0 = 15$$\n#### 有符号补码 - 常用\n最高位为负数，表示的值域：$-2^{4-1}$ ~ $2^{4-1} -1$，由此可以看出，因为0是非负数，所以多占了一个。有符号的位不是对称的。负数比正位大1。负数最小值在正方向上没有与之对应的数。\n$$B2T_4([1111]) = -1\\cdot2^3+1\\cdot2^2+1\\cdot2^1+1\\cdot2^0 = -1$$\n### 有符号反码\n和补码一样，只是最高位多减个1  ：$-2^{4-1} -1$\n###有符号原码\n最高位是-1： $-1\\cdot\\sum_{i=1}^nx\\cdot2^n$\n### 有无符号转换\n![image_1bepe8di71l3kvjgbkjlvii9p9.png-190kB][3]\n### 整数类型转换\n如果称位数少的为“小”，位数多的为“大”\n小 $\\to$ 大 ：零扩展\n大 $\\to$ 小 ：截断\n## 整数的运算\n判断加法溢出。用最大或者最小值跟目标值求差，再用差和另一个加数比较。如果那个加数比这个差大。就溢出。\n![image_1bepg9fg81sp6ceh1k5j1b4t16adm.png-599.8kB][4]\n\n## 浮点数\n![image_1beqdtlenf5q74h1v8214951gc013.png-126.1kB][5]\n>* 定点表示：**约定**机器中所有数据的小数点位置是固定不变的。由于约定在固定的位置，小数点就不再使用记号“.”来表示。通常将数据表示成纯小数或纯整数。定点数的表示方法就是整数是$\\sum_{i=1}^n 2^i $ ，小数就是2的负幂次。这种的缺点是表达的数据很窄。\n\n>* 浮点表示  - IEEE 754标准：浮点指小数点不是固定的，任意十进制数可以表示为：$$N = M \\cdot10^E$$\n比如：$$234.56 = 2.3456*10^2$$\n只保留一位整数这种方式叫规格化表示。\n$E$(Exponent) 阶码，它控制着小数点在什么位置上。\n$M$(Significand)尾数，也叫有效数。是核心数值。下图中的Fraction。\n![image_1besrrtt31jj3i8b17c1jfkohd1g.png-13.9kB][6]\n\n**这样就可以通过阶码E做为幂次来表示小数点在什么位置，以上情况在二进制上亦然:**\n### $$V = (-1)^s \\cdot M \\cdot 2^E$$\n\n### 为什么32位浮点数阶码要有偏移量 ？\n阶码有正有负，为了方便计算，加上一个比较大的正数。把所有阶码转为正值。这使得两个浮点数的指数大小的比较更为容易，实际上可以按照字典序比较两个浮点表示的大小。\n### 为什么偏移是127 ？\n1. 8位移码的取值范围为0~255（00000000~11111111），但在浮点数的阶码中，00000000与11111111被保留用作特殊情况，所以阶码可用范围只有1~254，总共有254个值。\n2. 8位有符号数取值范围为-128~+127（10000000~01111111），这里的二进制用补码表示，其中特别规定补码10000000没有原码，为-128的补码，总共有256个值。\n3. 如果采用偏置128，在表达+127时会产生上溢（移码11111111被保留），所以在阶码中偏置为（128-1），与此同时，在表达-127时会产生下溢（移码00000000被保留），所以阶码中去掉-127与-128，取值范围为-126~127，总共254个值。\n### 浮点运算\n编译器对于浮点型运算可以开启优化，而部分优化会丢失极小的精度。但是默认情况下编译器比较保守的不会主动进行指令优化。\n\n\n  [1]: http://static.zybuluo.com/allon6/xugxaf8oenhxkyvemsekx8xg/image_1benbhdpfh541jgr13s3fs1qs39.png\n  [2]: http://static.zybuluo.com/allon6/qhvg4rb4ss9sylo1l4bufwba/image_1bep6k353hh3apb1a1j12hn1oilm.png\n  [3]: http://static.zybuluo.com/allon6/7hxlly2j213a2w4864qn4vhn/image_1bepe8di71l3kvjgbkjlvii9p9.png\n  [4]: http://static.zybuluo.com/allon6/tlrw3y8lg8nqwidsuw9f36cj/image_1bepg9fg81sp6ceh1k5j1b4t16adm.png\n  [5]: http://static.zybuluo.com/allon6/f4v4p80nrlyvueonpxejq2wi/image_1beqdtlenf5q74h1v8214951gc013.png\n  [6]: http://static.zybuluo.com/allon6/g3ei6s88dmjp66u2da89ixr7/image_1besrrtt31jj3i8b17c1jfkohd1g.png\n","source":"_posts/第02章 程序结构和执行.md","raw":"---\ntitle: \"第02章 程序结构和执行\"\ncatalog: true\ndate: 2017-02-22 17:21:29\nheader-img: \"/img/05.jpg\"\ntags: \"深入理解计算机系统\"\n---\n\n# 第02章 程序结构和执行\n\nTags: 深入理解计算机系统\n\n[TOC]\n\n---\n\n## 信息的存储\n总线宽度一般就是一个字长，一个字长的位数，就决定着这个系统的寻址宽度。\n字长为 $n$ 那么它的寻址宽度为：$0$ ~ $(2^n - 1)$  程序最多访问$2^n$个字节。\n\nlittle endian(小端）目前android和ios都采用的是little endian。linux和windows也一样。\nbig endian(大端）  java是继承了SUN的系统规则属于小端。所以在java网络传输时尤其注意。\n![image_1benbhdpfh541jgr13s3fs1qs39.png-172.3kB][1]\n\nC、C++都支持无符号类型，java仅支持有符号。\n\n## 整数的表示\n![image_1bep6k353hh3apb1a1j12hn1oilm.png-271.8kB][2]\n<br>\n### 无符号编码\n全是正的，所以表示的正数值域很宽。\n$$B2U_4([1111]) = 1\\cdot2^3+1\\cdot2^2+1\\cdot2^1+1\\cdot2^0 = 15$$\n#### 有符号补码 - 常用\n最高位为负数，表示的值域：$-2^{4-1}$ ~ $2^{4-1} -1$，由此可以看出，因为0是非负数，所以多占了一个。有符号的位不是对称的。负数比正位大1。负数最小值在正方向上没有与之对应的数。\n$$B2T_4([1111]) = -1\\cdot2^3+1\\cdot2^2+1\\cdot2^1+1\\cdot2^0 = -1$$\n### 有符号反码\n和补码一样，只是最高位多减个1  ：$-2^{4-1} -1$\n###有符号原码\n最高位是-1： $-1\\cdot\\sum_{i=1}^nx\\cdot2^n$\n### 有无符号转换\n![image_1bepe8di71l3kvjgbkjlvii9p9.png-190kB][3]\n### 整数类型转换\n如果称位数少的为“小”，位数多的为“大”\n小 $\\to$ 大 ：零扩展\n大 $\\to$ 小 ：截断\n## 整数的运算\n判断加法溢出。用最大或者最小值跟目标值求差，再用差和另一个加数比较。如果那个加数比这个差大。就溢出。\n![image_1bepg9fg81sp6ceh1k5j1b4t16adm.png-599.8kB][4]\n\n## 浮点数\n![image_1beqdtlenf5q74h1v8214951gc013.png-126.1kB][5]\n>* 定点表示：**约定**机器中所有数据的小数点位置是固定不变的。由于约定在固定的位置，小数点就不再使用记号“.”来表示。通常将数据表示成纯小数或纯整数。定点数的表示方法就是整数是$\\sum_{i=1}^n 2^i $ ，小数就是2的负幂次。这种的缺点是表达的数据很窄。\n\n>* 浮点表示  - IEEE 754标准：浮点指小数点不是固定的，任意十进制数可以表示为：$$N = M \\cdot10^E$$\n比如：$$234.56 = 2.3456*10^2$$\n只保留一位整数这种方式叫规格化表示。\n$E$(Exponent) 阶码，它控制着小数点在什么位置上。\n$M$(Significand)尾数，也叫有效数。是核心数值。下图中的Fraction。\n![image_1besrrtt31jj3i8b17c1jfkohd1g.png-13.9kB][6]\n\n**这样就可以通过阶码E做为幂次来表示小数点在什么位置，以上情况在二进制上亦然:**\n### $$V = (-1)^s \\cdot M \\cdot 2^E$$\n\n### 为什么32位浮点数阶码要有偏移量 ？\n阶码有正有负，为了方便计算，加上一个比较大的正数。把所有阶码转为正值。这使得两个浮点数的指数大小的比较更为容易，实际上可以按照字典序比较两个浮点表示的大小。\n### 为什么偏移是127 ？\n1. 8位移码的取值范围为0~255（00000000~11111111），但在浮点数的阶码中，00000000与11111111被保留用作特殊情况，所以阶码可用范围只有1~254，总共有254个值。\n2. 8位有符号数取值范围为-128~+127（10000000~01111111），这里的二进制用补码表示，其中特别规定补码10000000没有原码，为-128的补码，总共有256个值。\n3. 如果采用偏置128，在表达+127时会产生上溢（移码11111111被保留），所以在阶码中偏置为（128-1），与此同时，在表达-127时会产生下溢（移码00000000被保留），所以阶码中去掉-127与-128，取值范围为-126~127，总共254个值。\n### 浮点运算\n编译器对于浮点型运算可以开启优化，而部分优化会丢失极小的精度。但是默认情况下编译器比较保守的不会主动进行指令优化。\n\n\n  [1]: http://static.zybuluo.com/allon6/xugxaf8oenhxkyvemsekx8xg/image_1benbhdpfh541jgr13s3fs1qs39.png\n  [2]: http://static.zybuluo.com/allon6/qhvg4rb4ss9sylo1l4bufwba/image_1bep6k353hh3apb1a1j12hn1oilm.png\n  [3]: http://static.zybuluo.com/allon6/7hxlly2j213a2w4864qn4vhn/image_1bepe8di71l3kvjgbkjlvii9p9.png\n  [4]: http://static.zybuluo.com/allon6/tlrw3y8lg8nqwidsuw9f36cj/image_1bepg9fg81sp6ceh1k5j1b4t16adm.png\n  [5]: http://static.zybuluo.com/allon6/f4v4p80nrlyvueonpxejq2wi/image_1beqdtlenf5q74h1v8214951gc013.png\n  [6]: http://static.zybuluo.com/allon6/g3ei6s88dmjp66u2da89ixr7/image_1besrrtt31jj3i8b17c1jfkohd1g.png\n","slug":"第02章 程序结构和执行","published":1,"updated":"2017-11-25T09:05:49.098Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjahvvny40016pv4nuvpc92ia","content":"<h1><span id=\"第02章-程序结构和执行\"> 第02章 程序结构和执行</span></h1>\n<p>Tags: 深入理解计算机系统</p>\n<p>[TOC]</p>\n<hr>\n<h2><span id=\"信息的存储\"> 信息的存储</span></h2>\n<p>总线宽度一般就是一个字长，一个字长的位数，就决定着这个系统的寻址宽度。<br>\n字长为 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"strut\" style=\"height:0.43056em;\"></span><span class=\"strut bottom\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"base textstyle uncramped\"><span class=\"mord mathit\">n</span></span></span></span> 那么它的寻址宽度为：<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding=\"application/x-tex\">0</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"strut\" style=\"height:0.64444em;\"></span><span class=\"strut bottom\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"base textstyle uncramped\"><span class=\"mord mathrm\">0</span></span></span></span> ~ <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mo>(</mo><msup><mn>2</mn><mi>n</mi></msup><mo>−</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding=\"application/x-tex\">(2^n - 1)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"strut\" style=\"height:0.75em;\"></span><span class=\"strut bottom\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"base textstyle uncramped\"><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathrm\">2</span><span class=\"vlist\"><span style=\"top:-0.363em;margin-right:0.05em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"reset-textstyle scriptstyle uncramped\"><span class=\"mord mathit\">n</span></span></span><span class=\"baseline-fix\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span>​</span></span></span><span class=\"mbin\">−</span><span class=\"mord mathrm\">1</span><span class=\"mclose\">)</span></span></span></span>  程序最多访问<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msup><mn>2</mn><mi>n</mi></msup></mrow><annotation encoding=\"application/x-tex\">2^n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"strut\" style=\"height:0.664392em;\"></span><span class=\"strut bottom\" style=\"height:0.664392em;vertical-align:0em;\"></span><span class=\"base textstyle uncramped\"><span class=\"mord\"><span class=\"mord mathrm\">2</span><span class=\"vlist\"><span style=\"top:-0.363em;margin-right:0.05em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"reset-textstyle scriptstyle uncramped\"><span class=\"mord mathit\">n</span></span></span><span class=\"baseline-fix\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span>​</span></span></span></span></span></span>个字节。</p>\n<p>little endian(小端）目前android和ios都采用的是little endian。linux和windows也一样。<br>\nbig endian(大端）  java是继承了SUN的系统规则属于小端。所以在java网络传输时尤其注意。<br>\n<img src=\"http://static.zybuluo.com/allon6/xugxaf8oenhxkyvemsekx8xg/image_1benbhdpfh541jgr13s3fs1qs39.png\" alt=\"image_1benbhdpfh541jgr13s3fs1qs39.png-172.3kB\"></p>\n<p>C、C++都支持无符号类型，java仅支持有符号。</p>\n<h2><span id=\"整数的表示\"> 整数的表示</span></h2>\n<p><img src=\"http://static.zybuluo.com/allon6/qhvg4rb4ss9sylo1l4bufwba/image_1bep6k353hh3apb1a1j12hn1oilm.png\" alt=\"image_1bep6k353hh3apb1a1j12hn1oilm.png-271.8kB\"><br>\n<br></p>\n<h3><span id=\"无符号编码\"> 无符号编码</span></h3>\n<p>全是正的，所以表示的正数值域很宽。</p>\n<p><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>B</mi><mn>2</mn><msub><mi>U</mi><mn>4</mn></msub><mo>(</mo><mo>[</mo><mn>1</mn><mn>1</mn><mn>1</mn><mn>1</mn><mo>]</mo><mo>)</mo><mo>=</mo><mn>1</mn><mo>⋅</mo><msup><mn>2</mn><mn>3</mn></msup><mo>+</mo><mn>1</mn><mo>⋅</mo><msup><mn>2</mn><mn>2</mn></msup><mo>+</mo><mn>1</mn><mo>⋅</mo><msup><mn>2</mn><mn>1</mn></msup><mo>+</mo><mn>1</mn><mo>⋅</mo><msup><mn>2</mn><mn>0</mn></msup><mo>=</mo><mn>1</mn><mn>5</mn></mrow><annotation encoding=\"application/x-tex\">B2U_4([1111]) = 1\\cdot2^3+1\\cdot2^2+1\\cdot2^1+1\\cdot2^0 = 15\n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"strut\" style=\"height:0.8641079999999999em;\"></span><span class=\"strut bottom\" style=\"height:1.1141079999999999em;vertical-align:-0.25em;\"></span><span class=\"base displaystyle textstyle uncramped\"><span class=\"mord mathit\" style=\"margin-right:0.05017em;\">B</span><span class=\"mord mathrm\">2</span><span class=\"mord\"><span class=\"mord mathit\" style=\"margin-right:0.10903em;\">U</span><span class=\"vlist\"><span style=\"top:0.15em;margin-right:0.05em;margin-left:-0.10903em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"reset-textstyle scriptstyle cramped\"><span class=\"mord mathrm\">4</span></span></span><span class=\"baseline-fix\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span>​</span></span></span><span class=\"mopen\">(</span><span class=\"mopen\">[</span><span class=\"mord mathrm\">1</span><span class=\"mord mathrm\">1</span><span class=\"mord mathrm\">1</span><span class=\"mord mathrm\">1</span><span class=\"mclose\">]</span><span class=\"mclose\">)</span><span class=\"mrel\">=</span><span class=\"mord mathrm\">1</span><span class=\"mbin\">⋅</span><span class=\"mord\"><span class=\"mord mathrm\">2</span><span class=\"vlist\"><span style=\"top:-0.413em;margin-right:0.05em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"reset-textstyle scriptstyle uncramped\"><span class=\"mord mathrm\">3</span></span></span><span class=\"baseline-fix\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span>​</span></span></span><span class=\"mbin\">+</span><span class=\"mord mathrm\">1</span><span class=\"mbin\">⋅</span><span class=\"mord\"><span class=\"mord mathrm\">2</span><span class=\"vlist\"><span style=\"top:-0.413em;margin-right:0.05em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"reset-textstyle scriptstyle uncramped\"><span class=\"mord mathrm\">2</span></span></span><span class=\"baseline-fix\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span>​</span></span></span><span class=\"mbin\">+</span><span class=\"mord mathrm\">1</span><span class=\"mbin\">⋅</span><span class=\"mord\"><span class=\"mord mathrm\">2</span><span class=\"vlist\"><span style=\"top:-0.413em;margin-right:0.05em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"reset-textstyle scriptstyle uncramped\"><span class=\"mord mathrm\">1</span></span></span><span class=\"baseline-fix\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span>​</span></span></span><span class=\"mbin\">+</span><span class=\"mord mathrm\">1</span><span class=\"mbin\">⋅</span><span class=\"mord\"><span class=\"mord mathrm\">2</span><span class=\"vlist\"><span style=\"top:-0.413em;margin-right:0.05em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"reset-textstyle scriptstyle uncramped\"><span class=\"mord mathrm\">0</span></span></span><span class=\"baseline-fix\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span>​</span></span></span><span class=\"mrel\">=</span><span class=\"mord mathrm\">1</span><span class=\"mord mathrm\">5</span></span></span></span></span></p>\n<h4><span id=\"有符号补码-常用\"> 有符号补码 - 常用</span></h4>\n<p>最高位为负数，表示的值域：<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mo>−</mo><msup><mn>2</mn><mrow><mn>4</mn><mo>−</mo><mn>1</mn></mrow></msup></mrow><annotation encoding=\"application/x-tex\">-2^{4-1}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"strut\" style=\"height:0.8141079999999999em;\"></span><span class=\"strut bottom\" style=\"height:0.897438em;vertical-align:-0.08333em;\"></span><span class=\"base textstyle uncramped\"><span class=\"mord\">−</span><span class=\"mord\"><span class=\"mord mathrm\">2</span><span class=\"vlist\"><span style=\"top:-0.363em;margin-right:0.05em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"reset-textstyle scriptstyle uncramped\"><span class=\"mord scriptstyle uncramped\"><span class=\"mord mathrm\">4</span><span class=\"mbin\">−</span><span class=\"mord mathrm\">1</span></span></span></span><span class=\"baseline-fix\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span>​</span></span></span></span></span></span> ~ <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msup><mn>2</mn><mrow><mn>4</mn><mo>−</mo><mn>1</mn></mrow></msup><mo>−</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">2^{4-1} -1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"strut\" style=\"height:0.8141079999999999em;\"></span><span class=\"strut bottom\" style=\"height:0.897438em;vertical-align:-0.08333em;\"></span><span class=\"base textstyle uncramped\"><span class=\"mord\"><span class=\"mord mathrm\">2</span><span class=\"vlist\"><span style=\"top:-0.363em;margin-right:0.05em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"reset-textstyle scriptstyle uncramped\"><span class=\"mord scriptstyle uncramped\"><span class=\"mord mathrm\">4</span><span class=\"mbin\">−</span><span class=\"mord mathrm\">1</span></span></span></span><span class=\"baseline-fix\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span>​</span></span></span><span class=\"mbin\">−</span><span class=\"mord mathrm\">1</span></span></span></span>，由此可以看出，因为0是非负数，所以多占了一个。有符号的位不是对称的。负数比正位大1。负数最小值在正方向上没有与之对应的数。</p>\n<p><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>B</mi><mn>2</mn><msub><mi>T</mi><mn>4</mn></msub><mo>(</mo><mo>[</mo><mn>1</mn><mn>1</mn><mn>1</mn><mn>1</mn><mo>]</mo><mo>)</mo><mo>=</mo><mo>−</mo><mn>1</mn><mo>⋅</mo><msup><mn>2</mn><mn>3</mn></msup><mo>+</mo><mn>1</mn><mo>⋅</mo><msup><mn>2</mn><mn>2</mn></msup><mo>+</mo><mn>1</mn><mo>⋅</mo><msup><mn>2</mn><mn>1</mn></msup><mo>+</mo><mn>1</mn><mo>⋅</mo><msup><mn>2</mn><mn>0</mn></msup><mo>=</mo><mo>−</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">B2T_4([1111]) = -1\\cdot2^3+1\\cdot2^2+1\\cdot2^1+1\\cdot2^0 = -1\n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"strut\" style=\"height:0.8641079999999999em;\"></span><span class=\"strut bottom\" style=\"height:1.1141079999999999em;vertical-align:-0.25em;\"></span><span class=\"base displaystyle textstyle uncramped\"><span class=\"mord mathit\" style=\"margin-right:0.05017em;\">B</span><span class=\"mord mathrm\">2</span><span class=\"mord\"><span class=\"mord mathit\" style=\"margin-right:0.13889em;\">T</span><span class=\"vlist\"><span style=\"top:0.15em;margin-right:0.05em;margin-left:-0.13889em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"reset-textstyle scriptstyle cramped\"><span class=\"mord mathrm\">4</span></span></span><span class=\"baseline-fix\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span>​</span></span></span><span class=\"mopen\">(</span><span class=\"mopen\">[</span><span class=\"mord mathrm\">1</span><span class=\"mord mathrm\">1</span><span class=\"mord mathrm\">1</span><span class=\"mord mathrm\">1</span><span class=\"mclose\">]</span><span class=\"mclose\">)</span><span class=\"mrel\">=</span><span class=\"mord\">−</span><span class=\"mord mathrm\">1</span><span class=\"mbin\">⋅</span><span class=\"mord\"><span class=\"mord mathrm\">2</span><span class=\"vlist\"><span style=\"top:-0.413em;margin-right:0.05em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"reset-textstyle scriptstyle uncramped\"><span class=\"mord mathrm\">3</span></span></span><span class=\"baseline-fix\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span>​</span></span></span><span class=\"mbin\">+</span><span class=\"mord mathrm\">1</span><span class=\"mbin\">⋅</span><span class=\"mord\"><span class=\"mord mathrm\">2</span><span class=\"vlist\"><span style=\"top:-0.413em;margin-right:0.05em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"reset-textstyle scriptstyle uncramped\"><span class=\"mord mathrm\">2</span></span></span><span class=\"baseline-fix\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span>​</span></span></span><span class=\"mbin\">+</span><span class=\"mord mathrm\">1</span><span class=\"mbin\">⋅</span><span class=\"mord\"><span class=\"mord mathrm\">2</span><span class=\"vlist\"><span style=\"top:-0.413em;margin-right:0.05em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"reset-textstyle scriptstyle uncramped\"><span class=\"mord mathrm\">1</span></span></span><span class=\"baseline-fix\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span>​</span></span></span><span class=\"mbin\">+</span><span class=\"mord mathrm\">1</span><span class=\"mbin\">⋅</span><span class=\"mord\"><span class=\"mord mathrm\">2</span><span class=\"vlist\"><span style=\"top:-0.413em;margin-right:0.05em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"reset-textstyle scriptstyle uncramped\"><span class=\"mord mathrm\">0</span></span></span><span class=\"baseline-fix\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span>​</span></span></span><span class=\"mrel\">=</span><span class=\"mord\">−</span><span class=\"mord mathrm\">1</span></span></span></span></span></p>\n<h3><span id=\"有符号反码\"> 有符号反码</span></h3>\n<p>和补码一样，只是最高位多减个1  ：<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mo>−</mo><msup><mn>2</mn><mrow><mn>4</mn><mo>−</mo><mn>1</mn></mrow></msup><mo>−</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">-2^{4-1} -1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"strut\" style=\"height:0.8141079999999999em;\"></span><span class=\"strut bottom\" style=\"height:0.897438em;vertical-align:-0.08333em;\"></span><span class=\"base textstyle uncramped\"><span class=\"mord\">−</span><span class=\"mord\"><span class=\"mord mathrm\">2</span><span class=\"vlist\"><span style=\"top:-0.363em;margin-right:0.05em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"reset-textstyle scriptstyle uncramped\"><span class=\"mord scriptstyle uncramped\"><span class=\"mord mathrm\">4</span><span class=\"mbin\">−</span><span class=\"mord mathrm\">1</span></span></span></span><span class=\"baseline-fix\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span>​</span></span></span><span class=\"mbin\">−</span><span class=\"mord mathrm\">1</span></span></span></span><br>\n###有符号原码<br>\n最高位是-1： <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mo>−</mo><mn>1</mn><mo>⋅</mo><msubsup><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></msubsup><mi>x</mi><mo>⋅</mo><msup><mn>2</mn><mi>n</mi></msup></mrow><annotation encoding=\"application/x-tex\">-1\\cdot\\sum_{i=1}^nx\\cdot2^n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"strut\" style=\"height:0.75em;\"></span><span class=\"strut bottom\" style=\"height:1.0500099999999999em;vertical-align:-0.30001em;\"></span><span class=\"base textstyle uncramped\"><span class=\"mord\">−</span><span class=\"mord mathrm\">1</span><span class=\"mbin\">⋅</span><span class=\"mop\"><span class=\"op-symbol small-op mop\" style=\"top:-0.0000050000000000050004em;\">∑</span><span class=\"vlist\"><span style=\"top:0.30001em;margin-left:0em;margin-right:0.05em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"reset-textstyle scriptstyle cramped\"><span class=\"mord scriptstyle cramped\"><span class=\"mord mathit\">i</span><span class=\"mrel\">=</span><span class=\"mord mathrm\">1</span></span></span></span><span style=\"top:-0.364em;margin-right:0.05em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"reset-textstyle scriptstyle uncramped\"><span class=\"mord mathit\">n</span></span></span><span class=\"baseline-fix\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span>​</span></span></span><span class=\"mord mathit\">x</span><span class=\"mbin\">⋅</span><span class=\"mord\"><span class=\"mord mathrm\">2</span><span class=\"vlist\"><span style=\"top:-0.363em;margin-right:0.05em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"reset-textstyle scriptstyle uncramped\"><span class=\"mord mathit\">n</span></span></span><span class=\"baseline-fix\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span>​</span></span></span></span></span></span></p>\n<h3><span id=\"有无符号转换\"> 有无符号转换</span></h3>\n<p><img src=\"http://static.zybuluo.com/allon6/7hxlly2j213a2w4864qn4vhn/image_1bepe8di71l3kvjgbkjlvii9p9.png\" alt=\"image_1bepe8di71l3kvjgbkjlvii9p9.png-190kB\"></p>\n<h3><span id=\"整数类型转换\"> 整数类型转换</span></h3>\n<p>如果称位数少的为“小”，位数多的为“大”<br>\n小 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mo>→</mo></mrow><annotation encoding=\"application/x-tex\">\\to</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"strut\" style=\"height:0.36687em;\"></span><span class=\"strut bottom\" style=\"height:0.36687em;vertical-align:0em;\"></span><span class=\"base textstyle uncramped\"><span class=\"mrel\">→</span></span></span></span> 大 ：零扩展<br>\n大 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mo>→</mo></mrow><annotation encoding=\"application/x-tex\">\\to</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"strut\" style=\"height:0.36687em;\"></span><span class=\"strut bottom\" style=\"height:0.36687em;vertical-align:0em;\"></span><span class=\"base textstyle uncramped\"><span class=\"mrel\">→</span></span></span></span> 小 ：截断</p>\n<h2><span id=\"整数的运算\"> 整数的运算</span></h2>\n<p>判断加法溢出。用最大或者最小值跟目标值求差，再用差和另一个加数比较。如果那个加数比这个差大。就溢出。<br>\n<img src=\"http://static.zybuluo.com/allon6/tlrw3y8lg8nqwidsuw9f36cj/image_1bepg9fg81sp6ceh1k5j1b4t16adm.png\" alt=\"image_1bepg9fg81sp6ceh1k5j1b4t16adm.png-599.8kB\"></p>\n<h2><span id=\"浮点数\"> 浮点数</span></h2>\n<p><img src=\"http://static.zybuluo.com/allon6/f4v4p80nrlyvueonpxejq2wi/image_1beqdtlenf5q74h1v8214951gc013.png\" alt=\"image_1beqdtlenf5q74h1v8214951gc013.png-126.1kB\"></p>\n<blockquote>\n<ul>\n<li>定点表示：<strong>约定</strong>机器中所有数据的小数点位置是固定不变的。由于约定在固定的位置，小数点就不再使用记号“.”来表示。通常将数据表示成纯小数或纯整数。定点数的表示方法就是整数是$\\sum_{i=1}^n 2^i $ ，小数就是2的负幂次。这种的缺点是表达的数据很窄。</li>\n</ul>\n</blockquote>\n<blockquote>\n<ul>\n<li>浮点表示  - IEEE 754标准：浮点指小数点不是固定的，任意十进制数可以表示为：$$N = M \\cdot10^E$$<br>\n比如：$$234.56 = 2.3456*10^2$$<br>\n只保留一位整数这种方式叫规格化表示。<br>\n<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>E</mi></mrow><annotation encoding=\"application/x-tex\">E</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"strut\" style=\"height:0.68333em;\"></span><span class=\"strut bottom\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"base textstyle uncramped\"><span class=\"mord mathit\" style=\"margin-right:0.05764em;\">E</span></span></span></span>(Exponent) 阶码，它控制着小数点在什么位置上。<br>\n<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>M</mi></mrow><annotation encoding=\"application/x-tex\">M</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"strut\" style=\"height:0.68333em;\"></span><span class=\"strut bottom\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"base textstyle uncramped\"><span class=\"mord mathit\" style=\"margin-right:0.10903em;\">M</span></span></span></span>(Significand)尾数，也叫有效数。是核心数值。下图中的Fraction。<br>\n<img src=\"http://static.zybuluo.com/allon6/g3ei6s88dmjp66u2da89ixr7/image_1besrrtt31jj3i8b17c1jfkohd1g.png\" alt=\"image_1besrrtt31jj3i8b17c1jfkohd1g.png-13.9kB\"></li>\n</ul>\n</blockquote>\n<p><strong>这样就可以通过阶码E做为幂次来表示小数点在什么位置，以上情况在二进制上亦然:</strong></p>\n<h3><span id=\"v-1s-cdot-m-cdot-2e\"> $$V = (-1)^s \\cdot M \\cdot 2^E$$</span></h3>\n<h3><span id=\"为什么32位浮点数阶码要有偏移量\"> 为什么32位浮点数阶码要有偏移量 ？</span></h3>\n<p>阶码有正有负，为了方便计算，加上一个比较大的正数。把所有阶码转为正值。这使得两个浮点数的指数大小的比较更为容易，实际上可以按照字典序比较两个浮点表示的大小。</p>\n<h3><span id=\"为什么偏移是127\"> 为什么偏移是127 ？</span></h3>\n<ol>\n<li>8位移码的取值范围为0<sub>255（00000000</sub>11111111），但在浮点数的阶码中，00000000与11111111被保留用作特殊情况，所以阶码可用范围只有1~254，总共有254个值。</li>\n<li>8位有符号数取值范围为-128<sub>+127（10000000</sub>01111111），这里的二进制用补码表示，其中特别规定补码10000000没有原码，为-128的补码，总共有256个值。</li>\n<li>如果采用偏置128，在表达+127时会产生上溢（移码11111111被保留），所以在阶码中偏置为（128-1），与此同时，在表达-127时会产生下溢（移码00000000被保留），所以阶码中去掉-127与-128，取值范围为-126~127，总共254个值。</li>\n</ol>\n<h3><span id=\"浮点运算\"> 浮点运算</span></h3>\n<p>编译器对于浮点型运算可以开启优化，而部分优化会丢失极小的精度。但是默认情况下编译器比较保守的不会主动进行指令优化。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"第02章-程序结构和执行\"><a class=\"markdownIt-Anchor\" href=\"#第02章-程序结构和执行\"></a> 第02章 程序结构和执行</h1>\n<p>Tags: 深入理解计算机系统</p>\n<p>[TOC]</p>\n<hr>\n<h2 id=\"信息的存储\"><a class=\"markdownIt-Anchor\" href=\"#信息的存储\"></a> 信息的存储</h2>\n<p>总线宽度一般就是一个字长，一个字长的位数，就决定着这个系统的寻址宽度。<br>\n字长为 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"strut\" style=\"height:0.43056em;\"></span><span class=\"strut bottom\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"base textstyle uncramped\"><span class=\"mord mathit\">n</span></span></span></span> 那么它的寻址宽度为：<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding=\"application/x-tex\">0</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"strut\" style=\"height:0.64444em;\"></span><span class=\"strut bottom\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"base textstyle uncramped\"><span class=\"mord mathrm\">0</span></span></span></span> ~ <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mo>(</mo><msup><mn>2</mn><mi>n</mi></msup><mo>−</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding=\"application/x-tex\">(2^n - 1)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"strut\" style=\"height:0.75em;\"></span><span class=\"strut bottom\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"base textstyle uncramped\"><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathrm\">2</span><span class=\"vlist\"><span style=\"top:-0.363em;margin-right:0.05em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"reset-textstyle scriptstyle uncramped\"><span class=\"mord mathit\">n</span></span></span><span class=\"baseline-fix\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span>​</span></span></span><span class=\"mbin\">−</span><span class=\"mord mathrm\">1</span><span class=\"mclose\">)</span></span></span></span>  程序最多访问<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msup><mn>2</mn><mi>n</mi></msup></mrow><annotation encoding=\"application/x-tex\">2^n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"strut\" style=\"height:0.664392em;\"></span><span class=\"strut bottom\" style=\"height:0.664392em;vertical-align:0em;\"></span><span class=\"base textstyle uncramped\"><span class=\"mord\"><span class=\"mord mathrm\">2</span><span class=\"vlist\"><span style=\"top:-0.363em;margin-right:0.05em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"reset-textstyle scriptstyle uncramped\"><span class=\"mord mathit\">n</span></span></span><span class=\"baseline-fix\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span>​</span></span></span></span></span></span>个字节。</p>\n<p>little endian(小端）目前android和ios都采用的是little endian。linux和windows也一样。<br>\nbig endian(大端）  java是继承了SUN的系统规则属于小端。所以在java网络传输时尤其注意。<br>\n<img src=\"http://static.zybuluo.com/allon6/xugxaf8oenhxkyvemsekx8xg/image_1benbhdpfh541jgr13s3fs1qs39.png\" alt=\"image_1benbhdpfh541jgr13s3fs1qs39.png-172.3kB\"></p>\n<p>C、C++都支持无符号类型，java仅支持有符号。</p>\n<h2 id=\"整数的表示\"><a class=\"markdownIt-Anchor\" href=\"#整数的表示\"></a> 整数的表示</h2>\n<p><img src=\"http://static.zybuluo.com/allon6/qhvg4rb4ss9sylo1l4bufwba/image_1bep6k353hh3apb1a1j12hn1oilm.png\" alt=\"image_1bep6k353hh3apb1a1j12hn1oilm.png-271.8kB\"><br>\n<br></p>\n<h3 id=\"无符号编码\"><a class=\"markdownIt-Anchor\" href=\"#无符号编码\"></a> 无符号编码</h3>\n<p>全是正的，所以表示的正数值域很宽。</p>\n<p><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>B</mi><mn>2</mn><msub><mi>U</mi><mn>4</mn></msub><mo>(</mo><mo>[</mo><mn>1</mn><mn>1</mn><mn>1</mn><mn>1</mn><mo>]</mo><mo>)</mo><mo>=</mo><mn>1</mn><mo>⋅</mo><msup><mn>2</mn><mn>3</mn></msup><mo>+</mo><mn>1</mn><mo>⋅</mo><msup><mn>2</mn><mn>2</mn></msup><mo>+</mo><mn>1</mn><mo>⋅</mo><msup><mn>2</mn><mn>1</mn></msup><mo>+</mo><mn>1</mn><mo>⋅</mo><msup><mn>2</mn><mn>0</mn></msup><mo>=</mo><mn>1</mn><mn>5</mn></mrow><annotation encoding=\"application/x-tex\">B2U_4([1111]) = 1\\cdot2^3+1\\cdot2^2+1\\cdot2^1+1\\cdot2^0 = 15\n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"strut\" style=\"height:0.8641079999999999em;\"></span><span class=\"strut bottom\" style=\"height:1.1141079999999999em;vertical-align:-0.25em;\"></span><span class=\"base displaystyle textstyle uncramped\"><span class=\"mord mathit\" style=\"margin-right:0.05017em;\">B</span><span class=\"mord mathrm\">2</span><span class=\"mord\"><span class=\"mord mathit\" style=\"margin-right:0.10903em;\">U</span><span class=\"vlist\"><span style=\"top:0.15em;margin-right:0.05em;margin-left:-0.10903em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"reset-textstyle scriptstyle cramped\"><span class=\"mord mathrm\">4</span></span></span><span class=\"baseline-fix\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span>​</span></span></span><span class=\"mopen\">(</span><span class=\"mopen\">[</span><span class=\"mord mathrm\">1</span><span class=\"mord mathrm\">1</span><span class=\"mord mathrm\">1</span><span class=\"mord mathrm\">1</span><span class=\"mclose\">]</span><span class=\"mclose\">)</span><span class=\"mrel\">=</span><span class=\"mord mathrm\">1</span><span class=\"mbin\">⋅</span><span class=\"mord\"><span class=\"mord mathrm\">2</span><span class=\"vlist\"><span style=\"top:-0.413em;margin-right:0.05em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"reset-textstyle scriptstyle uncramped\"><span class=\"mord mathrm\">3</span></span></span><span class=\"baseline-fix\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span>​</span></span></span><span class=\"mbin\">+</span><span class=\"mord mathrm\">1</span><span class=\"mbin\">⋅</span><span class=\"mord\"><span class=\"mord mathrm\">2</span><span class=\"vlist\"><span style=\"top:-0.413em;margin-right:0.05em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"reset-textstyle scriptstyle uncramped\"><span class=\"mord mathrm\">2</span></span></span><span class=\"baseline-fix\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span>​</span></span></span><span class=\"mbin\">+</span><span class=\"mord mathrm\">1</span><span class=\"mbin\">⋅</span><span class=\"mord\"><span class=\"mord mathrm\">2</span><span class=\"vlist\"><span style=\"top:-0.413em;margin-right:0.05em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"reset-textstyle scriptstyle uncramped\"><span class=\"mord mathrm\">1</span></span></span><span class=\"baseline-fix\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span>​</span></span></span><span class=\"mbin\">+</span><span class=\"mord mathrm\">1</span><span class=\"mbin\">⋅</span><span class=\"mord\"><span class=\"mord mathrm\">2</span><span class=\"vlist\"><span style=\"top:-0.413em;margin-right:0.05em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"reset-textstyle scriptstyle uncramped\"><span class=\"mord mathrm\">0</span></span></span><span class=\"baseline-fix\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span>​</span></span></span><span class=\"mrel\">=</span><span class=\"mord mathrm\">1</span><span class=\"mord mathrm\">5</span></span></span></span></span></p>\n<h4 id=\"有符号补码-常用\"><a class=\"markdownIt-Anchor\" href=\"#有符号补码-常用\"></a> 有符号补码 - 常用</h4>\n<p>最高位为负数，表示的值域：<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mo>−</mo><msup><mn>2</mn><mrow><mn>4</mn><mo>−</mo><mn>1</mn></mrow></msup></mrow><annotation encoding=\"application/x-tex\">-2^{4-1}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"strut\" style=\"height:0.8141079999999999em;\"></span><span class=\"strut bottom\" style=\"height:0.897438em;vertical-align:-0.08333em;\"></span><span class=\"base textstyle uncramped\"><span class=\"mord\">−</span><span class=\"mord\"><span class=\"mord mathrm\">2</span><span class=\"vlist\"><span style=\"top:-0.363em;margin-right:0.05em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"reset-textstyle scriptstyle uncramped\"><span class=\"mord scriptstyle uncramped\"><span class=\"mord mathrm\">4</span><span class=\"mbin\">−</span><span class=\"mord mathrm\">1</span></span></span></span><span class=\"baseline-fix\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span>​</span></span></span></span></span></span> ~ <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msup><mn>2</mn><mrow><mn>4</mn><mo>−</mo><mn>1</mn></mrow></msup><mo>−</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">2^{4-1} -1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"strut\" style=\"height:0.8141079999999999em;\"></span><span class=\"strut bottom\" style=\"height:0.897438em;vertical-align:-0.08333em;\"></span><span class=\"base textstyle uncramped\"><span class=\"mord\"><span class=\"mord mathrm\">2</span><span class=\"vlist\"><span style=\"top:-0.363em;margin-right:0.05em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"reset-textstyle scriptstyle uncramped\"><span class=\"mord scriptstyle uncramped\"><span class=\"mord mathrm\">4</span><span class=\"mbin\">−</span><span class=\"mord mathrm\">1</span></span></span></span><span class=\"baseline-fix\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span>​</span></span></span><span class=\"mbin\">−</span><span class=\"mord mathrm\">1</span></span></span></span>，由此可以看出，因为0是非负数，所以多占了一个。有符号的位不是对称的。负数比正位大1。负数最小值在正方向上没有与之对应的数。</p>\n<p><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>B</mi><mn>2</mn><msub><mi>T</mi><mn>4</mn></msub><mo>(</mo><mo>[</mo><mn>1</mn><mn>1</mn><mn>1</mn><mn>1</mn><mo>]</mo><mo>)</mo><mo>=</mo><mo>−</mo><mn>1</mn><mo>⋅</mo><msup><mn>2</mn><mn>3</mn></msup><mo>+</mo><mn>1</mn><mo>⋅</mo><msup><mn>2</mn><mn>2</mn></msup><mo>+</mo><mn>1</mn><mo>⋅</mo><msup><mn>2</mn><mn>1</mn></msup><mo>+</mo><mn>1</mn><mo>⋅</mo><msup><mn>2</mn><mn>0</mn></msup><mo>=</mo><mo>−</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">B2T_4([1111]) = -1\\cdot2^3+1\\cdot2^2+1\\cdot2^1+1\\cdot2^0 = -1\n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"strut\" style=\"height:0.8641079999999999em;\"></span><span class=\"strut bottom\" style=\"height:1.1141079999999999em;vertical-align:-0.25em;\"></span><span class=\"base displaystyle textstyle uncramped\"><span class=\"mord mathit\" style=\"margin-right:0.05017em;\">B</span><span class=\"mord mathrm\">2</span><span class=\"mord\"><span class=\"mord mathit\" style=\"margin-right:0.13889em;\">T</span><span class=\"vlist\"><span style=\"top:0.15em;margin-right:0.05em;margin-left:-0.13889em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"reset-textstyle scriptstyle cramped\"><span class=\"mord mathrm\">4</span></span></span><span class=\"baseline-fix\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span>​</span></span></span><span class=\"mopen\">(</span><span class=\"mopen\">[</span><span class=\"mord mathrm\">1</span><span class=\"mord mathrm\">1</span><span class=\"mord mathrm\">1</span><span class=\"mord mathrm\">1</span><span class=\"mclose\">]</span><span class=\"mclose\">)</span><span class=\"mrel\">=</span><span class=\"mord\">−</span><span class=\"mord mathrm\">1</span><span class=\"mbin\">⋅</span><span class=\"mord\"><span class=\"mord mathrm\">2</span><span class=\"vlist\"><span style=\"top:-0.413em;margin-right:0.05em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"reset-textstyle scriptstyle uncramped\"><span class=\"mord mathrm\">3</span></span></span><span class=\"baseline-fix\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span>​</span></span></span><span class=\"mbin\">+</span><span class=\"mord mathrm\">1</span><span class=\"mbin\">⋅</span><span class=\"mord\"><span class=\"mord mathrm\">2</span><span class=\"vlist\"><span style=\"top:-0.413em;margin-right:0.05em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"reset-textstyle scriptstyle uncramped\"><span class=\"mord mathrm\">2</span></span></span><span class=\"baseline-fix\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span>​</span></span></span><span class=\"mbin\">+</span><span class=\"mord mathrm\">1</span><span class=\"mbin\">⋅</span><span class=\"mord\"><span class=\"mord mathrm\">2</span><span class=\"vlist\"><span style=\"top:-0.413em;margin-right:0.05em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"reset-textstyle scriptstyle uncramped\"><span class=\"mord mathrm\">1</span></span></span><span class=\"baseline-fix\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span>​</span></span></span><span class=\"mbin\">+</span><span class=\"mord mathrm\">1</span><span class=\"mbin\">⋅</span><span class=\"mord\"><span class=\"mord mathrm\">2</span><span class=\"vlist\"><span style=\"top:-0.413em;margin-right:0.05em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"reset-textstyle scriptstyle uncramped\"><span class=\"mord mathrm\">0</span></span></span><span class=\"baseline-fix\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span>​</span></span></span><span class=\"mrel\">=</span><span class=\"mord\">−</span><span class=\"mord mathrm\">1</span></span></span></span></span></p>\n<h3 id=\"有符号反码\"><a class=\"markdownIt-Anchor\" href=\"#有符号反码\"></a> 有符号反码</h3>\n<p>和补码一样，只是最高位多减个1  ：<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mo>−</mo><msup><mn>2</mn><mrow><mn>4</mn><mo>−</mo><mn>1</mn></mrow></msup><mo>−</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">-2^{4-1} -1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"strut\" style=\"height:0.8141079999999999em;\"></span><span class=\"strut bottom\" style=\"height:0.897438em;vertical-align:-0.08333em;\"></span><span class=\"base textstyle uncramped\"><span class=\"mord\">−</span><span class=\"mord\"><span class=\"mord mathrm\">2</span><span class=\"vlist\"><span style=\"top:-0.363em;margin-right:0.05em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"reset-textstyle scriptstyle uncramped\"><span class=\"mord scriptstyle uncramped\"><span class=\"mord mathrm\">4</span><span class=\"mbin\">−</span><span class=\"mord mathrm\">1</span></span></span></span><span class=\"baseline-fix\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span>​</span></span></span><span class=\"mbin\">−</span><span class=\"mord mathrm\">1</span></span></span></span><br>\n###有符号原码<br>\n最高位是-1： <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mo>−</mo><mn>1</mn><mo>⋅</mo><msubsup><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></msubsup><mi>x</mi><mo>⋅</mo><msup><mn>2</mn><mi>n</mi></msup></mrow><annotation encoding=\"application/x-tex\">-1\\cdot\\sum_{i=1}^nx\\cdot2^n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"strut\" style=\"height:0.75em;\"></span><span class=\"strut bottom\" style=\"height:1.0500099999999999em;vertical-align:-0.30001em;\"></span><span class=\"base textstyle uncramped\"><span class=\"mord\">−</span><span class=\"mord mathrm\">1</span><span class=\"mbin\">⋅</span><span class=\"mop\"><span class=\"op-symbol small-op mop\" style=\"top:-0.0000050000000000050004em;\">∑</span><span class=\"vlist\"><span style=\"top:0.30001em;margin-left:0em;margin-right:0.05em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"reset-textstyle scriptstyle cramped\"><span class=\"mord scriptstyle cramped\"><span class=\"mord mathit\">i</span><span class=\"mrel\">=</span><span class=\"mord mathrm\">1</span></span></span></span><span style=\"top:-0.364em;margin-right:0.05em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"reset-textstyle scriptstyle uncramped\"><span class=\"mord mathit\">n</span></span></span><span class=\"baseline-fix\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span>​</span></span></span><span class=\"mord mathit\">x</span><span class=\"mbin\">⋅</span><span class=\"mord\"><span class=\"mord mathrm\">2</span><span class=\"vlist\"><span style=\"top:-0.363em;margin-right:0.05em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"reset-textstyle scriptstyle uncramped\"><span class=\"mord mathit\">n</span></span></span><span class=\"baseline-fix\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span>​</span></span></span></span></span></span></p>\n<h3 id=\"有无符号转换\"><a class=\"markdownIt-Anchor\" href=\"#有无符号转换\"></a> 有无符号转换</h3>\n<p><img src=\"http://static.zybuluo.com/allon6/7hxlly2j213a2w4864qn4vhn/image_1bepe8di71l3kvjgbkjlvii9p9.png\" alt=\"image_1bepe8di71l3kvjgbkjlvii9p9.png-190kB\"></p>\n<h3 id=\"整数类型转换\"><a class=\"markdownIt-Anchor\" href=\"#整数类型转换\"></a> 整数类型转换</h3>\n<p>如果称位数少的为“小”，位数多的为“大”<br>\n小 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mo>→</mo></mrow><annotation encoding=\"application/x-tex\">\\to</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"strut\" style=\"height:0.36687em;\"></span><span class=\"strut bottom\" style=\"height:0.36687em;vertical-align:0em;\"></span><span class=\"base textstyle uncramped\"><span class=\"mrel\">→</span></span></span></span> 大 ：零扩展<br>\n大 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mo>→</mo></mrow><annotation encoding=\"application/x-tex\">\\to</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"strut\" style=\"height:0.36687em;\"></span><span class=\"strut bottom\" style=\"height:0.36687em;vertical-align:0em;\"></span><span class=\"base textstyle uncramped\"><span class=\"mrel\">→</span></span></span></span> 小 ：截断</p>\n<h2 id=\"整数的运算\"><a class=\"markdownIt-Anchor\" href=\"#整数的运算\"></a> 整数的运算</h2>\n<p>判断加法溢出。用最大或者最小值跟目标值求差，再用差和另一个加数比较。如果那个加数比这个差大。就溢出。<br>\n<img src=\"http://static.zybuluo.com/allon6/tlrw3y8lg8nqwidsuw9f36cj/image_1bepg9fg81sp6ceh1k5j1b4t16adm.png\" alt=\"image_1bepg9fg81sp6ceh1k5j1b4t16adm.png-599.8kB\"></p>\n<h2 id=\"浮点数\"><a class=\"markdownIt-Anchor\" href=\"#浮点数\"></a> 浮点数</h2>\n<p><img src=\"http://static.zybuluo.com/allon6/f4v4p80nrlyvueonpxejq2wi/image_1beqdtlenf5q74h1v8214951gc013.png\" alt=\"image_1beqdtlenf5q74h1v8214951gc013.png-126.1kB\"></p>\n<blockquote>\n<ul>\n<li>定点表示：<strong>约定</strong>机器中所有数据的小数点位置是固定不变的。由于约定在固定的位置，小数点就不再使用记号“.”来表示。通常将数据表示成纯小数或纯整数。定点数的表示方法就是整数是$\\sum_{i=1}^n 2^i $ ，小数就是2的负幂次。这种的缺点是表达的数据很窄。</li>\n</ul>\n</blockquote>\n<blockquote>\n<ul>\n<li>浮点表示  - IEEE 754标准：浮点指小数点不是固定的，任意十进制数可以表示为：$$N = M \\cdot10^E$$<br>\n比如：$$234.56 = 2.3456*10^2$$<br>\n只保留一位整数这种方式叫规格化表示。<br>\n<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>E</mi></mrow><annotation encoding=\"application/x-tex\">E</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"strut\" style=\"height:0.68333em;\"></span><span class=\"strut bottom\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"base textstyle uncramped\"><span class=\"mord mathit\" style=\"margin-right:0.05764em;\">E</span></span></span></span>(Exponent) 阶码，它控制着小数点在什么位置上。<br>\n<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>M</mi></mrow><annotation encoding=\"application/x-tex\">M</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"strut\" style=\"height:0.68333em;\"></span><span class=\"strut bottom\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"base textstyle uncramped\"><span class=\"mord mathit\" style=\"margin-right:0.10903em;\">M</span></span></span></span>(Significand)尾数，也叫有效数。是核心数值。下图中的Fraction。<br>\n<img src=\"http://static.zybuluo.com/allon6/g3ei6s88dmjp66u2da89ixr7/image_1besrrtt31jj3i8b17c1jfkohd1g.png\" alt=\"image_1besrrtt31jj3i8b17c1jfkohd1g.png-13.9kB\"></li>\n</ul>\n</blockquote>\n<p><strong>这样就可以通过阶码E做为幂次来表示小数点在什么位置，以上情况在二进制上亦然:</strong></p>\n<h3 id=\"v-1s-cdot-m-cdot-2e\"><a class=\"markdownIt-Anchor\" href=\"#v-1s-cdot-m-cdot-2e\"></a> $$V = (-1)^s \\cdot M \\cdot 2^E$$</h3>\n<h3 id=\"为什么32位浮点数阶码要有偏移量\"><a class=\"markdownIt-Anchor\" href=\"#为什么32位浮点数阶码要有偏移量\"></a> 为什么32位浮点数阶码要有偏移量 ？</h3>\n<p>阶码有正有负，为了方便计算，加上一个比较大的正数。把所有阶码转为正值。这使得两个浮点数的指数大小的比较更为容易，实际上可以按照字典序比较两个浮点表示的大小。</p>\n<h3 id=\"为什么偏移是127\"><a class=\"markdownIt-Anchor\" href=\"#为什么偏移是127\"></a> 为什么偏移是127 ？</h3>\n<ol>\n<li>8位移码的取值范围为0<sub>255（00000000</sub>11111111），但在浮点数的阶码中，00000000与11111111被保留用作特殊情况，所以阶码可用范围只有1~254，总共有254个值。</li>\n<li>8位有符号数取值范围为-128<sub>+127（10000000</sub>01111111），这里的二进制用补码表示，其中特别规定补码10000000没有原码，为-128的补码，总共有256个值。</li>\n<li>如果采用偏置128，在表达+127时会产生上溢（移码11111111被保留），所以在阶码中偏置为（128-1），与此同时，在表达-127时会产生下溢（移码00000000被保留），所以阶码中去掉-127与-128，取值范围为-126~127，总共254个值。</li>\n</ol>\n<h3 id=\"浮点运算\"><a class=\"markdownIt-Anchor\" href=\"#浮点运算\"></a> 浮点运算</h3>\n<p>编译器对于浮点型运算可以开启优化，而部分优化会丢失极小的精度。但是默认情况下编译器比较保守的不会主动进行指令优化。</p>\n"},{"title":"第03章 程序的机器级表示","catalog":true,"date":"2017-02-22T09:21:29.000Z","header-img":"/img/05.jpg","_content":"\n# 第03章 程序的机器级表示\n\nTags: 深入理解计算机系统\n\n[TOC]\n\n---\n## 程序编码\n汇编或者机器码能操作很多对C语言隐藏的CPU状态：\n>* 程序计数器（PC，在x86-64中用%rip表示）给出将要执行的下一条指令。\n\n>* 整数寄存器文件的16个位置\n\n>* 条件寄存器（实现if、while等）\n\n>* 一组向量寄存器可以存放一个或多个浮点数值。\n\n汇编指令或者机器码特点：\n>* x86-64的指令1到15字节，常用的短，不常用的长。\n\n>* mac上反汇编可以使用otool -tV test.o，linux上可以用objdump \n\n>* 汇编格式分两种：ATT是GCC和objdump默认格式，另外还有intel和微软的使用的都是intel的格式。编译的时候加上-masm=intel。\n\n>* C语言和汇编可以结合编译。另外，C语言的if代价很高。\n\n![image_1bf6nhuvqllm13ro1kuo115m13sm.png-150.4kB][2]\n\n\n> 类型的关键就在汇编指令的后缀决定着汇编指令的大小和类型，这种约定决定了它是float还是int。\n|C声明        | Intel数据类型    | 汇编代码后缀        | 大小（字节）   |  \n| ----------| --------| ----------| --------| \n| char    |  字节|  b |1|\n| short        |   字   | w |2|\n| int        |   双字   |  l |4|\n|long         | 四字 |q |8|\n|char*         |四字| q |8|\n|float  |单精度| s |4|\n|double |双精度| l |8|\n\n## 控制\n###条件码\n除了整数寄存器，CPU还维护着一组单个位的条件码（condition code）寄存器。\n\n\n  [1]: http://static.zybuluo.com/allon6/yzfv9gtjsrji8s0b4p3aihsn/image_1bf6v19m51g921ca71it3129t1nhr13.png\n  [2]: http://static.zybuluo.com/allon6/js1wq6rorgfytob2opajes74/image_1bf6nhuvqllm13ro1kuo115m13sm.png\n","source":"_posts/第03章 程序的机器级表示.md","raw":"---\ntitle: \"第03章 程序的机器级表示\"\ncatalog: true\ndate: 2017-02-22 17:21:29\nheader-img: \"/img/05.jpg\"\ntags: \"深入理解计算机系统\"\n---\n\n# 第03章 程序的机器级表示\n\nTags: 深入理解计算机系统\n\n[TOC]\n\n---\n## 程序编码\n汇编或者机器码能操作很多对C语言隐藏的CPU状态：\n>* 程序计数器（PC，在x86-64中用%rip表示）给出将要执行的下一条指令。\n\n>* 整数寄存器文件的16个位置\n\n>* 条件寄存器（实现if、while等）\n\n>* 一组向量寄存器可以存放一个或多个浮点数值。\n\n汇编指令或者机器码特点：\n>* x86-64的指令1到15字节，常用的短，不常用的长。\n\n>* mac上反汇编可以使用otool -tV test.o，linux上可以用objdump \n\n>* 汇编格式分两种：ATT是GCC和objdump默认格式，另外还有intel和微软的使用的都是intel的格式。编译的时候加上-masm=intel。\n\n>* C语言和汇编可以结合编译。另外，C语言的if代价很高。\n\n![image_1bf6nhuvqllm13ro1kuo115m13sm.png-150.4kB][2]\n\n\n> 类型的关键就在汇编指令的后缀决定着汇编指令的大小和类型，这种约定决定了它是float还是int。\n|C声明        | Intel数据类型    | 汇编代码后缀        | 大小（字节）   |  \n| ----------| --------| ----------| --------| \n| char    |  字节|  b |1|\n| short        |   字   | w |2|\n| int        |   双字   |  l |4|\n|long         | 四字 |q |8|\n|char*         |四字| q |8|\n|float  |单精度| s |4|\n|double |双精度| l |8|\n\n## 控制\n###条件码\n除了整数寄存器，CPU还维护着一组单个位的条件码（condition code）寄存器。\n\n\n  [1]: http://static.zybuluo.com/allon6/yzfv9gtjsrji8s0b4p3aihsn/image_1bf6v19m51g921ca71it3129t1nhr13.png\n  [2]: http://static.zybuluo.com/allon6/js1wq6rorgfytob2opajes74/image_1bf6nhuvqllm13ro1kuo115m13sm.png\n","slug":"第03章 程序的机器级表示","published":1,"updated":"2017-11-25T09:06:03.135Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjahvvny50019pv4nh6vetn0m","content":"<h1><span id=\"第03章-程序的机器级表示\"> 第03章 程序的机器级表示</span></h1>\n<p>Tags: 深入理解计算机系统</p>\n<p>[TOC]</p>\n<hr>\n<h2><span id=\"程序编码\"> 程序编码</span></h2>\n<p>汇编或者机器码能操作很多对C语言隐藏的CPU状态：</p>\n<blockquote>\n<ul>\n<li>程序计数器（PC，在x86-64中用%rip表示）给出将要执行的下一条指令。</li>\n</ul>\n</blockquote>\n<blockquote>\n<ul>\n<li>整数寄存器文件的16个位置</li>\n</ul>\n</blockquote>\n<blockquote>\n<ul>\n<li>条件寄存器（实现if、while等）</li>\n</ul>\n</blockquote>\n<blockquote>\n<ul>\n<li>一组向量寄存器可以存放一个或多个浮点数值。</li>\n</ul>\n</blockquote>\n<p>汇编指令或者机器码特点：</p>\n<blockquote>\n<ul>\n<li>x86-64的指令1到15字节，常用的短，不常用的长。</li>\n</ul>\n</blockquote>\n<blockquote>\n<ul>\n<li>mac上反汇编可以使用otool -tV test.o，linux上可以用objdump</li>\n</ul>\n</blockquote>\n<blockquote>\n<ul>\n<li>汇编格式分两种：ATT是GCC和objdump默认格式，另外还有intel和微软的使用的都是intel的格式。编译的时候加上-masm=intel。</li>\n</ul>\n</blockquote>\n<blockquote>\n<ul>\n<li>C语言和汇编可以结合编译。另外，C语言的if代价很高。</li>\n</ul>\n</blockquote>\n<p><img src=\"http://static.zybuluo.com/allon6/js1wq6rorgfytob2opajes74/image_1bf6nhuvqllm13ro1kuo115m13sm.png\" alt=\"image_1bf6nhuvqllm13ro1kuo115m13sm.png-150.4kB\"></p>\n<blockquote>\n<p>类型的关键就在汇编指令的后缀决定着汇编指令的大小和类型，这种约定决定了它是float还是int。<br>\n|C声明        | Intel数据类型    | 汇编代码后缀        | 大小（字节）   |<br>\n| ----------| --------| ----------| --------|<br>\n| char    |  字节|  b |1|<br>\n| short        |   字   | w |2|<br>\n| int        |   双字   |  l |4|<br>\n|long         | 四字 |q |8|<br>\n|char*         |四字| q |8|<br>\n|float  |单精度| s |4|<br>\n|double |双精度| l |8|</p>\n</blockquote>\n<h2><span id=\"控制\"> 控制</span></h2>\n<p>###条件码<br>\n除了整数寄存器，CPU还维护着一组单个位的条件码（condition code）寄存器。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"第03章-程序的机器级表示\"><a class=\"markdownIt-Anchor\" href=\"#第03章-程序的机器级表示\"></a> 第03章 程序的机器级表示</h1>\n<p>Tags: 深入理解计算机系统</p>\n<p>[TOC]</p>\n<hr>\n<h2 id=\"程序编码\"><a class=\"markdownIt-Anchor\" href=\"#程序编码\"></a> 程序编码</h2>\n<p>汇编或者机器码能操作很多对C语言隐藏的CPU状态：</p>\n<blockquote>\n<ul>\n<li>程序计数器（PC，在x86-64中用%rip表示）给出将要执行的下一条指令。</li>\n</ul>\n</blockquote>\n<blockquote>\n<ul>\n<li>整数寄存器文件的16个位置</li>\n</ul>\n</blockquote>\n<blockquote>\n<ul>\n<li>条件寄存器（实现if、while等）</li>\n</ul>\n</blockquote>\n<blockquote>\n<ul>\n<li>一组向量寄存器可以存放一个或多个浮点数值。</li>\n</ul>\n</blockquote>\n<p>汇编指令或者机器码特点：</p>\n<blockquote>\n<ul>\n<li>x86-64的指令1到15字节，常用的短，不常用的长。</li>\n</ul>\n</blockquote>\n<blockquote>\n<ul>\n<li>mac上反汇编可以使用otool -tV test.o，linux上可以用objdump</li>\n</ul>\n</blockquote>\n<blockquote>\n<ul>\n<li>汇编格式分两种：ATT是GCC和objdump默认格式，另外还有intel和微软的使用的都是intel的格式。编译的时候加上-masm=intel。</li>\n</ul>\n</blockquote>\n<blockquote>\n<ul>\n<li>C语言和汇编可以结合编译。另外，C语言的if代价很高。</li>\n</ul>\n</blockquote>\n<p><img src=\"http://static.zybuluo.com/allon6/js1wq6rorgfytob2opajes74/image_1bf6nhuvqllm13ro1kuo115m13sm.png\" alt=\"image_1bf6nhuvqllm13ro1kuo115m13sm.png-150.4kB\"></p>\n<blockquote>\n<p>类型的关键就在汇编指令的后缀决定着汇编指令的大小和类型，这种约定决定了它是float还是int。<br>\n|C声明        | Intel数据类型    | 汇编代码后缀        | 大小（字节）   |<br>\n| ----------| --------| ----------| --------|<br>\n| char    |  字节|  b |1|<br>\n| short        |   字   | w |2|<br>\n| int        |   双字   |  l |4|<br>\n|long         | 四字 |q |8|<br>\n|char*         |四字| q |8|<br>\n|float  |单精度| s |4|<br>\n|double |双精度| l |8|</p>\n</blockquote>\n<h2 id=\"控制\"><a class=\"markdownIt-Anchor\" href=\"#控制\"></a> 控制</h2>\n<p>###条件码<br>\n除了整数寄存器，CPU还维护着一组单个位的条件码（condition code）寄存器。</p>\n"},{"title":"資治通鑑總覽","catalog":true,"date":"2017-11-27T07:08:06.000Z","subtitle":"鑑于往事，有資於治道","header-img":"/img/17.jpg","_content":"\n# 資治通鑑總覽\n\n編年體，二百九十四卷，十六朝，凡一千三百六十二年。\n\n進書表：重念臣違離闕庭，十有五年，雖身處于外，區區之心，朝夕寤寐，何嘗不在陛下之左右！顧以駑蹇，無施而可，是以專事鉛槧，用酬大恩，庶竭涓塵，少裨海嶽。臣今骸骨癯瘁，目視昏近，齒牙無幾，神識衰耗，目前所為，旋踵遺忘。臣之精力，盡於此書。伏望陛下寬其妄作之誅，察其願忠之意，以清閒之宴，時賜有覽，監前世之興衰，考當今之得失，嘉善矜惡，取得捨非，足以懋稽古之盛德，躋無前之至治。俾四海羣生，咸蒙其福，則臣雖委骨九泉，志願永畢矣！\n\n謹奉表陳進以聞。臣光誠惶誠懼，頓首頓首，謹言。\n\n| 紀 | 範圍 | 卷數| \n| --- | --- | --- |\n|周紀 | 1 - 5 | 共5卷 |\n|秦紀 | 6 - 8 |共3卷 |\n|漢紀 | 9 - 68 | 共60卷 |\n|魏紀 | 69 - 78 | 共10卷 |\n|晉紀 | 79 - 118 | 共40卷 |\n|宋紀 | 119 - 134 | 共60卷 |\n|齊紀| 135 - 144 | 共10卷 |\n|梁紀| 145 - 166 | 共22卷 |\n|陳紀| 167 - 176 |共10卷 |\n|隋紀| 177 - 184 | 共7卷 |\n|唐紀| 185 - 265 | 共81卷 |\n|後梁紀| 266 - 271 | 共5卷|\n|後唐紀| 272 - 279 | 共8卷|\n|後晉紀| 280 - 285 | 共6卷 |\n|後漢紀| 286 - 289 | 共4卷 |\n|後周紀| 290 - 294 | 共5卷 |\n\n    進展：\n    2017年11月27日 第101卷 晉紀。\n\n\n","source":"_posts/資治通鑑總覽.md","raw":"---\ntitle: 資治通鑑總覽\ncatalog: true\ndate: 2017-11-27 15:08:06\nsubtitle: '鑑于往事，有資於治道'\nheader-img: '/img/17.jpg'\ntags: 資治通鑑\n---\n\n# 資治通鑑總覽\n\n編年體，二百九十四卷，十六朝，凡一千三百六十二年。\n\n進書表：重念臣違離闕庭，十有五年，雖身處于外，區區之心，朝夕寤寐，何嘗不在陛下之左右！顧以駑蹇，無施而可，是以專事鉛槧，用酬大恩，庶竭涓塵，少裨海嶽。臣今骸骨癯瘁，目視昏近，齒牙無幾，神識衰耗，目前所為，旋踵遺忘。臣之精力，盡於此書。伏望陛下寬其妄作之誅，察其願忠之意，以清閒之宴，時賜有覽，監前世之興衰，考當今之得失，嘉善矜惡，取得捨非，足以懋稽古之盛德，躋無前之至治。俾四海羣生，咸蒙其福，則臣雖委骨九泉，志願永畢矣！\n\n謹奉表陳進以聞。臣光誠惶誠懼，頓首頓首，謹言。\n\n| 紀 | 範圍 | 卷數| \n| --- | --- | --- |\n|周紀 | 1 - 5 | 共5卷 |\n|秦紀 | 6 - 8 |共3卷 |\n|漢紀 | 9 - 68 | 共60卷 |\n|魏紀 | 69 - 78 | 共10卷 |\n|晉紀 | 79 - 118 | 共40卷 |\n|宋紀 | 119 - 134 | 共60卷 |\n|齊紀| 135 - 144 | 共10卷 |\n|梁紀| 145 - 166 | 共22卷 |\n|陳紀| 167 - 176 |共10卷 |\n|隋紀| 177 - 184 | 共7卷 |\n|唐紀| 185 - 265 | 共81卷 |\n|後梁紀| 266 - 271 | 共5卷|\n|後唐紀| 272 - 279 | 共8卷|\n|後晉紀| 280 - 285 | 共6卷 |\n|後漢紀| 286 - 289 | 共4卷 |\n|後周紀| 290 - 294 | 共5卷 |\n\n    進展：\n    2017年11月27日 第101卷 晉紀。\n\n\n","slug":"資治通鑑總覽","published":1,"updated":"2017-11-27T07:40:05.182Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjahvvny6001apv4nfgp3wid8","content":"<h1><span id=\"資治通鑑總覽\"> 資治通鑑總覽</span></h1>\n<p>編年體，二百九十四卷，十六朝，凡一千三百六十二年。</p>\n<p>進書表：重念臣違離闕庭，十有五年，雖身處于外，區區之心，朝夕寤寐，何嘗不在陛下之左右！顧以駑蹇，無施而可，是以專事鉛槧，用酬大恩，庶竭涓塵，少裨海嶽。臣今骸骨癯瘁，目視昏近，齒牙無幾，神識衰耗，目前所為，旋踵遺忘。臣之精力，盡於此書。伏望陛下寬其妄作之誅，察其願忠之意，以清閒之宴，時賜有覽，監前世之興衰，考當今之得失，嘉善矜惡，取得捨非，足以懋稽古之盛德，躋無前之至治。俾四海羣生，咸蒙其福，則臣雖委骨九泉，志願永畢矣！</p>\n<p>謹奉表陳進以聞。臣光誠惶誠懼，頓首頓首，謹言。</p>\n<table>\n<thead>\n<tr>\n<th>紀</th>\n<th>範圍</th>\n<th>卷數</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>周紀</td>\n<td>1 - 5</td>\n<td>共5卷</td>\n</tr>\n<tr>\n<td>秦紀</td>\n<td>6 - 8</td>\n<td>共3卷</td>\n</tr>\n<tr>\n<td>漢紀</td>\n<td>9 - 68</td>\n<td>共60卷</td>\n</tr>\n<tr>\n<td>魏紀</td>\n<td>69 - 78</td>\n<td>共10卷</td>\n</tr>\n<tr>\n<td>晉紀</td>\n<td>79 - 118</td>\n<td>共40卷</td>\n</tr>\n<tr>\n<td>宋紀</td>\n<td>119 - 134</td>\n<td>共60卷</td>\n</tr>\n<tr>\n<td>齊紀</td>\n<td>135 - 144</td>\n<td>共10卷</td>\n</tr>\n<tr>\n<td>梁紀</td>\n<td>145 - 166</td>\n<td>共22卷</td>\n</tr>\n<tr>\n<td>陳紀</td>\n<td>167 - 176</td>\n<td>共10卷</td>\n</tr>\n<tr>\n<td>隋紀</td>\n<td>177 - 184</td>\n<td>共7卷</td>\n</tr>\n<tr>\n<td>唐紀</td>\n<td>185 - 265</td>\n<td>共81卷</td>\n</tr>\n<tr>\n<td>後梁紀</td>\n<td>266 - 271</td>\n<td>共5卷</td>\n</tr>\n<tr>\n<td>後唐紀</td>\n<td>272 - 279</td>\n<td>共8卷</td>\n</tr>\n<tr>\n<td>後晉紀</td>\n<td>280 - 285</td>\n<td>共6卷</td>\n</tr>\n<tr>\n<td>後漢紀</td>\n<td>286 - 289</td>\n<td>共4卷</td>\n</tr>\n<tr>\n<td>後周紀</td>\n<td>290 - 294</td>\n<td>共5卷</td>\n</tr>\n</tbody>\n</table>\n<pre><code>進展：\n2017年11月27日 第101卷 晉紀。\n</code></pre>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"資治通鑑總覽\"><a class=\"markdownIt-Anchor\" href=\"#資治通鑑總覽\"></a> 資治通鑑總覽</h1>\n<p>編年體，二百九十四卷，十六朝，凡一千三百六十二年。</p>\n<p>進書表：重念臣違離闕庭，十有五年，雖身處于外，區區之心，朝夕寤寐，何嘗不在陛下之左右！顧以駑蹇，無施而可，是以專事鉛槧，用酬大恩，庶竭涓塵，少裨海嶽。臣今骸骨癯瘁，目視昏近，齒牙無幾，神識衰耗，目前所為，旋踵遺忘。臣之精力，盡於此書。伏望陛下寬其妄作之誅，察其願忠之意，以清閒之宴，時賜有覽，監前世之興衰，考當今之得失，嘉善矜惡，取得捨非，足以懋稽古之盛德，躋無前之至治。俾四海羣生，咸蒙其福，則臣雖委骨九泉，志願永畢矣！</p>\n<p>謹奉表陳進以聞。臣光誠惶誠懼，頓首頓首，謹言。</p>\n<table>\n<thead>\n<tr>\n<th>紀</th>\n<th>範圍</th>\n<th>卷數</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>周紀</td>\n<td>1 - 5</td>\n<td>共5卷</td>\n</tr>\n<tr>\n<td>秦紀</td>\n<td>6 - 8</td>\n<td>共3卷</td>\n</tr>\n<tr>\n<td>漢紀</td>\n<td>9 - 68</td>\n<td>共60卷</td>\n</tr>\n<tr>\n<td>魏紀</td>\n<td>69 - 78</td>\n<td>共10卷</td>\n</tr>\n<tr>\n<td>晉紀</td>\n<td>79 - 118</td>\n<td>共40卷</td>\n</tr>\n<tr>\n<td>宋紀</td>\n<td>119 - 134</td>\n<td>共60卷</td>\n</tr>\n<tr>\n<td>齊紀</td>\n<td>135 - 144</td>\n<td>共10卷</td>\n</tr>\n<tr>\n<td>梁紀</td>\n<td>145 - 166</td>\n<td>共22卷</td>\n</tr>\n<tr>\n<td>陳紀</td>\n<td>167 - 176</td>\n<td>共10卷</td>\n</tr>\n<tr>\n<td>隋紀</td>\n<td>177 - 184</td>\n<td>共7卷</td>\n</tr>\n<tr>\n<td>唐紀</td>\n<td>185 - 265</td>\n<td>共81卷</td>\n</tr>\n<tr>\n<td>後梁紀</td>\n<td>266 - 271</td>\n<td>共5卷</td>\n</tr>\n<tr>\n<td>後唐紀</td>\n<td>272 - 279</td>\n<td>共8卷</td>\n</tr>\n<tr>\n<td>後晉紀</td>\n<td>280 - 285</td>\n<td>共6卷</td>\n</tr>\n<tr>\n<td>後漢紀</td>\n<td>286 - 289</td>\n<td>共4卷</td>\n</tr>\n<tr>\n<td>後周紀</td>\n<td>290 - 294</td>\n<td>共5卷</td>\n</tr>\n</tbody>\n</table>\n<pre><code>進展：\n2017年11月27日 第101卷 晉紀。\n</code></pre>\n"},{"title":"线性代数这点事","catalog":true,"date":"2017-11-21T08:05:31.000Z","subtitle":null,"header-img":"/img/02.jpg","mathjax":true,"_content":"\n# 线性代数\n\n线性代数最重要的概念就是矩阵，理解矩阵，一定要先从变换起手。\n\n## 矩阵\n\n矩阵的本质就是在描述坐标系变换，比如一个二维直角坐标系向左旋转了90度，那么怎么才能描述这种运动呢，其实就可以盯住（1，0）和（0，1）这两个基本点的坐标在新的坐标系跑哪去了。\n\n如果我告诉你那两个坐标现在分别跑到了（0，1）和（-1，0）就明白新坐标系长什么样了。\n\n如果把这两个坐标竖起来写到一起，就是矩阵了！如下式：\n$$A = \\left[\n    \\begin{array}{}\n      0&-1\\\\\n      1& 0\n    \\end{array}\n\\right]$$\n\n* 矩阵A是变换的结果，也用来表示变换的过程。也就是说，矩阵A可以把标准坐标系旋转90度。\n\n* 由于坐标轴旋转了，整个坐标系也就随之旋转了，所有的坐标系内的向量也就一起旋转。\n\n* 当原坐标系里的任意向量被矩阵A施加变换以后，就得到了新坐标系内对应的向量，在这个该例中，就是得到了旋转90度后的向量。\n\n![-w250](http://otkwwi4x8.bkt.clouddn.com/15108096020947.jpg)\n\n    标准直角坐标系中，向量[1,0]和[0,1]构成了最基本的二维单位矩阵。\n    所有的矩阵都可以看成是对单位矩阵的变换。\n    所有的矩阵都是一套坐标系。\n\n## 变换\n变换和函数的作用是一样的。被称为变换也是体现了图形上的含义。\n\n线性变换就是原来是根线，变完还是根线。同时，原点不能动。简单讲线性变换就是拉伸、旋转。\n\n向量$v$是$x,y$的线性组合，那么不管$x,y$经历怎么样的线性变换，你大爷永远是你大爷。$v$永远是$x,y$的变换后相同系数的线性组合。\n$$v=3x + 4y$$\n$$\\hat{v}=3\\hat{x} + 4\\hat{y}$$\n\n* 二维空间中，只要知道两个变换后的向量，就可以求出任意向量经过变换后结果。\n* 下图中$x,y$为变换前的坐标，$\\hat j$,$\\hat i$都是已知w变换后的向量，可以求出经过变换后的向量。\n\n![-w400](http://otkwwi4x8.bkt.clouddn.com/15105677933631.jpg)\n\n\n\n\n下图解读为矩阵对向量$[x,y]$进行作用后得到的结果，其实也可以理解为向量对矩阵里的各列进行线性组合：\n![-w400](http://otkwwi4x8.bkt.clouddn.com/15105681717369.jpg)\n\n* **上图矩阵可以看成是将[1,0]变换成[a,c]，将[0,1]变换成[b,d]，OK，那么就可以由变换后的矩阵求得向量[x,y]被变换后的向量是什么。这也说明了为什么单位矩阵的乘法具有不变性，因为经过单位矩阵的作用之后还是原来的向量。**\n\n![-w150](http://otkwwi4x8.bkt.clouddn.com/15106401190857.jpg)\n\n* **上图中的x,y就是在新座系中的两个坐标。**\n\n\n\n    矩阵乘法的本质就是线性变换，所有的矩阵都是逐行对单位向量做变换\n\n\n## 矩阵乘法\n\n$$A \\times B = C$$\n\n    两个矩阵相乘，就是两个线性变换的叠加，结果矩阵也就是“增强”后的效果。\n\n下图中，可以看作是$M_2$对$M_1$的两个向量($[e,g]$、$[f,h]$)分别进行线性变换。\n![-w500](http://otkwwi4x8.bkt.clouddn.com/15106446775428.jpg)\n\n\n\n## 行列式\n\n$$ det( \\left[\n    \\begin{array}{}\n      a&b\\\\\n      c&d\n    \\end{array}\n\\right] )= e$$\n\n如上图行列式的结果$e$就是经过变换后，固定区域的缩放比例。\n![-w500](http://otkwwi4x8.bkt.clouddn.com/15106477083108.jpg)\n\n行列式可以为负值，当为负值时，空间定向变了。简单讲就是翻个儿了。\n![-w300](http://otkwwi4x8.bkt.clouddn.com/15106483421572.jpg)\n\n## 逆\n\n    矩阵的逆，就是矩阵变换后，再变回来。\n    \n下图中向量$\\vec{x}$经过矩阵$A$的变换后得到向量$\\vec{v}$，由此可得将$\\vec{v}$沿着${A}^{-1}$的还原回去，就会得到向量$\\vec{x}$。$$\\vec{x} = {A}^{-1} \\cdot \\vec{v}$$\n\n![-w500](http://otkwwi4x8.bkt.clouddn.com/15107489431518.jpg)\n\n* $det(A)$不等于0，意味着空间没有被压缩到丢维的程度。那么不管$A$有多大能耐，制造出多邪乎的变换，都可以还原，也就是说$A$可逆。\n\n    \n        比如你把二维空间给变换成了一条直线，那还怎么可能恢复成平面。\n    \n## 秩\n\n秩就是变换后的空间维数。$n$维矩阵变换后还是$n$维空间叫满秩。\n    \n    经过线性变换后的空间，如果是一条一维的直接，秩就是1。二维平面秩就是2。\n\n## 列空间\n\n列(基)向量的线性组合组成的空间。\n\n## 零空间\n\n线性变换后，被压缩到原点的那部分，叫零空间。\n\n    一个直线被线性压缩变换后只有原点保持不变；\n    一个平面被线性变换压缩成直线，原平面中有一条直线的空间就被压缩到了原点。\n    那么这条被压缩到原点的直线就是零空间。\n    \n\n如下式可以看出，所有可以被$A$变换压缩到原点的向量$\\vec{x}$集合组成了零空间。也就是方程组可能是解的集合。下式中如果向量$\\vec{x}$不在零空间内，也一定无解。\n$$A \\cdot \\vec{x} = \\left[\n    \\begin{array}{}\n      0\\\\\n      0\\\\\n      .\\\\\n      .\\\\\n      .\n    \\end{array}\n\\right]$$\n\n## 点积\n两个向量$\\vec{v},\\vec{j}$点积，几何意义就是$\\vec{v}$在$\\vec{j}$的投影长度，乘以$\\vec{j}$的长度。反之也成立，这是一个对称的。\n\n## 叉积\n* 两个向量围成的平行四边形的面积，有正有负。\n* 计算方式相对简单，将两个向量看成是由单位矩阵变换而来的两个基，行列式的值就是该面积。\n* 在求出该面积后，也就得出来叉积向量。它和上述的平行四边形平面垂直，长度就是面积值。如下图红色向量（需要用到右手定则）。\n\n![-w240](http://otkwwi4x8.bkt.clouddn.com/15108854308734.jpg)\n\n![-w240](http://otkwwi4x8.bkt.clouddn.com/15108855479844.jpg)\n\n## 基变换\n$${A}^{-1} \\cdot M \\cdot A$$\n\n## 特征\n在经历矩阵线性变换后，该向量还保持方向不变，该向量就是特征向量，且长度是放大比例就是特征值。零空间和特征有紧密联系。\n\n$$A \\vec{v} =  \\lambda \\vec{v}$$\n\n粉色轴是长度为1的特征向量，那么整个正方体可以在该方向旋转而不变形。\n![-w300](http://otkwwi4x8.bkt.clouddn.com/15114215605944.jpg)\n\n如果$\\lambda$大于1了，也就意味着在所有维度都放大$\\lambda$倍，否则就被拉歪了。各维度都牵扯相同的比例也不会“倾倒”。就像下面的矩阵一样，它们正是一组由单位矩阵缩放$\\lambda$倍得到的基。\n$$\n\\left[\n    \\begin{array}{}\n      1&0\\\\\n      0& 1\n    \\end{array}\n\\right]$$\n\n$$\\left[\n    \\begin{array}{}\n      \\lambda&0\\\\\n      0&\\lambda\n    \\end{array}\n\\right]\n$$\n\n## 抽象向量空间\n\n世间万物，符合线性特征者，皆可矩阵化运算。\n$$\nL(\\vec{v} + \\vec{w}) = L(\\vec{v}) + L(\\vec{w}) \n$$\n\n$$\nL(c\\vec{v}) = cL(\\vec{v})\n$$\n\n* 上一式表示一起整和分开整，一个效果\n* 上二式表示变一个大向量和变一个小向量再倍乘一个效果\n\n符合以上两点就是线性的。导数就是这样的\n$$\\frac{d}{dx}(x^3+x^2) = \\frac{d}{dx}(x^3)+\\frac{d}{dx}(x^2)$$\n$$\\frac{d}{dx}(4x^3) = 4\\frac{d}{dx}(x^3)$$\n\n下面这张图表示了用矩阵来求导数的过程，箭头为标准基，它由$x^0$,$x^1$,$x^2$…$x^n$一组基函数分别求导得出的一组导数基。\n![-w500](http://otkwwi4x8.bkt.clouddn.com/15114339843705.jpg)\n","source":"_posts/线性代数.md","raw":"---\ntitle: 线性代数这点事\ncatalog: true\ndate: 2017-11-21 16:05:31\nsubtitle:\nheader-img: \"/img/02.jpg\" \nmathjax: true\ntags: \"数学\"\n---\n\n# 线性代数\n\n线性代数最重要的概念就是矩阵，理解矩阵，一定要先从变换起手。\n\n## 矩阵\n\n矩阵的本质就是在描述坐标系变换，比如一个二维直角坐标系向左旋转了90度，那么怎么才能描述这种运动呢，其实就可以盯住（1，0）和（0，1）这两个基本点的坐标在新的坐标系跑哪去了。\n\n如果我告诉你那两个坐标现在分别跑到了（0，1）和（-1，0）就明白新坐标系长什么样了。\n\n如果把这两个坐标竖起来写到一起，就是矩阵了！如下式：\n$$A = \\left[\n    \\begin{array}{}\n      0&-1\\\\\n      1& 0\n    \\end{array}\n\\right]$$\n\n* 矩阵A是变换的结果，也用来表示变换的过程。也就是说，矩阵A可以把标准坐标系旋转90度。\n\n* 由于坐标轴旋转了，整个坐标系也就随之旋转了，所有的坐标系内的向量也就一起旋转。\n\n* 当原坐标系里的任意向量被矩阵A施加变换以后，就得到了新坐标系内对应的向量，在这个该例中，就是得到了旋转90度后的向量。\n\n![-w250](http://otkwwi4x8.bkt.clouddn.com/15108096020947.jpg)\n\n    标准直角坐标系中，向量[1,0]和[0,1]构成了最基本的二维单位矩阵。\n    所有的矩阵都可以看成是对单位矩阵的变换。\n    所有的矩阵都是一套坐标系。\n\n## 变换\n变换和函数的作用是一样的。被称为变换也是体现了图形上的含义。\n\n线性变换就是原来是根线，变完还是根线。同时，原点不能动。简单讲线性变换就是拉伸、旋转。\n\n向量$v$是$x,y$的线性组合，那么不管$x,y$经历怎么样的线性变换，你大爷永远是你大爷。$v$永远是$x,y$的变换后相同系数的线性组合。\n$$v=3x + 4y$$\n$$\\hat{v}=3\\hat{x} + 4\\hat{y}$$\n\n* 二维空间中，只要知道两个变换后的向量，就可以求出任意向量经过变换后结果。\n* 下图中$x,y$为变换前的坐标，$\\hat j$,$\\hat i$都是已知w变换后的向量，可以求出经过变换后的向量。\n\n![-w400](http://otkwwi4x8.bkt.clouddn.com/15105677933631.jpg)\n\n\n\n\n下图解读为矩阵对向量$[x,y]$进行作用后得到的结果，其实也可以理解为向量对矩阵里的各列进行线性组合：\n![-w400](http://otkwwi4x8.bkt.clouddn.com/15105681717369.jpg)\n\n* **上图矩阵可以看成是将[1,0]变换成[a,c]，将[0,1]变换成[b,d]，OK，那么就可以由变换后的矩阵求得向量[x,y]被变换后的向量是什么。这也说明了为什么单位矩阵的乘法具有不变性，因为经过单位矩阵的作用之后还是原来的向量。**\n\n![-w150](http://otkwwi4x8.bkt.clouddn.com/15106401190857.jpg)\n\n* **上图中的x,y就是在新座系中的两个坐标。**\n\n\n\n    矩阵乘法的本质就是线性变换，所有的矩阵都是逐行对单位向量做变换\n\n\n## 矩阵乘法\n\n$$A \\times B = C$$\n\n    两个矩阵相乘，就是两个线性变换的叠加，结果矩阵也就是“增强”后的效果。\n\n下图中，可以看作是$M_2$对$M_1$的两个向量($[e,g]$、$[f,h]$)分别进行线性变换。\n![-w500](http://otkwwi4x8.bkt.clouddn.com/15106446775428.jpg)\n\n\n\n## 行列式\n\n$$ det( \\left[\n    \\begin{array}{}\n      a&b\\\\\n      c&d\n    \\end{array}\n\\right] )= e$$\n\n如上图行列式的结果$e$就是经过变换后，固定区域的缩放比例。\n![-w500](http://otkwwi4x8.bkt.clouddn.com/15106477083108.jpg)\n\n行列式可以为负值，当为负值时，空间定向变了。简单讲就是翻个儿了。\n![-w300](http://otkwwi4x8.bkt.clouddn.com/15106483421572.jpg)\n\n## 逆\n\n    矩阵的逆，就是矩阵变换后，再变回来。\n    \n下图中向量$\\vec{x}$经过矩阵$A$的变换后得到向量$\\vec{v}$，由此可得将$\\vec{v}$沿着${A}^{-1}$的还原回去，就会得到向量$\\vec{x}$。$$\\vec{x} = {A}^{-1} \\cdot \\vec{v}$$\n\n![-w500](http://otkwwi4x8.bkt.clouddn.com/15107489431518.jpg)\n\n* $det(A)$不等于0，意味着空间没有被压缩到丢维的程度。那么不管$A$有多大能耐，制造出多邪乎的变换，都可以还原，也就是说$A$可逆。\n\n    \n        比如你把二维空间给变换成了一条直线，那还怎么可能恢复成平面。\n    \n## 秩\n\n秩就是变换后的空间维数。$n$维矩阵变换后还是$n$维空间叫满秩。\n    \n    经过线性变换后的空间，如果是一条一维的直接，秩就是1。二维平面秩就是2。\n\n## 列空间\n\n列(基)向量的线性组合组成的空间。\n\n## 零空间\n\n线性变换后，被压缩到原点的那部分，叫零空间。\n\n    一个直线被线性压缩变换后只有原点保持不变；\n    一个平面被线性变换压缩成直线，原平面中有一条直线的空间就被压缩到了原点。\n    那么这条被压缩到原点的直线就是零空间。\n    \n\n如下式可以看出，所有可以被$A$变换压缩到原点的向量$\\vec{x}$集合组成了零空间。也就是方程组可能是解的集合。下式中如果向量$\\vec{x}$不在零空间内，也一定无解。\n$$A \\cdot \\vec{x} = \\left[\n    \\begin{array}{}\n      0\\\\\n      0\\\\\n      .\\\\\n      .\\\\\n      .\n    \\end{array}\n\\right]$$\n\n## 点积\n两个向量$\\vec{v},\\vec{j}$点积，几何意义就是$\\vec{v}$在$\\vec{j}$的投影长度，乘以$\\vec{j}$的长度。反之也成立，这是一个对称的。\n\n## 叉积\n* 两个向量围成的平行四边形的面积，有正有负。\n* 计算方式相对简单，将两个向量看成是由单位矩阵变换而来的两个基，行列式的值就是该面积。\n* 在求出该面积后，也就得出来叉积向量。它和上述的平行四边形平面垂直，长度就是面积值。如下图红色向量（需要用到右手定则）。\n\n![-w240](http://otkwwi4x8.bkt.clouddn.com/15108854308734.jpg)\n\n![-w240](http://otkwwi4x8.bkt.clouddn.com/15108855479844.jpg)\n\n## 基变换\n$${A}^{-1} \\cdot M \\cdot A$$\n\n## 特征\n在经历矩阵线性变换后，该向量还保持方向不变，该向量就是特征向量，且长度是放大比例就是特征值。零空间和特征有紧密联系。\n\n$$A \\vec{v} =  \\lambda \\vec{v}$$\n\n粉色轴是长度为1的特征向量，那么整个正方体可以在该方向旋转而不变形。\n![-w300](http://otkwwi4x8.bkt.clouddn.com/15114215605944.jpg)\n\n如果$\\lambda$大于1了，也就意味着在所有维度都放大$\\lambda$倍，否则就被拉歪了。各维度都牵扯相同的比例也不会“倾倒”。就像下面的矩阵一样，它们正是一组由单位矩阵缩放$\\lambda$倍得到的基。\n$$\n\\left[\n    \\begin{array}{}\n      1&0\\\\\n      0& 1\n    \\end{array}\n\\right]$$\n\n$$\\left[\n    \\begin{array}{}\n      \\lambda&0\\\\\n      0&\\lambda\n    \\end{array}\n\\right]\n$$\n\n## 抽象向量空间\n\n世间万物，符合线性特征者，皆可矩阵化运算。\n$$\nL(\\vec{v} + \\vec{w}) = L(\\vec{v}) + L(\\vec{w}) \n$$\n\n$$\nL(c\\vec{v}) = cL(\\vec{v})\n$$\n\n* 上一式表示一起整和分开整，一个效果\n* 上二式表示变一个大向量和变一个小向量再倍乘一个效果\n\n符合以上两点就是线性的。导数就是这样的\n$$\\frac{d}{dx}(x^3+x^2) = \\frac{d}{dx}(x^3)+\\frac{d}{dx}(x^2)$$\n$$\\frac{d}{dx}(4x^3) = 4\\frac{d}{dx}(x^3)$$\n\n下面这张图表示了用矩阵来求导数的过程，箭头为标准基，它由$x^0$,$x^1$,$x^2$…$x^n$一组基函数分别求导得出的一组导数基。\n![-w500](http://otkwwi4x8.bkt.clouddn.com/15114339843705.jpg)\n","slug":"线性代数","published":1,"updated":"2017-11-23T10:50:20.475Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjahvvny7001cpv4nm9p3b5go","content":"<h1><span id=\"线性代数\"> 线性代数</span></h1>\n<p>线性代数最重要的概念就是矩阵，理解矩阵，一定要先从变换起手。</p>\n<h2><span id=\"矩阵\"> 矩阵</span></h2>\n<p>矩阵的本质就是在描述坐标系变换，比如一个二维直角坐标系向左旋转了90度，那么怎么才能描述这种运动呢，其实就可以盯住（1，0）和（0，1）这两个基本点的坐标在新的坐标系跑哪去了。</p>\n<p>如果我告诉你那两个坐标现在分别跑到了（0，1）和（-1，0）就明白新坐标系长什么样了。</p>\n<p>如果把这两个坐标竖起来写到一起，就是矩阵了！如下式：</p>\n<p><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>A</mi><mo>=</mo><mrow><mo fence=\"true\">[</mo><mtable><mtr><mtd><mrow><mn>0</mn></mrow></mtd><mtd><mrow><mo>−</mo><mn>1</mn></mrow></mtd></mtr><mtr><mtd><mrow><mn>1</mn></mrow></mtd><mtd><mrow><mn>0</mn></mrow></mtd></mtr></mtable><mo fence=\"true\">]</mo></mrow></mrow><annotation encoding=\"application/x-tex\">A = \\left[\n    \\begin{array}{}\n      0&amp;-1\\\\\n      1&amp; 0\n    \\end{array}\n\\right]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"strut\" style=\"height:1.45em;\"></span><span class=\"strut bottom\" style=\"height:2.40003em;vertical-align:-0.95003em;\"></span><span class=\"base displaystyle textstyle uncramped\"><span class=\"mord mathit\">A</span><span class=\"mrel\">=</span><span class=\"minner displaystyle textstyle uncramped\"><span class=\"style-wrap reset-textstyle textstyle uncramped\" style=\"top:0em;\"><span class=\"delimsizing size3\">[</span></span><span class=\"mord\"><span class=\"mtable\"><span class=\"arraycolsep\" style=\"width:0.5em;\"></span><span class=\"col-align-c\"><span class=\"vlist\"><span style=\"top:-0.6099999999999999em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"mord displaystyle textstyle uncramped\"><span class=\"mord mathrm\">0</span></span></span><span style=\"top:0.5900000000000003em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"mord displaystyle textstyle uncramped\"><span class=\"mord mathrm\">1</span></span></span><span class=\"baseline-fix\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span>​</span></span></span><span class=\"arraycolsep\" style=\"width:0.5em;\"></span><span class=\"arraycolsep\" style=\"width:0.5em;\"></span><span class=\"col-align-c\"><span class=\"vlist\"><span style=\"top:-0.6099999999999999em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"mord displaystyle textstyle uncramped\"><span class=\"mord\">−</span><span class=\"mord mathrm\">1</span></span></span><span style=\"top:0.5900000000000003em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"mord displaystyle textstyle uncramped\"><span class=\"mord mathrm\">0</span></span></span><span class=\"baseline-fix\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span>​</span></span></span><span class=\"arraycolsep\" style=\"width:0.5em;\"></span></span></span><span class=\"style-wrap reset-textstyle textstyle uncramped\" style=\"top:0em;\"><span class=\"delimsizing size3\">]</span></span></span></span></span></span></span></p>\n<ul>\n<li>\n<p>矩阵A是变换的结果，也用来表示变换的过程。也就是说，矩阵A可以把标准坐标系旋转90度。</p>\n</li>\n<li>\n<p>由于坐标轴旋转了，整个坐标系也就随之旋转了，所有的坐标系内的向量也就一起旋转。</p>\n</li>\n<li>\n<p>当原坐标系里的任意向量被矩阵A施加变换以后，就得到了新坐标系内对应的向量，在这个该例中，就是得到了旋转90度后的向量。</p>\n</li>\n</ul>\n<p><img src=\"http://otkwwi4x8.bkt.clouddn.com/15108096020947.jpg\" alt=\"-w250\"></p>\n<pre><code>标准直角坐标系中，向量[1,0]和[0,1]构成了最基本的二维单位矩阵。\n所有的矩阵都可以看成是对单位矩阵的变换。\n所有的矩阵都是一套坐标系。\n</code></pre>\n<h2><span id=\"变换\"> 变换</span></h2>\n<p>变换和函数的作用是一样的。被称为变换也是体现了图形上的含义。</p>\n<p>线性变换就是原来是根线，变完还是根线。同时，原点不能动。简单讲线性变换就是拉伸、旋转。</p>\n<p>向量<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>v</mi></mrow><annotation encoding=\"application/x-tex\">v</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"strut\" style=\"height:0.43056em;\"></span><span class=\"strut bottom\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"base textstyle uncramped\"><span class=\"mord mathit\" style=\"margin-right:0.03588em;\">v</span></span></span></span>是<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>x</mi><mo separator=\"true\">,</mo><mi>y</mi></mrow><annotation encoding=\"application/x-tex\">x,y</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"strut\" style=\"height:0.43056em;\"></span><span class=\"strut bottom\" style=\"height:0.625em;vertical-align:-0.19444em;\"></span><span class=\"base textstyle uncramped\"><span class=\"mord mathit\">x</span><span class=\"mpunct\">,</span><span class=\"mord mathit\" style=\"margin-right:0.03588em;\">y</span></span></span></span>的线性组合，那么不管<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>x</mi><mo separator=\"true\">,</mo><mi>y</mi></mrow><annotation encoding=\"application/x-tex\">x,y</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"strut\" style=\"height:0.43056em;\"></span><span class=\"strut bottom\" style=\"height:0.625em;vertical-align:-0.19444em;\"></span><span class=\"base textstyle uncramped\"><span class=\"mord mathit\">x</span><span class=\"mpunct\">,</span><span class=\"mord mathit\" style=\"margin-right:0.03588em;\">y</span></span></span></span>经历怎么样的线性变换，你大爷永远是你大爷。<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>v</mi></mrow><annotation encoding=\"application/x-tex\">v</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"strut\" style=\"height:0.43056em;\"></span><span class=\"strut bottom\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"base textstyle uncramped\"><span class=\"mord mathit\" style=\"margin-right:0.03588em;\">v</span></span></span></span>永远是<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>x</mi><mo separator=\"true\">,</mo><mi>y</mi></mrow><annotation encoding=\"application/x-tex\">x,y</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"strut\" style=\"height:0.43056em;\"></span><span class=\"strut bottom\" style=\"height:0.625em;vertical-align:-0.19444em;\"></span><span class=\"base textstyle uncramped\"><span class=\"mord mathit\">x</span><span class=\"mpunct\">,</span><span class=\"mord mathit\" style=\"margin-right:0.03588em;\">y</span></span></span></span>的变换后相同系数的线性组合。</p>\n<p><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>v</mi><mo>=</mo><mn>3</mn><mi>x</mi><mo>+</mo><mn>4</mn><mi>y</mi></mrow><annotation encoding=\"application/x-tex\">v=3x + 4y\n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"strut\" style=\"height:0.64444em;\"></span><span class=\"strut bottom\" style=\"height:0.8388800000000001em;vertical-align:-0.19444em;\"></span><span class=\"base displaystyle textstyle uncramped\"><span class=\"mord mathit\" style=\"margin-right:0.03588em;\">v</span><span class=\"mrel\">=</span><span class=\"mord mathrm\">3</span><span class=\"mord mathit\">x</span><span class=\"mbin\">+</span><span class=\"mord mathrm\">4</span><span class=\"mord mathit\" style=\"margin-right:0.03588em;\">y</span></span></span></span></span></p>\n<p><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mover accent=\"true\"><mrow><mi>v</mi></mrow><mo>^</mo></mover><mo>=</mo><mn>3</mn><mover accent=\"true\"><mrow><mi>x</mi></mrow><mo>^</mo></mover><mo>+</mo><mn>4</mn><mover accent=\"true\"><mrow><mi>y</mi></mrow><mo>^</mo></mover></mrow><annotation encoding=\"application/x-tex\">\\hat{v}=3\\hat{x} + 4\\hat{y}\n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"strut\" style=\"height:0.69444em;\"></span><span class=\"strut bottom\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"base displaystyle textstyle uncramped\"><span class=\"mord accent\"><span class=\"vlist\"><span style=\"top:0em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"mord displaystyle textstyle cramped\"><span class=\"mord mathit\" style=\"margin-right:0.03588em;\">v</span></span></span><span style=\"top:0em;margin-left:0.05556em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"accent-body\"><span>^</span></span></span><span class=\"baseline-fix\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span>​</span></span></span><span class=\"mrel\">=</span><span class=\"mord mathrm\">3</span><span class=\"mord accent\"><span class=\"vlist\"><span style=\"top:0em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"mord displaystyle textstyle cramped\"><span class=\"mord mathit\">x</span></span></span><span style=\"top:0em;margin-left:0.05556em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"accent-body\"><span>^</span></span></span><span class=\"baseline-fix\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span>​</span></span></span><span class=\"mbin\">+</span><span class=\"mord mathrm\">4</span><span class=\"mord accent\"><span class=\"vlist\"><span style=\"top:0em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"mord displaystyle textstyle cramped\"><span class=\"mord mathit\" style=\"margin-right:0.03588em;\">y</span></span></span><span style=\"top:0em;margin-left:0.11112em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"accent-body\"><span>^</span></span></span><span class=\"baseline-fix\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span>​</span></span></span></span></span></span></span></p>\n<ul>\n<li>二维空间中，只要知道两个变换后的向量，就可以求出任意向量经过变换后结果。</li>\n<li>下图中<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>x</mi><mo separator=\"true\">,</mo><mi>y</mi></mrow><annotation encoding=\"application/x-tex\">x,y</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"strut\" style=\"height:0.43056em;\"></span><span class=\"strut bottom\" style=\"height:0.625em;vertical-align:-0.19444em;\"></span><span class=\"base textstyle uncramped\"><span class=\"mord mathit\">x</span><span class=\"mpunct\">,</span><span class=\"mord mathit\" style=\"margin-right:0.03588em;\">y</span></span></span></span>为变换前的坐标，<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mover accent=\"true\"><mi>j</mi><mo>^</mo></mover></mrow><annotation encoding=\"application/x-tex\">\\hat j</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"strut\" style=\"height:0.92296em;\"></span><span class=\"strut bottom\" style=\"height:1.1174em;vertical-align:-0.19444em;\"></span><span class=\"base textstyle uncramped\"><span class=\"mord accent\"><span class=\"vlist\"><span style=\"top:0em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"mord mathit\" style=\"margin-right:0.05724em;\">j</span></span><span style=\"top:-0.2285200000000001em;margin-left:0em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"accent-body\"><span>^</span></span></span><span class=\"baseline-fix\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span>​</span></span></span></span></span></span>,<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mover accent=\"true\"><mi>i</mi><mo>^</mo></mover></mrow><annotation encoding=\"application/x-tex\">\\hat i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"strut\" style=\"height:0.92296em;\"></span><span class=\"strut bottom\" style=\"height:0.92296em;vertical-align:0em;\"></span><span class=\"base textstyle uncramped\"><span class=\"mord accent\"><span class=\"vlist\"><span style=\"top:0em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"mord mathit\">i</span></span><span style=\"top:-0.22852em;margin-left:0em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"accent-body\"><span>^</span></span></span><span class=\"baseline-fix\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span>​</span></span></span></span></span></span>都是已知w变换后的向量，可以求出经过变换后的向量。</li>\n</ul>\n<p><img src=\"http://otkwwi4x8.bkt.clouddn.com/15105677933631.jpg\" alt=\"-w400\"></p>\n<p>下图解读为矩阵对向量<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mo>[</mo><mi>x</mi><mo separator=\"true\">,</mo><mi>y</mi><mo>]</mo></mrow><annotation encoding=\"application/x-tex\">[x,y]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"strut\" style=\"height:0.75em;\"></span><span class=\"strut bottom\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"base textstyle uncramped\"><span class=\"mopen\">[</span><span class=\"mord mathit\">x</span><span class=\"mpunct\">,</span><span class=\"mord mathit\" style=\"margin-right:0.03588em;\">y</span><span class=\"mclose\">]</span></span></span></span>进行作用后得到的结果，其实也可以理解为向量对矩阵里的各列进行线性组合：<br>\n<img src=\"http://otkwwi4x8.bkt.clouddn.com/15105681717369.jpg\" alt=\"-w400\"></p>\n<ul>\n<li><strong>上图矩阵可以看成是将[1,0]变换成[a,c]，将[0,1]变换成[b,d]，OK，那么就可以由变换后的矩阵求得向量[x,y]被变换后的向量是什么。这也说明了为什么单位矩阵的乘法具有不变性，因为经过单位矩阵的作用之后还是原来的向量。</strong></li>\n</ul>\n<p><img src=\"http://otkwwi4x8.bkt.clouddn.com/15106401190857.jpg\" alt=\"-w150\"></p>\n<ul>\n<li>\n<p><strong>上图中的x,y就是在新座系中的两个坐标。</strong></p>\n<p>矩阵乘法的本质就是线性变换，所有的矩阵都是逐行对单位向量做变换</p>\n</li>\n</ul>\n<h2><span id=\"矩阵乘法\"> 矩阵乘法</span></h2>\n<p><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>A</mi><mo>×</mo><mi>B</mi><mo>=</mo><mi>C</mi></mrow><annotation encoding=\"application/x-tex\">A \\times B = C\n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"strut\" style=\"height:0.68333em;\"></span><span class=\"strut bottom\" style=\"height:0.76666em;vertical-align:-0.08333em;\"></span><span class=\"base displaystyle textstyle uncramped\"><span class=\"mord mathit\">A</span><span class=\"mbin\">×</span><span class=\"mord mathit\" style=\"margin-right:0.05017em;\">B</span><span class=\"mrel\">=</span><span class=\"mord mathit\" style=\"margin-right:0.07153em;\">C</span></span></span></span></span></p>\n<pre><code>两个矩阵相乘，就是两个线性变换的叠加，结果矩阵也就是“增强”后的效果。\n</code></pre>\n<p>下图中，可以看作是<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi>M</mi><mn>2</mn></msub></mrow><annotation encoding=\"application/x-tex\">M_2</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"strut\" style=\"height:0.68333em;\"></span><span class=\"strut bottom\" style=\"height:0.83333em;vertical-align:-0.15em;\"></span><span class=\"base textstyle uncramped\"><span class=\"mord\"><span class=\"mord mathit\" style=\"margin-right:0.10903em;\">M</span><span class=\"vlist\"><span style=\"top:0.15em;margin-right:0.05em;margin-left:-0.10903em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"reset-textstyle scriptstyle cramped\"><span class=\"mord mathrm\">2</span></span></span><span class=\"baseline-fix\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span>​</span></span></span></span></span></span>对<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi>M</mi><mn>1</mn></msub></mrow><annotation encoding=\"application/x-tex\">M_1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"strut\" style=\"height:0.68333em;\"></span><span class=\"strut bottom\" style=\"height:0.83333em;vertical-align:-0.15em;\"></span><span class=\"base textstyle uncramped\"><span class=\"mord\"><span class=\"mord mathit\" style=\"margin-right:0.10903em;\">M</span><span class=\"vlist\"><span style=\"top:0.15em;margin-right:0.05em;margin-left:-0.10903em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"reset-textstyle scriptstyle cramped\"><span class=\"mord mathrm\">1</span></span></span><span class=\"baseline-fix\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span>​</span></span></span></span></span></span>的两个向量(<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mo>[</mo><mi>e</mi><mo separator=\"true\">,</mo><mi>g</mi><mo>]</mo></mrow><annotation encoding=\"application/x-tex\">[e,g]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"strut\" style=\"height:0.75em;\"></span><span class=\"strut bottom\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"base textstyle uncramped\"><span class=\"mopen\">[</span><span class=\"mord mathit\">e</span><span class=\"mpunct\">,</span><span class=\"mord mathit\" style=\"margin-right:0.03588em;\">g</span><span class=\"mclose\">]</span></span></span></span>、<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mo>[</mo><mi>f</mi><mo separator=\"true\">,</mo><mi>h</mi><mo>]</mo></mrow><annotation encoding=\"application/x-tex\">[f,h]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"strut\" style=\"height:0.75em;\"></span><span class=\"strut bottom\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"base textstyle uncramped\"><span class=\"mopen\">[</span><span class=\"mord mathit\" style=\"margin-right:0.10764em;\">f</span><span class=\"mpunct\">,</span><span class=\"mord mathit\">h</span><span class=\"mclose\">]</span></span></span></span>)分别进行线性变换。<br>\n<img src=\"http://otkwwi4x8.bkt.clouddn.com/15106446775428.jpg\" alt=\"-w500\"></p>\n<h2><span id=\"行列式\"> 行列式</span></h2>\n<p><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>d</mi><mi>e</mi><mi>t</mi><mo>(</mo><mrow><mo fence=\"true\">[</mo><mtable><mtr><mtd><mrow><mi>a</mi></mrow></mtd><mtd><mrow><mi>b</mi></mrow></mtd></mtr><mtr><mtd><mrow><mi>c</mi></mrow></mtd><mtd><mrow><mi>d</mi></mrow></mtd></mtr></mtable><mo fence=\"true\">]</mo></mrow><mo>)</mo><mo>=</mo><mi>e</mi></mrow><annotation encoding=\"application/x-tex\"> det( \\left[\n    \\begin{array}{}\n      a&amp;b\\\\\n      c&amp;d\n    \\end{array}\n\\right] )= e</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"strut\" style=\"height:1.45em;\"></span><span class=\"strut bottom\" style=\"height:2.40003em;vertical-align:-0.95003em;\"></span><span class=\"base displaystyle textstyle uncramped\"><span class=\"mord mathit\">d</span><span class=\"mord mathit\">e</span><span class=\"mord mathit\">t</span><span class=\"mopen\">(</span><span class=\"minner displaystyle textstyle uncramped\"><span class=\"style-wrap reset-textstyle textstyle uncramped\" style=\"top:0em;\"><span class=\"delimsizing size3\">[</span></span><span class=\"mord\"><span class=\"mtable\"><span class=\"arraycolsep\" style=\"width:0.5em;\"></span><span class=\"col-align-c\"><span class=\"vlist\"><span style=\"top:-0.6099999999999999em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"mord displaystyle textstyle uncramped\"><span class=\"mord mathit\">a</span></span></span><span style=\"top:0.5900000000000003em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"mord displaystyle textstyle uncramped\"><span class=\"mord mathit\">c</span></span></span><span class=\"baseline-fix\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span>​</span></span></span><span class=\"arraycolsep\" style=\"width:0.5em;\"></span><span class=\"arraycolsep\" style=\"width:0.5em;\"></span><span class=\"col-align-c\"><span class=\"vlist\"><span style=\"top:-0.6099999999999999em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"mord displaystyle textstyle uncramped\"><span class=\"mord mathit\">b</span></span></span><span style=\"top:0.5900000000000003em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"mord displaystyle textstyle uncramped\"><span class=\"mord mathit\">d</span></span></span><span class=\"baseline-fix\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span>​</span></span></span><span class=\"arraycolsep\" style=\"width:0.5em;\"></span></span></span><span class=\"style-wrap reset-textstyle textstyle uncramped\" style=\"top:0em;\"><span class=\"delimsizing size3\">]</span></span></span><span class=\"mclose\">)</span><span class=\"mrel\">=</span><span class=\"mord mathit\">e</span></span></span></span></span></p>\n<p>如上图行列式的结果<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>e</mi></mrow><annotation encoding=\"application/x-tex\">e</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"strut\" style=\"height:0.43056em;\"></span><span class=\"strut bottom\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"base textstyle uncramped\"><span class=\"mord mathit\">e</span></span></span></span>就是经过变换后，固定区域的缩放比例。<br>\n<img src=\"http://otkwwi4x8.bkt.clouddn.com/15106477083108.jpg\" alt=\"-w500\"></p>\n<p>行列式可以为负值，当为负值时，空间定向变了。简单讲就是翻个儿了。<br>\n<img src=\"http://otkwwi4x8.bkt.clouddn.com/15106483421572.jpg\" alt=\"-w300\"></p>\n<h2><span id=\"逆\"> 逆</span></h2>\n<pre><code>矩阵的逆，就是矩阵变换后，再变回来。\n</code></pre>\n<p>下图中向量<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mover accent=\"true\"><mrow><mi>x</mi></mrow><mo>⃗</mo></mover></mrow><annotation encoding=\"application/x-tex\">\\vec{x}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"strut\" style=\"height:0.71444em;\"></span><span class=\"strut bottom\" style=\"height:0.71444em;vertical-align:0em;\"></span><span class=\"base textstyle uncramped\"><span class=\"mord accent\"><span class=\"vlist\"><span style=\"top:0em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"mord textstyle cramped\"><span class=\"mord mathit\">x</span></span></span><span style=\"top:0em;margin-left:0.05556em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"accent-body accent-vec\"><span>⃗</span></span></span><span class=\"baseline-fix\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span>​</span></span></span></span></span></span>经过矩阵<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"strut\" style=\"height:0.68333em;\"></span><span class=\"strut bottom\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"base textstyle uncramped\"><span class=\"mord mathit\">A</span></span></span></span>的变换后得到向量<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mover accent=\"true\"><mrow><mi>v</mi></mrow><mo>⃗</mo></mover></mrow><annotation encoding=\"application/x-tex\">\\vec{v}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"strut\" style=\"height:0.71444em;\"></span><span class=\"strut bottom\" style=\"height:0.71444em;vertical-align:0em;\"></span><span class=\"base textstyle uncramped\"><span class=\"mord accent\"><span class=\"vlist\"><span style=\"top:0em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"mord textstyle cramped\"><span class=\"mord mathit\" style=\"margin-right:0.03588em;\">v</span></span></span><span style=\"top:0em;margin-left:0.05556em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"accent-body accent-vec\"><span>⃗</span></span></span><span class=\"baseline-fix\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span>​</span></span></span></span></span></span>，由此可得将<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mover accent=\"true\"><mrow><mi>v</mi></mrow><mo>⃗</mo></mover></mrow><annotation encoding=\"application/x-tex\">\\vec{v}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"strut\" style=\"height:0.71444em;\"></span><span class=\"strut bottom\" style=\"height:0.71444em;vertical-align:0em;\"></span><span class=\"base textstyle uncramped\"><span class=\"mord accent\"><span class=\"vlist\"><span style=\"top:0em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"mord textstyle cramped\"><span class=\"mord mathit\" style=\"margin-right:0.03588em;\">v</span></span></span><span style=\"top:0em;margin-left:0.05556em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"accent-body accent-vec\"><span>⃗</span></span></span><span class=\"baseline-fix\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span>​</span></span></span></span></span></span>沿着<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msup><mrow><mi>A</mi></mrow><mrow><mo>−</mo><mn>1</mn></mrow></msup></mrow><annotation encoding=\"application/x-tex\">{A}^{-1}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"strut\" style=\"height:0.8141079999999999em;\"></span><span class=\"strut bottom\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"base textstyle uncramped\"><span class=\"mord\"><span class=\"mord textstyle uncramped\"><span class=\"mord mathit\">A</span></span><span class=\"vlist\"><span style=\"top:-0.363em;margin-right:0.05em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"reset-textstyle scriptstyle uncramped\"><span class=\"mord scriptstyle uncramped\"><span class=\"mord\">−</span><span class=\"mord mathrm\">1</span></span></span></span><span class=\"baseline-fix\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span>​</span></span></span></span></span></span>的还原回去，就会得到向量<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mover accent=\"true\"><mrow><mi>x</mi></mrow><mo>⃗</mo></mover></mrow><annotation encoding=\"application/x-tex\">\\vec{x}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"strut\" style=\"height:0.71444em;\"></span><span class=\"strut bottom\" style=\"height:0.71444em;vertical-align:0em;\"></span><span class=\"base textstyle uncramped\"><span class=\"mord accent\"><span class=\"vlist\"><span style=\"top:0em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"mord textstyle cramped\"><span class=\"mord mathit\">x</span></span></span><span style=\"top:0em;margin-left:0.05556em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"accent-body accent-vec\"><span>⃗</span></span></span><span class=\"baseline-fix\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span>​</span></span></span></span></span></span>。$$\\vec{x} = {A}^{-1} \\cdot \\vec{v}$$</p>\n<p><img src=\"http://otkwwi4x8.bkt.clouddn.com/15107489431518.jpg\" alt=\"-w500\"></p>\n<ul>\n<li>\n<p><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>d</mi><mi>e</mi><mi>t</mi><mo>(</mo><mi>A</mi><mo>)</mo></mrow><annotation encoding=\"application/x-tex\">det(A)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"strut\" style=\"height:0.75em;\"></span><span class=\"strut bottom\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"base textstyle uncramped\"><span class=\"mord mathit\">d</span><span class=\"mord mathit\">e</span><span class=\"mord mathit\">t</span><span class=\"mopen\">(</span><span class=\"mord mathit\">A</span><span class=\"mclose\">)</span></span></span></span>不等于0，意味着空间没有被压缩到丢维的程度。那么不管<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"strut\" style=\"height:0.68333em;\"></span><span class=\"strut bottom\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"base textstyle uncramped\"><span class=\"mord mathit\">A</span></span></span></span>有多大能耐，制造出多邪乎的变换，都可以还原，也就是说<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"strut\" style=\"height:0.68333em;\"></span><span class=\"strut bottom\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"base textstyle uncramped\"><span class=\"mord mathit\">A</span></span></span></span>可逆。</p>\n<pre><code>  比如你把二维空间给变换成了一条直线，那还怎么可能恢复成平面。\n</code></pre>\n</li>\n</ul>\n<h2><span id=\"秩\"> 秩</span></h2>\n<p>秩就是变换后的空间维数。<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"strut\" style=\"height:0.43056em;\"></span><span class=\"strut bottom\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"base textstyle uncramped\"><span class=\"mord mathit\">n</span></span></span></span>维矩阵变换后还是<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"strut\" style=\"height:0.43056em;\"></span><span class=\"strut bottom\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"base textstyle uncramped\"><span class=\"mord mathit\">n</span></span></span></span>维空间叫满秩。</p>\n<pre><code>经过线性变换后的空间，如果是一条一维的直接，秩就是1。二维平面秩就是2。\n</code></pre>\n<h2><span id=\"列空间\"> 列空间</span></h2>\n<p>列(基)向量的线性组合组成的空间。</p>\n<h2><span id=\"零空间\"> 零空间</span></h2>\n<p>线性变换后，被压缩到原点的那部分，叫零空间。</p>\n<pre><code>一个直线被线性压缩变换后只有原点保持不变；\n一个平面被线性变换压缩成直线，原平面中有一条直线的空间就被压缩到了原点。\n那么这条被压缩到原点的直线就是零空间。\n</code></pre>\n<p>如下式可以看出，所有可以被<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"strut\" style=\"height:0.68333em;\"></span><span class=\"strut bottom\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"base textstyle uncramped\"><span class=\"mord mathit\">A</span></span></span></span>变换压缩到原点的向量<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mover accent=\"true\"><mrow><mi>x</mi></mrow><mo>⃗</mo></mover></mrow><annotation encoding=\"application/x-tex\">\\vec{x}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"strut\" style=\"height:0.71444em;\"></span><span class=\"strut bottom\" style=\"height:0.71444em;vertical-align:0em;\"></span><span class=\"base textstyle uncramped\"><span class=\"mord accent\"><span class=\"vlist\"><span style=\"top:0em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"mord textstyle cramped\"><span class=\"mord mathit\">x</span></span></span><span style=\"top:0em;margin-left:0.05556em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"accent-body accent-vec\"><span>⃗</span></span></span><span class=\"baseline-fix\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span>​</span></span></span></span></span></span>集合组成了零空间。也就是方程组可能是解的集合。下式中如果向量<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mover accent=\"true\"><mrow><mi>x</mi></mrow><mo>⃗</mo></mover></mrow><annotation encoding=\"application/x-tex\">\\vec{x}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"strut\" style=\"height:0.71444em;\"></span><span class=\"strut bottom\" style=\"height:0.71444em;vertical-align:0em;\"></span><span class=\"base textstyle uncramped\"><span class=\"mord accent\"><span class=\"vlist\"><span style=\"top:0em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"mord textstyle cramped\"><span class=\"mord mathit\">x</span></span></span><span style=\"top:0em;margin-left:0.05556em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"accent-body accent-vec\"><span>⃗</span></span></span><span class=\"baseline-fix\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span>​</span></span></span></span></span></span>不在零空间内，也一定无解。</p>\n<p><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>A</mi><mo>⋅</mo><mover accent=\"true\"><mrow><mi>x</mi></mrow><mo>⃗</mo></mover><mo>=</mo><mrow><mo fence=\"true\">[</mo><mtable><mtr><mtd><mrow><mn>0</mn></mrow></mtd></mtr><mtr><mtd><mrow><mn>0</mn></mrow></mtd></mtr><mtr><mtd><mrow><mi mathvariant=\"normal\">.</mi></mrow></mtd></mtr><mtr><mtd><mrow><mi mathvariant=\"normal\">.</mi></mrow></mtd></mtr><mtr><mtd><mrow><mi mathvariant=\"normal\">.</mi></mrow></mtd></mtr></mtable><mo fence=\"true\">]</mo></mrow></mrow><annotation encoding=\"application/x-tex\">A \\cdot \\vec{x} = \\left[\n    \\begin{array}{}\n      0\\\\\n      0\\\\\n      .\\\\\n      .\\\\\n      .\n    \\end{array}\n\\right]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"strut\" style=\"height:3.2540000000000004em;\"></span><span class=\"strut bottom\" style=\"height:6.00404em;vertical-align:-2.75004em;\"></span><span class=\"base displaystyle textstyle uncramped\"><span class=\"mord mathit\">A</span><span class=\"mbin\">⋅</span><span class=\"mord accent\"><span class=\"vlist\"><span style=\"top:0em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"mord displaystyle textstyle cramped\"><span class=\"mord mathit\">x</span></span></span><span style=\"top:0em;margin-left:0.05556em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"accent-body accent-vec\"><span>⃗</span></span></span><span class=\"baseline-fix\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span>​</span></span></span><span class=\"mrel\">=</span><span class=\"minner displaystyle textstyle uncramped\"><span class=\"style-wrap reset-textstyle textstyle uncramped\"><span class=\"delimsizing mult\"><span class=\"vlist\"><span style=\"top:2.1050199999999997em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"delimsizinginner delim-size4\"><span>⎣</span></span></span><span style=\"top:0.9500199999999999em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"delimsizinginner delim-size4\"><span>⎢</span></span></span><span style=\"top:0.3490199999999999em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"delimsizinginner delim-size4\"><span>⎢</span></span></span><span style=\"top:-0.2519800000000001em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"delimsizinginner delim-size4\"><span>⎢</span></span></span><span style=\"top:-0.8529800000000001em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"delimsizinginner delim-size4\"><span>⎢</span></span></span><span style=\"top:-2.099em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"delimsizinginner delim-size4\"><span>⎡</span></span></span><span class=\"baseline-fix\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span>​</span></span></span></span><span class=\"mord\"><span class=\"mtable\"><span class=\"arraycolsep\" style=\"width:0.5em;\"></span><span class=\"col-align-c\"><span class=\"vlist\"><span style=\"top:-2.41em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"mord displaystyle textstyle uncramped\"><span class=\"mord mathrm\">0</span></span></span><span style=\"top:-1.2100000000000002em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"mord displaystyle textstyle uncramped\"><span class=\"mord mathrm\">0</span></span></span><span style=\"top:-0.009999999999999953em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"mord displaystyle textstyle uncramped\"><span class=\"mord mathrm\">.</span></span></span><span style=\"top:1.1900000000000002em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"mord displaystyle textstyle uncramped\"><span class=\"mord mathrm\">.</span></span></span><span style=\"top:2.3900000000000006em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"mord displaystyle textstyle uncramped\"><span class=\"mord mathrm\">.</span></span></span><span class=\"baseline-fix\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span>​</span></span></span><span class=\"arraycolsep\" style=\"width:0.5em;\"></span></span></span><span class=\"style-wrap reset-textstyle textstyle uncramped\"><span class=\"delimsizing mult\"><span class=\"vlist\"><span style=\"top:2.1050199999999997em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"delimsizinginner delim-size4\"><span>⎦</span></span></span><span style=\"top:0.9500199999999999em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"delimsizinginner delim-size4\"><span>⎥</span></span></span><span style=\"top:0.3490199999999999em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"delimsizinginner delim-size4\"><span>⎥</span></span></span><span style=\"top:-0.2519800000000001em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"delimsizinginner delim-size4\"><span>⎥</span></span></span><span style=\"top:-0.8529800000000001em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"delimsizinginner delim-size4\"><span>⎥</span></span></span><span style=\"top:-2.099em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"delimsizinginner delim-size4\"><span>⎤</span></span></span><span class=\"baseline-fix\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span>​</span></span></span></span></span></span></span></span></span></p>\n<h2><span id=\"点积\"> 点积</span></h2>\n<p>两个向量<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mover accent=\"true\"><mrow><mi>v</mi></mrow><mo>⃗</mo></mover><mo separator=\"true\">,</mo><mover accent=\"true\"><mrow><mi>j</mi></mrow><mo>⃗</mo></mover></mrow><annotation encoding=\"application/x-tex\">\\vec{v},\\vec{j}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"strut\" style=\"height:0.94296em;\"></span><span class=\"strut bottom\" style=\"height:1.1374em;vertical-align:-0.19444em;\"></span><span class=\"base textstyle uncramped\"><span class=\"mord accent\"><span class=\"vlist\"><span style=\"top:0em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"mord textstyle cramped\"><span class=\"mord mathit\" style=\"margin-right:0.03588em;\">v</span></span></span><span style=\"top:0em;margin-left:0.05556em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"accent-body accent-vec\"><span>⃗</span></span></span><span class=\"baseline-fix\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span>​</span></span></span><span class=\"mpunct\">,</span><span class=\"mord accent\"><span class=\"vlist\"><span style=\"top:0em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"mord textstyle cramped\"><span class=\"mord mathit\" style=\"margin-right:0.05724em;\">j</span></span></span><span style=\"top:-0.2285200000000001em;margin-left:0em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"accent-body accent-vec\"><span>⃗</span></span></span><span class=\"baseline-fix\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span>​</span></span></span></span></span></span>点积，几何意义就是<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mover accent=\"true\"><mrow><mi>v</mi></mrow><mo>⃗</mo></mover></mrow><annotation encoding=\"application/x-tex\">\\vec{v}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"strut\" style=\"height:0.71444em;\"></span><span class=\"strut bottom\" style=\"height:0.71444em;vertical-align:0em;\"></span><span class=\"base textstyle uncramped\"><span class=\"mord accent\"><span class=\"vlist\"><span style=\"top:0em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"mord textstyle cramped\"><span class=\"mord mathit\" style=\"margin-right:0.03588em;\">v</span></span></span><span style=\"top:0em;margin-left:0.05556em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"accent-body accent-vec\"><span>⃗</span></span></span><span class=\"baseline-fix\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span>​</span></span></span></span></span></span>在<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mover accent=\"true\"><mrow><mi>j</mi></mrow><mo>⃗</mo></mover></mrow><annotation encoding=\"application/x-tex\">\\vec{j}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"strut\" style=\"height:0.94296em;\"></span><span class=\"strut bottom\" style=\"height:1.1374em;vertical-align:-0.19444em;\"></span><span class=\"base textstyle uncramped\"><span class=\"mord accent\"><span class=\"vlist\"><span style=\"top:0em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"mord textstyle cramped\"><span class=\"mord mathit\" style=\"margin-right:0.05724em;\">j</span></span></span><span style=\"top:-0.2285200000000001em;margin-left:0em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"accent-body accent-vec\"><span>⃗</span></span></span><span class=\"baseline-fix\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span>​</span></span></span></span></span></span>的投影长度，乘以<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mover accent=\"true\"><mrow><mi>j</mi></mrow><mo>⃗</mo></mover></mrow><annotation encoding=\"application/x-tex\">\\vec{j}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"strut\" style=\"height:0.94296em;\"></span><span class=\"strut bottom\" style=\"height:1.1374em;vertical-align:-0.19444em;\"></span><span class=\"base textstyle uncramped\"><span class=\"mord accent\"><span class=\"vlist\"><span style=\"top:0em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"mord textstyle cramped\"><span class=\"mord mathit\" style=\"margin-right:0.05724em;\">j</span></span></span><span style=\"top:-0.2285200000000001em;margin-left:0em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"accent-body accent-vec\"><span>⃗</span></span></span><span class=\"baseline-fix\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span>​</span></span></span></span></span></span>的长度。反之也成立，这是一个对称的。</p>\n<h2><span id=\"叉积\"> 叉积</span></h2>\n<ul>\n<li>两个向量围成的平行四边形的面积，有正有负。</li>\n<li>计算方式相对简单，将两个向量看成是由单位矩阵变换而来的两个基，行列式的值就是该面积。</li>\n<li>在求出该面积后，也就得出来叉积向量。它和上述的平行四边形平面垂直，长度就是面积值。如下图红色向量（需要用到右手定则）。</li>\n</ul>\n<p><img src=\"http://otkwwi4x8.bkt.clouddn.com/15108854308734.jpg\" alt=\"-w240\"></p>\n<p><img src=\"http://otkwwi4x8.bkt.clouddn.com/15108855479844.jpg\" alt=\"-w240\"></p>\n<h2><span id=\"基变换\"> 基变换</span></h2>\n<p><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msup><mrow><mi>A</mi></mrow><mrow><mo>−</mo><mn>1</mn></mrow></msup><mo>⋅</mo><mi>M</mi><mo>⋅</mo><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">{A}^{-1} \\cdot M \\cdot A\n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"strut\" style=\"height:0.864108em;\"></span><span class=\"strut bottom\" style=\"height:0.864108em;vertical-align:0em;\"></span><span class=\"base displaystyle textstyle uncramped\"><span class=\"mord\"><span class=\"mord displaystyle textstyle uncramped\"><span class=\"mord mathit\">A</span></span><span class=\"vlist\"><span style=\"top:-0.41300000000000003em;margin-right:0.05em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"reset-textstyle scriptstyle uncramped\"><span class=\"mord scriptstyle uncramped\"><span class=\"mord\">−</span><span class=\"mord mathrm\">1</span></span></span></span><span class=\"baseline-fix\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span>​</span></span></span><span class=\"mbin\">⋅</span><span class=\"mord mathit\" style=\"margin-right:0.10903em;\">M</span><span class=\"mbin\">⋅</span><span class=\"mord mathit\">A</span></span></span></span></span></p>\n<h2><span id=\"特征\"> 特征</span></h2>\n<p>在经历矩阵线性变换后，该向量还保持方向不变，该向量就是特征向量，且长度是放大比例就是特征值。零空间和特征有紧密联系。</p>\n<p><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>A</mi><mover accent=\"true\"><mrow><mi>v</mi></mrow><mo>⃗</mo></mover><mo>=</mo><mi>λ</mi><mover accent=\"true\"><mrow><mi>v</mi></mrow><mo>⃗</mo></mover></mrow><annotation encoding=\"application/x-tex\">A \\vec{v} =  \\lambda \\vec{v}\n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"strut\" style=\"height:0.71444em;\"></span><span class=\"strut bottom\" style=\"height:0.71444em;vertical-align:0em;\"></span><span class=\"base displaystyle textstyle uncramped\"><span class=\"mord mathit\">A</span><span class=\"mord accent\"><span class=\"vlist\"><span style=\"top:0em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"mord displaystyle textstyle cramped\"><span class=\"mord mathit\" style=\"margin-right:0.03588em;\">v</span></span></span><span style=\"top:0em;margin-left:0.05556em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"accent-body accent-vec\"><span>⃗</span></span></span><span class=\"baseline-fix\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span>​</span></span></span><span class=\"mrel\">=</span><span class=\"mord mathit\">λ</span><span class=\"mord accent\"><span class=\"vlist\"><span style=\"top:0em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"mord displaystyle textstyle cramped\"><span class=\"mord mathit\" style=\"margin-right:0.03588em;\">v</span></span></span><span style=\"top:0em;margin-left:0.05556em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"accent-body accent-vec\"><span>⃗</span></span></span><span class=\"baseline-fix\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span>​</span></span></span></span></span></span></span></p>\n<p>粉色轴是长度为1的特征向量，那么整个正方体可以在该方向旋转而不变形。<br>\n<img src=\"http://otkwwi4x8.bkt.clouddn.com/15114215605944.jpg\" alt=\"-w300\"></p>\n<p>如果<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>λ</mi></mrow><annotation encoding=\"application/x-tex\">\\lambda</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"strut\" style=\"height:0.69444em;\"></span><span class=\"strut bottom\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"base textstyle uncramped\"><span class=\"mord mathit\">λ</span></span></span></span>大于1了，也就意味着在所有维度都放大<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>λ</mi></mrow><annotation encoding=\"application/x-tex\">\\lambda</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"strut\" style=\"height:0.69444em;\"></span><span class=\"strut bottom\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"base textstyle uncramped\"><span class=\"mord mathit\">λ</span></span></span></span>倍，否则就被拉歪了。各维度都牵扯相同的比例也不会“倾倒”。就像下面的矩阵一样，它们正是一组由单位矩阵缩放<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>λ</mi></mrow><annotation encoding=\"application/x-tex\">\\lambda</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"strut\" style=\"height:0.69444em;\"></span><span class=\"strut bottom\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"base textstyle uncramped\"><span class=\"mord mathit\">λ</span></span></span></span>倍得到的基。</p>\n<p><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mrow><mo fence=\"true\">[</mo><mtable><mtr><mtd><mrow><mn>1</mn></mrow></mtd><mtd><mrow><mn>0</mn></mrow></mtd></mtr><mtr><mtd><mrow><mn>0</mn></mrow></mtd><mtd><mrow><mn>1</mn></mrow></mtd></mtr></mtable><mo fence=\"true\">]</mo></mrow></mrow><annotation encoding=\"application/x-tex\">\\left[\n    \\begin{array}{}\n      1&amp;0\\\\\n      0&amp; 1\n    \\end{array}\n\\right]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"strut\" style=\"height:1.45em;\"></span><span class=\"strut bottom\" style=\"height:2.40003em;vertical-align:-0.95003em;\"></span><span class=\"base displaystyle textstyle uncramped\"><span class=\"minner displaystyle textstyle uncramped\"><span class=\"style-wrap reset-textstyle textstyle uncramped\" style=\"top:0em;\"><span class=\"delimsizing size3\">[</span></span><span class=\"mord\"><span class=\"mtable\"><span class=\"arraycolsep\" style=\"width:0.5em;\"></span><span class=\"col-align-c\"><span class=\"vlist\"><span style=\"top:-0.6099999999999999em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"mord displaystyle textstyle uncramped\"><span class=\"mord mathrm\">1</span></span></span><span style=\"top:0.5900000000000003em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"mord displaystyle textstyle uncramped\"><span class=\"mord mathrm\">0</span></span></span><span class=\"baseline-fix\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span>​</span></span></span><span class=\"arraycolsep\" style=\"width:0.5em;\"></span><span class=\"arraycolsep\" style=\"width:0.5em;\"></span><span class=\"col-align-c\"><span class=\"vlist\"><span style=\"top:-0.6099999999999999em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"mord displaystyle textstyle uncramped\"><span class=\"mord mathrm\">0</span></span></span><span style=\"top:0.5900000000000003em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"mord displaystyle textstyle uncramped\"><span class=\"mord mathrm\">1</span></span></span><span class=\"baseline-fix\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span>​</span></span></span><span class=\"arraycolsep\" style=\"width:0.5em;\"></span></span></span><span class=\"style-wrap reset-textstyle textstyle uncramped\" style=\"top:0em;\"><span class=\"delimsizing size3\">]</span></span></span></span></span></span></span></p>\n<p><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mrow><mo fence=\"true\">[</mo><mtable><mtr><mtd><mrow><mi>λ</mi></mrow></mtd><mtd><mrow><mn>0</mn></mrow></mtd></mtr><mtr><mtd><mrow><mn>0</mn></mrow></mtd><mtd><mrow><mi>λ</mi></mrow></mtd></mtr></mtable><mo fence=\"true\">]</mo></mrow></mrow><annotation encoding=\"application/x-tex\">\\left[\n    \\begin{array}{}\n      \\lambda&amp;0\\\\\n      0&amp;\\lambda\n    \\end{array}\n\\right]\n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"strut\" style=\"height:1.45em;\"></span><span class=\"strut bottom\" style=\"height:2.40003em;vertical-align:-0.95003em;\"></span><span class=\"base displaystyle textstyle uncramped\"><span class=\"minner displaystyle textstyle uncramped\"><span class=\"style-wrap reset-textstyle textstyle uncramped\" style=\"top:0em;\"><span class=\"delimsizing size3\">[</span></span><span class=\"mord\"><span class=\"mtable\"><span class=\"arraycolsep\" style=\"width:0.5em;\"></span><span class=\"col-align-c\"><span class=\"vlist\"><span style=\"top:-0.6099999999999999em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"mord displaystyle textstyle uncramped\"><span class=\"mord mathit\">λ</span></span></span><span style=\"top:0.5900000000000003em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"mord displaystyle textstyle uncramped\"><span class=\"mord mathrm\">0</span></span></span><span class=\"baseline-fix\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span>​</span></span></span><span class=\"arraycolsep\" style=\"width:0.5em;\"></span><span class=\"arraycolsep\" style=\"width:0.5em;\"></span><span class=\"col-align-c\"><span class=\"vlist\"><span style=\"top:-0.6099999999999999em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"mord displaystyle textstyle uncramped\"><span class=\"mord mathrm\">0</span></span></span><span style=\"top:0.5900000000000003em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"mord displaystyle textstyle uncramped\"><span class=\"mord mathit\">λ</span></span></span><span class=\"baseline-fix\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span>​</span></span></span><span class=\"arraycolsep\" style=\"width:0.5em;\"></span></span></span><span class=\"style-wrap reset-textstyle textstyle uncramped\" style=\"top:0em;\"><span class=\"delimsizing size3\">]</span></span></span></span></span></span></span></p>\n<h2><span id=\"抽象向量空间\"> 抽象向量空间</span></h2>\n<p>世间万物，符合线性特征者，皆可矩阵化运算。</p>\n<p><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>L</mi><mo>(</mo><mover accent=\"true\"><mrow><mi>v</mi></mrow><mo>⃗</mo></mover><mo>+</mo><mover accent=\"true\"><mrow><mi>w</mi></mrow><mo>⃗</mo></mover><mo>)</mo><mo>=</mo><mi>L</mi><mo>(</mo><mover accent=\"true\"><mrow><mi>v</mi></mrow><mo>⃗</mo></mover><mo>)</mo><mo>+</mo><mi>L</mi><mo>(</mo><mover accent=\"true\"><mrow><mi>w</mi></mrow><mo>⃗</mo></mover><mo>)</mo></mrow><annotation encoding=\"application/x-tex\">L(\\vec{v} + \\vec{w}) = L(\\vec{v}) + L(\\vec{w}) \n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"strut\" style=\"height:0.75em;\"></span><span class=\"strut bottom\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"base displaystyle textstyle uncramped\"><span class=\"mord mathit\">L</span><span class=\"mopen\">(</span><span class=\"mord accent\"><span class=\"vlist\"><span style=\"top:0em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"mord displaystyle textstyle cramped\"><span class=\"mord mathit\" style=\"margin-right:0.03588em;\">v</span></span></span><span style=\"top:0em;margin-left:0.05556em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"accent-body accent-vec\"><span>⃗</span></span></span><span class=\"baseline-fix\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span>​</span></span></span><span class=\"mbin\">+</span><span class=\"mord accent\"><span class=\"vlist\"><span style=\"top:0em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"mord displaystyle textstyle cramped\"><span class=\"mord mathit\" style=\"margin-right:0.02691em;\">w</span></span></span><span style=\"top:0em;margin-left:0.16668em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"accent-body accent-vec\"><span>⃗</span></span></span><span class=\"baseline-fix\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span>​</span></span></span><span class=\"mclose\">)</span><span class=\"mrel\">=</span><span class=\"mord mathit\">L</span><span class=\"mopen\">(</span><span class=\"mord accent\"><span class=\"vlist\"><span style=\"top:0em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"mord displaystyle textstyle cramped\"><span class=\"mord mathit\" style=\"margin-right:0.03588em;\">v</span></span></span><span style=\"top:0em;margin-left:0.05556em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"accent-body accent-vec\"><span>⃗</span></span></span><span class=\"baseline-fix\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span>​</span></span></span><span class=\"mclose\">)</span><span class=\"mbin\">+</span><span class=\"mord mathit\">L</span><span class=\"mopen\">(</span><span class=\"mord accent\"><span class=\"vlist\"><span style=\"top:0em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"mord displaystyle textstyle cramped\"><span class=\"mord mathit\" style=\"margin-right:0.02691em;\">w</span></span></span><span style=\"top:0em;margin-left:0.16668em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"accent-body accent-vec\"><span>⃗</span></span></span><span class=\"baseline-fix\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span>​</span></span></span><span class=\"mclose\">)</span></span></span></span></span></p>\n<p><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>L</mi><mo>(</mo><mi>c</mi><mover accent=\"true\"><mrow><mi>v</mi></mrow><mo>⃗</mo></mover><mo>)</mo><mo>=</mo><mi>c</mi><mi>L</mi><mo>(</mo><mover accent=\"true\"><mrow><mi>v</mi></mrow><mo>⃗</mo></mover><mo>)</mo></mrow><annotation encoding=\"application/x-tex\">L(c\\vec{v}) = cL(\\vec{v})\n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"strut\" style=\"height:0.75em;\"></span><span class=\"strut bottom\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"base displaystyle textstyle uncramped\"><span class=\"mord mathit\">L</span><span class=\"mopen\">(</span><span class=\"mord mathit\">c</span><span class=\"mord accent\"><span class=\"vlist\"><span style=\"top:0em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"mord displaystyle textstyle cramped\"><span class=\"mord mathit\" style=\"margin-right:0.03588em;\">v</span></span></span><span style=\"top:0em;margin-left:0.05556em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"accent-body accent-vec\"><span>⃗</span></span></span><span class=\"baseline-fix\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span>​</span></span></span><span class=\"mclose\">)</span><span class=\"mrel\">=</span><span class=\"mord mathit\">c</span><span class=\"mord mathit\">L</span><span class=\"mopen\">(</span><span class=\"mord accent\"><span class=\"vlist\"><span style=\"top:0em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"mord displaystyle textstyle cramped\"><span class=\"mord mathit\" style=\"margin-right:0.03588em;\">v</span></span></span><span style=\"top:0em;margin-left:0.05556em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"accent-body accent-vec\"><span>⃗</span></span></span><span class=\"baseline-fix\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span>​</span></span></span><span class=\"mclose\">)</span></span></span></span></span></p>\n<ul>\n<li>上一式表示一起整和分开整，一个效果</li>\n<li>上二式表示变一个大向量和变一个小向量再倍乘一个效果</li>\n</ul>\n<p>符合以上两点就是线性的。导数就是这样的</p>\n<p><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mfrac><mrow><mi>d</mi></mrow><mrow><mi>d</mi><mi>x</mi></mrow></mfrac><mo>(</mo><msup><mi>x</mi><mn>3</mn></msup><mo>+</mo><msup><mi>x</mi><mn>2</mn></msup><mo>)</mo><mo>=</mo><mfrac><mrow><mi>d</mi></mrow><mrow><mi>d</mi><mi>x</mi></mrow></mfrac><mo>(</mo><msup><mi>x</mi><mn>3</mn></msup><mo>)</mo><mo>+</mo><mfrac><mrow><mi>d</mi></mrow><mrow><mi>d</mi><mi>x</mi></mrow></mfrac><mo>(</mo><msup><mi>x</mi><mn>2</mn></msup><mo>)</mo></mrow><annotation encoding=\"application/x-tex\">\\frac{d}{dx}(x^3+x^2) = \\frac{d}{dx}(x^3)+\\frac{d}{dx}(x^2)\n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"strut\" style=\"height:1.37144em;\"></span><span class=\"strut bottom\" style=\"height:2.05744em;vertical-align:-0.686em;\"></span><span class=\"base displaystyle textstyle uncramped\"><span class=\"mord reset-textstyle displaystyle textstyle uncramped\"><span class=\"sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist\"><span style=\"top:0.686em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"reset-textstyle textstyle cramped\"><span class=\"mord textstyle cramped\"><span class=\"mord mathit\">d</span><span class=\"mord mathit\">x</span></span></span></span><span style=\"top:-0.22999999999999998em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"reset-textstyle textstyle uncramped frac-line\"></span></span><span style=\"top:-0.677em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"reset-textstyle textstyle uncramped\"><span class=\"mord textstyle uncramped\"><span class=\"mord mathit\">d</span></span></span></span><span class=\"baseline-fix\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span>​</span></span></span><span class=\"sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter\"></span></span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathit\">x</span><span class=\"vlist\"><span style=\"top:-0.413em;margin-right:0.05em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"reset-textstyle scriptstyle uncramped\"><span class=\"mord mathrm\">3</span></span></span><span class=\"baseline-fix\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span>​</span></span></span><span class=\"mbin\">+</span><span class=\"mord\"><span class=\"mord mathit\">x</span><span class=\"vlist\"><span style=\"top:-0.413em;margin-right:0.05em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"reset-textstyle scriptstyle uncramped\"><span class=\"mord mathrm\">2</span></span></span><span class=\"baseline-fix\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span>​</span></span></span><span class=\"mclose\">)</span><span class=\"mrel\">=</span><span class=\"mord reset-textstyle displaystyle textstyle uncramped\"><span class=\"sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist\"><span style=\"top:0.686em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"reset-textstyle textstyle cramped\"><span class=\"mord textstyle cramped\"><span class=\"mord mathit\">d</span><span class=\"mord mathit\">x</span></span></span></span><span style=\"top:-0.22999999999999998em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"reset-textstyle textstyle uncramped frac-line\"></span></span><span style=\"top:-0.677em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"reset-textstyle textstyle uncramped\"><span class=\"mord textstyle uncramped\"><span class=\"mord mathit\">d</span></span></span></span><span class=\"baseline-fix\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span>​</span></span></span><span class=\"sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter\"></span></span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathit\">x</span><span class=\"vlist\"><span style=\"top:-0.413em;margin-right:0.05em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"reset-textstyle scriptstyle uncramped\"><span class=\"mord mathrm\">3</span></span></span><span class=\"baseline-fix\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span>​</span></span></span><span class=\"mclose\">)</span><span class=\"mbin\">+</span><span class=\"mord reset-textstyle displaystyle textstyle uncramped\"><span class=\"sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist\"><span style=\"top:0.686em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"reset-textstyle textstyle cramped\"><span class=\"mord textstyle cramped\"><span class=\"mord mathit\">d</span><span class=\"mord mathit\">x</span></span></span></span><span style=\"top:-0.22999999999999998em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"reset-textstyle textstyle uncramped frac-line\"></span></span><span style=\"top:-0.677em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"reset-textstyle textstyle uncramped\"><span class=\"mord textstyle uncramped\"><span class=\"mord mathit\">d</span></span></span></span><span class=\"baseline-fix\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span>​</span></span></span><span class=\"sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter\"></span></span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathit\">x</span><span class=\"vlist\"><span style=\"top:-0.413em;margin-right:0.05em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"reset-textstyle scriptstyle uncramped\"><span class=\"mord mathrm\">2</span></span></span><span class=\"baseline-fix\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span>​</span></span></span><span class=\"mclose\">)</span></span></span></span></span></p>\n<p><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mfrac><mrow><mi>d</mi></mrow><mrow><mi>d</mi><mi>x</mi></mrow></mfrac><mo>(</mo><mn>4</mn><msup><mi>x</mi><mn>3</mn></msup><mo>)</mo><mo>=</mo><mn>4</mn><mfrac><mrow><mi>d</mi></mrow><mrow><mi>d</mi><mi>x</mi></mrow></mfrac><mo>(</mo><msup><mi>x</mi><mn>3</mn></msup><mo>)</mo></mrow><annotation encoding=\"application/x-tex\">\\frac{d}{dx}(4x^3) = 4\\frac{d}{dx}(x^3)\n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"strut\" style=\"height:1.37144em;\"></span><span class=\"strut bottom\" style=\"height:2.05744em;vertical-align:-0.686em;\"></span><span class=\"base displaystyle textstyle uncramped\"><span class=\"mord reset-textstyle displaystyle textstyle uncramped\"><span class=\"sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist\"><span style=\"top:0.686em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"reset-textstyle textstyle cramped\"><span class=\"mord textstyle cramped\"><span class=\"mord mathit\">d</span><span class=\"mord mathit\">x</span></span></span></span><span style=\"top:-0.22999999999999998em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"reset-textstyle textstyle uncramped frac-line\"></span></span><span style=\"top:-0.677em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"reset-textstyle textstyle uncramped\"><span class=\"mord textstyle uncramped\"><span class=\"mord mathit\">d</span></span></span></span><span class=\"baseline-fix\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span>​</span></span></span><span class=\"sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter\"></span></span><span class=\"mopen\">(</span><span class=\"mord mathrm\">4</span><span class=\"mord\"><span class=\"mord mathit\">x</span><span class=\"vlist\"><span style=\"top:-0.413em;margin-right:0.05em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"reset-textstyle scriptstyle uncramped\"><span class=\"mord mathrm\">3</span></span></span><span class=\"baseline-fix\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span>​</span></span></span><span class=\"mclose\">)</span><span class=\"mrel\">=</span><span class=\"mord mathrm\">4</span><span class=\"mord reset-textstyle displaystyle textstyle uncramped\"><span class=\"sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist\"><span style=\"top:0.686em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"reset-textstyle textstyle cramped\"><span class=\"mord textstyle cramped\"><span class=\"mord mathit\">d</span><span class=\"mord mathit\">x</span></span></span></span><span style=\"top:-0.22999999999999998em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"reset-textstyle textstyle uncramped frac-line\"></span></span><span style=\"top:-0.677em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"reset-textstyle textstyle uncramped\"><span class=\"mord textstyle uncramped\"><span class=\"mord mathit\">d</span></span></span></span><span class=\"baseline-fix\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span>​</span></span></span><span class=\"sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter\"></span></span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathit\">x</span><span class=\"vlist\"><span style=\"top:-0.413em;margin-right:0.05em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"reset-textstyle scriptstyle uncramped\"><span class=\"mord mathrm\">3</span></span></span><span class=\"baseline-fix\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span>​</span></span></span><span class=\"mclose\">)</span></span></span></span></span></p>\n<p>下面这张图表示了用矩阵来求导数的过程，箭头为标准基，它由<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msup><mi>x</mi><mn>0</mn></msup></mrow><annotation encoding=\"application/x-tex\">x^0</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"strut\" style=\"height:0.8141079999999999em;\"></span><span class=\"strut bottom\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"base textstyle uncramped\"><span class=\"mord\"><span class=\"mord mathit\">x</span><span class=\"vlist\"><span style=\"top:-0.363em;margin-right:0.05em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"reset-textstyle scriptstyle uncramped\"><span class=\"mord mathrm\">0</span></span></span><span class=\"baseline-fix\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span>​</span></span></span></span></span></span>,<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msup><mi>x</mi><mn>1</mn></msup></mrow><annotation encoding=\"application/x-tex\">x^1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"strut\" style=\"height:0.8141079999999999em;\"></span><span class=\"strut bottom\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"base textstyle uncramped\"><span class=\"mord\"><span class=\"mord mathit\">x</span><span class=\"vlist\"><span style=\"top:-0.363em;margin-right:0.05em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"reset-textstyle scriptstyle uncramped\"><span class=\"mord mathrm\">1</span></span></span><span class=\"baseline-fix\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span>​</span></span></span></span></span></span>,<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msup><mi>x</mi><mn>2</mn></msup></mrow><annotation encoding=\"application/x-tex\">x^2</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"strut\" style=\"height:0.8141079999999999em;\"></span><span class=\"strut bottom\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"base textstyle uncramped\"><span class=\"mord\"><span class=\"mord mathit\">x</span><span class=\"vlist\"><span style=\"top:-0.363em;margin-right:0.05em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"reset-textstyle scriptstyle uncramped\"><span class=\"mord mathrm\">2</span></span></span><span class=\"baseline-fix\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span>​</span></span></span></span></span></span>…<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msup><mi>x</mi><mi>n</mi></msup></mrow><annotation encoding=\"application/x-tex\">x^n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"strut\" style=\"height:0.664392em;\"></span><span class=\"strut bottom\" style=\"height:0.664392em;vertical-align:0em;\"></span><span class=\"base textstyle uncramped\"><span class=\"mord\"><span class=\"mord mathit\">x</span><span class=\"vlist\"><span style=\"top:-0.363em;margin-right:0.05em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"reset-textstyle scriptstyle uncramped\"><span class=\"mord mathit\">n</span></span></span><span class=\"baseline-fix\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span>​</span></span></span></span></span></span>一组基函数分别求导得出的一组导数基。<br>\n<img src=\"http://otkwwi4x8.bkt.clouddn.com/15114339843705.jpg\" alt=\"-w500\"></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"线性代数\"><a class=\"markdownIt-Anchor\" href=\"#线性代数\"></a> 线性代数</h1>\n<p>线性代数最重要的概念就是矩阵，理解矩阵，一定要先从变换起手。</p>\n<h2 id=\"矩阵\"><a class=\"markdownIt-Anchor\" href=\"#矩阵\"></a> 矩阵</h2>\n<p>矩阵的本质就是在描述坐标系变换，比如一个二维直角坐标系向左旋转了90度，那么怎么才能描述这种运动呢，其实就可以盯住（1，0）和（0，1）这两个基本点的坐标在新的坐标系跑哪去了。</p>\n<p>如果我告诉你那两个坐标现在分别跑到了（0，1）和（-1，0）就明白新坐标系长什么样了。</p>\n<p>如果把这两个坐标竖起来写到一起，就是矩阵了！如下式：</p>\n<p><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>A</mi><mo>=</mo><mrow><mo fence=\"true\">[</mo><mtable><mtr><mtd><mrow><mn>0</mn></mrow></mtd><mtd><mrow><mo>−</mo><mn>1</mn></mrow></mtd></mtr><mtr><mtd><mrow><mn>1</mn></mrow></mtd><mtd><mrow><mn>0</mn></mrow></mtd></mtr></mtable><mo fence=\"true\">]</mo></mrow></mrow><annotation encoding=\"application/x-tex\">A = \\left[\n    \\begin{array}{}\n      0&amp;-1\\\\\n      1&amp; 0\n    \\end{array}\n\\right]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"strut\" style=\"height:1.45em;\"></span><span class=\"strut bottom\" style=\"height:2.40003em;vertical-align:-0.95003em;\"></span><span class=\"base displaystyle textstyle uncramped\"><span class=\"mord mathit\">A</span><span class=\"mrel\">=</span><span class=\"minner displaystyle textstyle uncramped\"><span class=\"style-wrap reset-textstyle textstyle uncramped\" style=\"top:0em;\"><span class=\"delimsizing size3\">[</span></span><span class=\"mord\"><span class=\"mtable\"><span class=\"arraycolsep\" style=\"width:0.5em;\"></span><span class=\"col-align-c\"><span class=\"vlist\"><span style=\"top:-0.6099999999999999em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"mord displaystyle textstyle uncramped\"><span class=\"mord mathrm\">0</span></span></span><span style=\"top:0.5900000000000003em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"mord displaystyle textstyle uncramped\"><span class=\"mord mathrm\">1</span></span></span><span class=\"baseline-fix\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span>​</span></span></span><span class=\"arraycolsep\" style=\"width:0.5em;\"></span><span class=\"arraycolsep\" style=\"width:0.5em;\"></span><span class=\"col-align-c\"><span class=\"vlist\"><span style=\"top:-0.6099999999999999em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"mord displaystyle textstyle uncramped\"><span class=\"mord\">−</span><span class=\"mord mathrm\">1</span></span></span><span style=\"top:0.5900000000000003em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"mord displaystyle textstyle uncramped\"><span class=\"mord mathrm\">0</span></span></span><span class=\"baseline-fix\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span>​</span></span></span><span class=\"arraycolsep\" style=\"width:0.5em;\"></span></span></span><span class=\"style-wrap reset-textstyle textstyle uncramped\" style=\"top:0em;\"><span class=\"delimsizing size3\">]</span></span></span></span></span></span></span></p>\n<ul>\n<li>\n<p>矩阵A是变换的结果，也用来表示变换的过程。也就是说，矩阵A可以把标准坐标系旋转90度。</p>\n</li>\n<li>\n<p>由于坐标轴旋转了，整个坐标系也就随之旋转了，所有的坐标系内的向量也就一起旋转。</p>\n</li>\n<li>\n<p>当原坐标系里的任意向量被矩阵A施加变换以后，就得到了新坐标系内对应的向量，在这个该例中，就是得到了旋转90度后的向量。</p>\n</li>\n</ul>\n<p><img src=\"http://otkwwi4x8.bkt.clouddn.com/15108096020947.jpg\" alt=\"-w250\"></p>\n<pre><code>标准直角坐标系中，向量[1,0]和[0,1]构成了最基本的二维单位矩阵。\n所有的矩阵都可以看成是对单位矩阵的变换。\n所有的矩阵都是一套坐标系。\n</code></pre>\n<h2 id=\"变换\"><a class=\"markdownIt-Anchor\" href=\"#变换\"></a> 变换</h2>\n<p>变换和函数的作用是一样的。被称为变换也是体现了图形上的含义。</p>\n<p>线性变换就是原来是根线，变完还是根线。同时，原点不能动。简单讲线性变换就是拉伸、旋转。</p>\n<p>向量<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>v</mi></mrow><annotation encoding=\"application/x-tex\">v</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"strut\" style=\"height:0.43056em;\"></span><span class=\"strut bottom\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"base textstyle uncramped\"><span class=\"mord mathit\" style=\"margin-right:0.03588em;\">v</span></span></span></span>是<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>x</mi><mo separator=\"true\">,</mo><mi>y</mi></mrow><annotation encoding=\"application/x-tex\">x,y</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"strut\" style=\"height:0.43056em;\"></span><span class=\"strut bottom\" style=\"height:0.625em;vertical-align:-0.19444em;\"></span><span class=\"base textstyle uncramped\"><span class=\"mord mathit\">x</span><span class=\"mpunct\">,</span><span class=\"mord mathit\" style=\"margin-right:0.03588em;\">y</span></span></span></span>的线性组合，那么不管<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>x</mi><mo separator=\"true\">,</mo><mi>y</mi></mrow><annotation encoding=\"application/x-tex\">x,y</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"strut\" style=\"height:0.43056em;\"></span><span class=\"strut bottom\" style=\"height:0.625em;vertical-align:-0.19444em;\"></span><span class=\"base textstyle uncramped\"><span class=\"mord mathit\">x</span><span class=\"mpunct\">,</span><span class=\"mord mathit\" style=\"margin-right:0.03588em;\">y</span></span></span></span>经历怎么样的线性变换，你大爷永远是你大爷。<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>v</mi></mrow><annotation encoding=\"application/x-tex\">v</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"strut\" style=\"height:0.43056em;\"></span><span class=\"strut bottom\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"base textstyle uncramped\"><span class=\"mord mathit\" style=\"margin-right:0.03588em;\">v</span></span></span></span>永远是<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>x</mi><mo separator=\"true\">,</mo><mi>y</mi></mrow><annotation encoding=\"application/x-tex\">x,y</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"strut\" style=\"height:0.43056em;\"></span><span class=\"strut bottom\" style=\"height:0.625em;vertical-align:-0.19444em;\"></span><span class=\"base textstyle uncramped\"><span class=\"mord mathit\">x</span><span class=\"mpunct\">,</span><span class=\"mord mathit\" style=\"margin-right:0.03588em;\">y</span></span></span></span>的变换后相同系数的线性组合。</p>\n<p><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>v</mi><mo>=</mo><mn>3</mn><mi>x</mi><mo>+</mo><mn>4</mn><mi>y</mi></mrow><annotation encoding=\"application/x-tex\">v=3x + 4y\n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"strut\" style=\"height:0.64444em;\"></span><span class=\"strut bottom\" style=\"height:0.8388800000000001em;vertical-align:-0.19444em;\"></span><span class=\"base displaystyle textstyle uncramped\"><span class=\"mord mathit\" style=\"margin-right:0.03588em;\">v</span><span class=\"mrel\">=</span><span class=\"mord mathrm\">3</span><span class=\"mord mathit\">x</span><span class=\"mbin\">+</span><span class=\"mord mathrm\">4</span><span class=\"mord mathit\" style=\"margin-right:0.03588em;\">y</span></span></span></span></span></p>\n<p><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mover accent=\"true\"><mrow><mi>v</mi></mrow><mo>^</mo></mover><mo>=</mo><mn>3</mn><mover accent=\"true\"><mrow><mi>x</mi></mrow><mo>^</mo></mover><mo>+</mo><mn>4</mn><mover accent=\"true\"><mrow><mi>y</mi></mrow><mo>^</mo></mover></mrow><annotation encoding=\"application/x-tex\">\\hat{v}=3\\hat{x} + 4\\hat{y}\n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"strut\" style=\"height:0.69444em;\"></span><span class=\"strut bottom\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"base displaystyle textstyle uncramped\"><span class=\"mord accent\"><span class=\"vlist\"><span style=\"top:0em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"mord displaystyle textstyle cramped\"><span class=\"mord mathit\" style=\"margin-right:0.03588em;\">v</span></span></span><span style=\"top:0em;margin-left:0.05556em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"accent-body\"><span>^</span></span></span><span class=\"baseline-fix\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span>​</span></span></span><span class=\"mrel\">=</span><span class=\"mord mathrm\">3</span><span class=\"mord accent\"><span class=\"vlist\"><span style=\"top:0em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"mord displaystyle textstyle cramped\"><span class=\"mord mathit\">x</span></span></span><span style=\"top:0em;margin-left:0.05556em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"accent-body\"><span>^</span></span></span><span class=\"baseline-fix\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span>​</span></span></span><span class=\"mbin\">+</span><span class=\"mord mathrm\">4</span><span class=\"mord accent\"><span class=\"vlist\"><span style=\"top:0em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"mord displaystyle textstyle cramped\"><span class=\"mord mathit\" style=\"margin-right:0.03588em;\">y</span></span></span><span style=\"top:0em;margin-left:0.11112em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"accent-body\"><span>^</span></span></span><span class=\"baseline-fix\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span>​</span></span></span></span></span></span></span></p>\n<ul>\n<li>二维空间中，只要知道两个变换后的向量，就可以求出任意向量经过变换后结果。</li>\n<li>下图中<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>x</mi><mo separator=\"true\">,</mo><mi>y</mi></mrow><annotation encoding=\"application/x-tex\">x,y</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"strut\" style=\"height:0.43056em;\"></span><span class=\"strut bottom\" style=\"height:0.625em;vertical-align:-0.19444em;\"></span><span class=\"base textstyle uncramped\"><span class=\"mord mathit\">x</span><span class=\"mpunct\">,</span><span class=\"mord mathit\" style=\"margin-right:0.03588em;\">y</span></span></span></span>为变换前的坐标，<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mover accent=\"true\"><mi>j</mi><mo>^</mo></mover></mrow><annotation encoding=\"application/x-tex\">\\hat j</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"strut\" style=\"height:0.92296em;\"></span><span class=\"strut bottom\" style=\"height:1.1174em;vertical-align:-0.19444em;\"></span><span class=\"base textstyle uncramped\"><span class=\"mord accent\"><span class=\"vlist\"><span style=\"top:0em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"mord mathit\" style=\"margin-right:0.05724em;\">j</span></span><span style=\"top:-0.2285200000000001em;margin-left:0em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"accent-body\"><span>^</span></span></span><span class=\"baseline-fix\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span>​</span></span></span></span></span></span>,<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mover accent=\"true\"><mi>i</mi><mo>^</mo></mover></mrow><annotation encoding=\"application/x-tex\">\\hat i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"strut\" style=\"height:0.92296em;\"></span><span class=\"strut bottom\" style=\"height:0.92296em;vertical-align:0em;\"></span><span class=\"base textstyle uncramped\"><span class=\"mord accent\"><span class=\"vlist\"><span style=\"top:0em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"mord mathit\">i</span></span><span style=\"top:-0.22852em;margin-left:0em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"accent-body\"><span>^</span></span></span><span class=\"baseline-fix\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span>​</span></span></span></span></span></span>都是已知w变换后的向量，可以求出经过变换后的向量。</li>\n</ul>\n<p><img src=\"http://otkwwi4x8.bkt.clouddn.com/15105677933631.jpg\" alt=\"-w400\"></p>\n<p>下图解读为矩阵对向量<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mo>[</mo><mi>x</mi><mo separator=\"true\">,</mo><mi>y</mi><mo>]</mo></mrow><annotation encoding=\"application/x-tex\">[x,y]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"strut\" style=\"height:0.75em;\"></span><span class=\"strut bottom\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"base textstyle uncramped\"><span class=\"mopen\">[</span><span class=\"mord mathit\">x</span><span class=\"mpunct\">,</span><span class=\"mord mathit\" style=\"margin-right:0.03588em;\">y</span><span class=\"mclose\">]</span></span></span></span>进行作用后得到的结果，其实也可以理解为向量对矩阵里的各列进行线性组合：<br>\n<img src=\"http://otkwwi4x8.bkt.clouddn.com/15105681717369.jpg\" alt=\"-w400\"></p>\n<ul>\n<li><strong>上图矩阵可以看成是将[1,0]变换成[a,c]，将[0,1]变换成[b,d]，OK，那么就可以由变换后的矩阵求得向量[x,y]被变换后的向量是什么。这也说明了为什么单位矩阵的乘法具有不变性，因为经过单位矩阵的作用之后还是原来的向量。</strong></li>\n</ul>\n<p><img src=\"http://otkwwi4x8.bkt.clouddn.com/15106401190857.jpg\" alt=\"-w150\"></p>\n<ul>\n<li>\n<p><strong>上图中的x,y就是在新座系中的两个坐标。</strong></p>\n<p>矩阵乘法的本质就是线性变换，所有的矩阵都是逐行对单位向量做变换</p>\n</li>\n</ul>\n<h2 id=\"矩阵乘法\"><a class=\"markdownIt-Anchor\" href=\"#矩阵乘法\"></a> 矩阵乘法</h2>\n<p><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>A</mi><mo>×</mo><mi>B</mi><mo>=</mo><mi>C</mi></mrow><annotation encoding=\"application/x-tex\">A \\times B = C\n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"strut\" style=\"height:0.68333em;\"></span><span class=\"strut bottom\" style=\"height:0.76666em;vertical-align:-0.08333em;\"></span><span class=\"base displaystyle textstyle uncramped\"><span class=\"mord mathit\">A</span><span class=\"mbin\">×</span><span class=\"mord mathit\" style=\"margin-right:0.05017em;\">B</span><span class=\"mrel\">=</span><span class=\"mord mathit\" style=\"margin-right:0.07153em;\">C</span></span></span></span></span></p>\n<pre><code>两个矩阵相乘，就是两个线性变换的叠加，结果矩阵也就是“增强”后的效果。\n</code></pre>\n<p>下图中，可以看作是<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi>M</mi><mn>2</mn></msub></mrow><annotation encoding=\"application/x-tex\">M_2</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"strut\" style=\"height:0.68333em;\"></span><span class=\"strut bottom\" style=\"height:0.83333em;vertical-align:-0.15em;\"></span><span class=\"base textstyle uncramped\"><span class=\"mord\"><span class=\"mord mathit\" style=\"margin-right:0.10903em;\">M</span><span class=\"vlist\"><span style=\"top:0.15em;margin-right:0.05em;margin-left:-0.10903em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"reset-textstyle scriptstyle cramped\"><span class=\"mord mathrm\">2</span></span></span><span class=\"baseline-fix\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span>​</span></span></span></span></span></span>对<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi>M</mi><mn>1</mn></msub></mrow><annotation encoding=\"application/x-tex\">M_1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"strut\" style=\"height:0.68333em;\"></span><span class=\"strut bottom\" style=\"height:0.83333em;vertical-align:-0.15em;\"></span><span class=\"base textstyle uncramped\"><span class=\"mord\"><span class=\"mord mathit\" style=\"margin-right:0.10903em;\">M</span><span class=\"vlist\"><span style=\"top:0.15em;margin-right:0.05em;margin-left:-0.10903em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"reset-textstyle scriptstyle cramped\"><span class=\"mord mathrm\">1</span></span></span><span class=\"baseline-fix\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span>​</span></span></span></span></span></span>的两个向量(<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mo>[</mo><mi>e</mi><mo separator=\"true\">,</mo><mi>g</mi><mo>]</mo></mrow><annotation encoding=\"application/x-tex\">[e,g]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"strut\" style=\"height:0.75em;\"></span><span class=\"strut bottom\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"base textstyle uncramped\"><span class=\"mopen\">[</span><span class=\"mord mathit\">e</span><span class=\"mpunct\">,</span><span class=\"mord mathit\" style=\"margin-right:0.03588em;\">g</span><span class=\"mclose\">]</span></span></span></span>、<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mo>[</mo><mi>f</mi><mo separator=\"true\">,</mo><mi>h</mi><mo>]</mo></mrow><annotation encoding=\"application/x-tex\">[f,h]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"strut\" style=\"height:0.75em;\"></span><span class=\"strut bottom\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"base textstyle uncramped\"><span class=\"mopen\">[</span><span class=\"mord mathit\" style=\"margin-right:0.10764em;\">f</span><span class=\"mpunct\">,</span><span class=\"mord mathit\">h</span><span class=\"mclose\">]</span></span></span></span>)分别进行线性变换。<br>\n<img src=\"http://otkwwi4x8.bkt.clouddn.com/15106446775428.jpg\" alt=\"-w500\"></p>\n<h2 id=\"行列式\"><a class=\"markdownIt-Anchor\" href=\"#行列式\"></a> 行列式</h2>\n<p><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>d</mi><mi>e</mi><mi>t</mi><mo>(</mo><mrow><mo fence=\"true\">[</mo><mtable><mtr><mtd><mrow><mi>a</mi></mrow></mtd><mtd><mrow><mi>b</mi></mrow></mtd></mtr><mtr><mtd><mrow><mi>c</mi></mrow></mtd><mtd><mrow><mi>d</mi></mrow></mtd></mtr></mtable><mo fence=\"true\">]</mo></mrow><mo>)</mo><mo>=</mo><mi>e</mi></mrow><annotation encoding=\"application/x-tex\"> det( \\left[\n    \\begin{array}{}\n      a&amp;b\\\\\n      c&amp;d\n    \\end{array}\n\\right] )= e</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"strut\" style=\"height:1.45em;\"></span><span class=\"strut bottom\" style=\"height:2.40003em;vertical-align:-0.95003em;\"></span><span class=\"base displaystyle textstyle uncramped\"><span class=\"mord mathit\">d</span><span class=\"mord mathit\">e</span><span class=\"mord mathit\">t</span><span class=\"mopen\">(</span><span class=\"minner displaystyle textstyle uncramped\"><span class=\"style-wrap reset-textstyle textstyle uncramped\" style=\"top:0em;\"><span class=\"delimsizing size3\">[</span></span><span class=\"mord\"><span class=\"mtable\"><span class=\"arraycolsep\" style=\"width:0.5em;\"></span><span class=\"col-align-c\"><span class=\"vlist\"><span style=\"top:-0.6099999999999999em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"mord displaystyle textstyle uncramped\"><span class=\"mord mathit\">a</span></span></span><span style=\"top:0.5900000000000003em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"mord displaystyle textstyle uncramped\"><span class=\"mord mathit\">c</span></span></span><span class=\"baseline-fix\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span>​</span></span></span><span class=\"arraycolsep\" style=\"width:0.5em;\"></span><span class=\"arraycolsep\" style=\"width:0.5em;\"></span><span class=\"col-align-c\"><span class=\"vlist\"><span style=\"top:-0.6099999999999999em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"mord displaystyle textstyle uncramped\"><span class=\"mord mathit\">b</span></span></span><span style=\"top:0.5900000000000003em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"mord displaystyle textstyle uncramped\"><span class=\"mord mathit\">d</span></span></span><span class=\"baseline-fix\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span>​</span></span></span><span class=\"arraycolsep\" style=\"width:0.5em;\"></span></span></span><span class=\"style-wrap reset-textstyle textstyle uncramped\" style=\"top:0em;\"><span class=\"delimsizing size3\">]</span></span></span><span class=\"mclose\">)</span><span class=\"mrel\">=</span><span class=\"mord mathit\">e</span></span></span></span></span></p>\n<p>如上图行列式的结果<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>e</mi></mrow><annotation encoding=\"application/x-tex\">e</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"strut\" style=\"height:0.43056em;\"></span><span class=\"strut bottom\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"base textstyle uncramped\"><span class=\"mord mathit\">e</span></span></span></span>就是经过变换后，固定区域的缩放比例。<br>\n<img src=\"http://otkwwi4x8.bkt.clouddn.com/15106477083108.jpg\" alt=\"-w500\"></p>\n<p>行列式可以为负值，当为负值时，空间定向变了。简单讲就是翻个儿了。<br>\n<img src=\"http://otkwwi4x8.bkt.clouddn.com/15106483421572.jpg\" alt=\"-w300\"></p>\n<h2 id=\"逆\"><a class=\"markdownIt-Anchor\" href=\"#逆\"></a> 逆</h2>\n<pre><code>矩阵的逆，就是矩阵变换后，再变回来。\n</code></pre>\n<p>下图中向量<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mover accent=\"true\"><mrow><mi>x</mi></mrow><mo>⃗</mo></mover></mrow><annotation encoding=\"application/x-tex\">\\vec{x}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"strut\" style=\"height:0.71444em;\"></span><span class=\"strut bottom\" style=\"height:0.71444em;vertical-align:0em;\"></span><span class=\"base textstyle uncramped\"><span class=\"mord accent\"><span class=\"vlist\"><span style=\"top:0em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"mord textstyle cramped\"><span class=\"mord mathit\">x</span></span></span><span style=\"top:0em;margin-left:0.05556em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"accent-body accent-vec\"><span>⃗</span></span></span><span class=\"baseline-fix\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span>​</span></span></span></span></span></span>经过矩阵<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"strut\" style=\"height:0.68333em;\"></span><span class=\"strut bottom\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"base textstyle uncramped\"><span class=\"mord mathit\">A</span></span></span></span>的变换后得到向量<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mover accent=\"true\"><mrow><mi>v</mi></mrow><mo>⃗</mo></mover></mrow><annotation encoding=\"application/x-tex\">\\vec{v}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"strut\" style=\"height:0.71444em;\"></span><span class=\"strut bottom\" style=\"height:0.71444em;vertical-align:0em;\"></span><span class=\"base textstyle uncramped\"><span class=\"mord accent\"><span class=\"vlist\"><span style=\"top:0em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"mord textstyle cramped\"><span class=\"mord mathit\" style=\"margin-right:0.03588em;\">v</span></span></span><span style=\"top:0em;margin-left:0.05556em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"accent-body accent-vec\"><span>⃗</span></span></span><span class=\"baseline-fix\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span>​</span></span></span></span></span></span>，由此可得将<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mover accent=\"true\"><mrow><mi>v</mi></mrow><mo>⃗</mo></mover></mrow><annotation encoding=\"application/x-tex\">\\vec{v}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"strut\" style=\"height:0.71444em;\"></span><span class=\"strut bottom\" style=\"height:0.71444em;vertical-align:0em;\"></span><span class=\"base textstyle uncramped\"><span class=\"mord accent\"><span class=\"vlist\"><span style=\"top:0em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"mord textstyle cramped\"><span class=\"mord mathit\" style=\"margin-right:0.03588em;\">v</span></span></span><span style=\"top:0em;margin-left:0.05556em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"accent-body accent-vec\"><span>⃗</span></span></span><span class=\"baseline-fix\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span>​</span></span></span></span></span></span>沿着<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msup><mrow><mi>A</mi></mrow><mrow><mo>−</mo><mn>1</mn></mrow></msup></mrow><annotation encoding=\"application/x-tex\">{A}^{-1}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"strut\" style=\"height:0.8141079999999999em;\"></span><span class=\"strut bottom\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"base textstyle uncramped\"><span class=\"mord\"><span class=\"mord textstyle uncramped\"><span class=\"mord mathit\">A</span></span><span class=\"vlist\"><span style=\"top:-0.363em;margin-right:0.05em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"reset-textstyle scriptstyle uncramped\"><span class=\"mord scriptstyle uncramped\"><span class=\"mord\">−</span><span class=\"mord mathrm\">1</span></span></span></span><span class=\"baseline-fix\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span>​</span></span></span></span></span></span>的还原回去，就会得到向量<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mover accent=\"true\"><mrow><mi>x</mi></mrow><mo>⃗</mo></mover></mrow><annotation encoding=\"application/x-tex\">\\vec{x}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"strut\" style=\"height:0.71444em;\"></span><span class=\"strut bottom\" style=\"height:0.71444em;vertical-align:0em;\"></span><span class=\"base textstyle uncramped\"><span class=\"mord accent\"><span class=\"vlist\"><span style=\"top:0em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"mord textstyle cramped\"><span class=\"mord mathit\">x</span></span></span><span style=\"top:0em;margin-left:0.05556em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"accent-body accent-vec\"><span>⃗</span></span></span><span class=\"baseline-fix\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span>​</span></span></span></span></span></span>。$$\\vec{x} = {A}^{-1} \\cdot \\vec{v}$$</p>\n<p><img src=\"http://otkwwi4x8.bkt.clouddn.com/15107489431518.jpg\" alt=\"-w500\"></p>\n<ul>\n<li>\n<p><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>d</mi><mi>e</mi><mi>t</mi><mo>(</mo><mi>A</mi><mo>)</mo></mrow><annotation encoding=\"application/x-tex\">det(A)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"strut\" style=\"height:0.75em;\"></span><span class=\"strut bottom\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"base textstyle uncramped\"><span class=\"mord mathit\">d</span><span class=\"mord mathit\">e</span><span class=\"mord mathit\">t</span><span class=\"mopen\">(</span><span class=\"mord mathit\">A</span><span class=\"mclose\">)</span></span></span></span>不等于0，意味着空间没有被压缩到丢维的程度。那么不管<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"strut\" style=\"height:0.68333em;\"></span><span class=\"strut bottom\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"base textstyle uncramped\"><span class=\"mord mathit\">A</span></span></span></span>有多大能耐，制造出多邪乎的变换，都可以还原，也就是说<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"strut\" style=\"height:0.68333em;\"></span><span class=\"strut bottom\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"base textstyle uncramped\"><span class=\"mord mathit\">A</span></span></span></span>可逆。</p>\n<pre><code>  比如你把二维空间给变换成了一条直线，那还怎么可能恢复成平面。\n</code></pre>\n</li>\n</ul>\n<h2 id=\"秩\"><a class=\"markdownIt-Anchor\" href=\"#秩\"></a> 秩</h2>\n<p>秩就是变换后的空间维数。<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"strut\" style=\"height:0.43056em;\"></span><span class=\"strut bottom\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"base textstyle uncramped\"><span class=\"mord mathit\">n</span></span></span></span>维矩阵变换后还是<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"strut\" style=\"height:0.43056em;\"></span><span class=\"strut bottom\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"base textstyle uncramped\"><span class=\"mord mathit\">n</span></span></span></span>维空间叫满秩。</p>\n<pre><code>经过线性变换后的空间，如果是一条一维的直接，秩就是1。二维平面秩就是2。\n</code></pre>\n<h2 id=\"列空间\"><a class=\"markdownIt-Anchor\" href=\"#列空间\"></a> 列空间</h2>\n<p>列(基)向量的线性组合组成的空间。</p>\n<h2 id=\"零空间\"><a class=\"markdownIt-Anchor\" href=\"#零空间\"></a> 零空间</h2>\n<p>线性变换后，被压缩到原点的那部分，叫零空间。</p>\n<pre><code>一个直线被线性压缩变换后只有原点保持不变；\n一个平面被线性变换压缩成直线，原平面中有一条直线的空间就被压缩到了原点。\n那么这条被压缩到原点的直线就是零空间。\n</code></pre>\n<p>如下式可以看出，所有可以被<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"strut\" style=\"height:0.68333em;\"></span><span class=\"strut bottom\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"base textstyle uncramped\"><span class=\"mord mathit\">A</span></span></span></span>变换压缩到原点的向量<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mover accent=\"true\"><mrow><mi>x</mi></mrow><mo>⃗</mo></mover></mrow><annotation encoding=\"application/x-tex\">\\vec{x}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"strut\" style=\"height:0.71444em;\"></span><span class=\"strut bottom\" style=\"height:0.71444em;vertical-align:0em;\"></span><span class=\"base textstyle uncramped\"><span class=\"mord accent\"><span class=\"vlist\"><span style=\"top:0em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"mord textstyle cramped\"><span class=\"mord mathit\">x</span></span></span><span style=\"top:0em;margin-left:0.05556em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"accent-body accent-vec\"><span>⃗</span></span></span><span class=\"baseline-fix\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span>​</span></span></span></span></span></span>集合组成了零空间。也就是方程组可能是解的集合。下式中如果向量<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mover accent=\"true\"><mrow><mi>x</mi></mrow><mo>⃗</mo></mover></mrow><annotation encoding=\"application/x-tex\">\\vec{x}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"strut\" style=\"height:0.71444em;\"></span><span class=\"strut bottom\" style=\"height:0.71444em;vertical-align:0em;\"></span><span class=\"base textstyle uncramped\"><span class=\"mord accent\"><span class=\"vlist\"><span style=\"top:0em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"mord textstyle cramped\"><span class=\"mord mathit\">x</span></span></span><span style=\"top:0em;margin-left:0.05556em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"accent-body accent-vec\"><span>⃗</span></span></span><span class=\"baseline-fix\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span>​</span></span></span></span></span></span>不在零空间内，也一定无解。</p>\n<p><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>A</mi><mo>⋅</mo><mover accent=\"true\"><mrow><mi>x</mi></mrow><mo>⃗</mo></mover><mo>=</mo><mrow><mo fence=\"true\">[</mo><mtable><mtr><mtd><mrow><mn>0</mn></mrow></mtd></mtr><mtr><mtd><mrow><mn>0</mn></mrow></mtd></mtr><mtr><mtd><mrow><mi mathvariant=\"normal\">.</mi></mrow></mtd></mtr><mtr><mtd><mrow><mi mathvariant=\"normal\">.</mi></mrow></mtd></mtr><mtr><mtd><mrow><mi mathvariant=\"normal\">.</mi></mrow></mtd></mtr></mtable><mo fence=\"true\">]</mo></mrow></mrow><annotation encoding=\"application/x-tex\">A \\cdot \\vec{x} = \\left[\n    \\begin{array}{}\n      0\\\\\n      0\\\\\n      .\\\\\n      .\\\\\n      .\n    \\end{array}\n\\right]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"strut\" style=\"height:3.2540000000000004em;\"></span><span class=\"strut bottom\" style=\"height:6.00404em;vertical-align:-2.75004em;\"></span><span class=\"base displaystyle textstyle uncramped\"><span class=\"mord mathit\">A</span><span class=\"mbin\">⋅</span><span class=\"mord accent\"><span class=\"vlist\"><span style=\"top:0em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"mord displaystyle textstyle cramped\"><span class=\"mord mathit\">x</span></span></span><span style=\"top:0em;margin-left:0.05556em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"accent-body accent-vec\"><span>⃗</span></span></span><span class=\"baseline-fix\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span>​</span></span></span><span class=\"mrel\">=</span><span class=\"minner displaystyle textstyle uncramped\"><span class=\"style-wrap reset-textstyle textstyle uncramped\"><span class=\"delimsizing mult\"><span class=\"vlist\"><span style=\"top:2.1050199999999997em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"delimsizinginner delim-size4\"><span>⎣</span></span></span><span style=\"top:0.9500199999999999em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"delimsizinginner delim-size4\"><span>⎢</span></span></span><span style=\"top:0.3490199999999999em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"delimsizinginner delim-size4\"><span>⎢</span></span></span><span style=\"top:-0.2519800000000001em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"delimsizinginner delim-size4\"><span>⎢</span></span></span><span style=\"top:-0.8529800000000001em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"delimsizinginner delim-size4\"><span>⎢</span></span></span><span style=\"top:-2.099em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"delimsizinginner delim-size4\"><span>⎡</span></span></span><span class=\"baseline-fix\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span>​</span></span></span></span><span class=\"mord\"><span class=\"mtable\"><span class=\"arraycolsep\" style=\"width:0.5em;\"></span><span class=\"col-align-c\"><span class=\"vlist\"><span style=\"top:-2.41em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"mord displaystyle textstyle uncramped\"><span class=\"mord mathrm\">0</span></span></span><span style=\"top:-1.2100000000000002em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"mord displaystyle textstyle uncramped\"><span class=\"mord mathrm\">0</span></span></span><span style=\"top:-0.009999999999999953em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"mord displaystyle textstyle uncramped\"><span class=\"mord mathrm\">.</span></span></span><span style=\"top:1.1900000000000002em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"mord displaystyle textstyle uncramped\"><span class=\"mord mathrm\">.</span></span></span><span style=\"top:2.3900000000000006em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"mord displaystyle textstyle uncramped\"><span class=\"mord mathrm\">.</span></span></span><span class=\"baseline-fix\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span>​</span></span></span><span class=\"arraycolsep\" style=\"width:0.5em;\"></span></span></span><span class=\"style-wrap reset-textstyle textstyle uncramped\"><span class=\"delimsizing mult\"><span class=\"vlist\"><span style=\"top:2.1050199999999997em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"delimsizinginner delim-size4\"><span>⎦</span></span></span><span style=\"top:0.9500199999999999em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"delimsizinginner delim-size4\"><span>⎥</span></span></span><span style=\"top:0.3490199999999999em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"delimsizinginner delim-size4\"><span>⎥</span></span></span><span style=\"top:-0.2519800000000001em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"delimsizinginner delim-size4\"><span>⎥</span></span></span><span style=\"top:-0.8529800000000001em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"delimsizinginner delim-size4\"><span>⎥</span></span></span><span style=\"top:-2.099em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"delimsizinginner delim-size4\"><span>⎤</span></span></span><span class=\"baseline-fix\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span>​</span></span></span></span></span></span></span></span></span></p>\n<h2 id=\"点积\"><a class=\"markdownIt-Anchor\" href=\"#点积\"></a> 点积</h2>\n<p>两个向量<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mover accent=\"true\"><mrow><mi>v</mi></mrow><mo>⃗</mo></mover><mo separator=\"true\">,</mo><mover accent=\"true\"><mrow><mi>j</mi></mrow><mo>⃗</mo></mover></mrow><annotation encoding=\"application/x-tex\">\\vec{v},\\vec{j}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"strut\" style=\"height:0.94296em;\"></span><span class=\"strut bottom\" style=\"height:1.1374em;vertical-align:-0.19444em;\"></span><span class=\"base textstyle uncramped\"><span class=\"mord accent\"><span class=\"vlist\"><span style=\"top:0em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"mord textstyle cramped\"><span class=\"mord mathit\" style=\"margin-right:0.03588em;\">v</span></span></span><span style=\"top:0em;margin-left:0.05556em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"accent-body accent-vec\"><span>⃗</span></span></span><span class=\"baseline-fix\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span>​</span></span></span><span class=\"mpunct\">,</span><span class=\"mord accent\"><span class=\"vlist\"><span style=\"top:0em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"mord textstyle cramped\"><span class=\"mord mathit\" style=\"margin-right:0.05724em;\">j</span></span></span><span style=\"top:-0.2285200000000001em;margin-left:0em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"accent-body accent-vec\"><span>⃗</span></span></span><span class=\"baseline-fix\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span>​</span></span></span></span></span></span>点积，几何意义就是<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mover accent=\"true\"><mrow><mi>v</mi></mrow><mo>⃗</mo></mover></mrow><annotation encoding=\"application/x-tex\">\\vec{v}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"strut\" style=\"height:0.71444em;\"></span><span class=\"strut bottom\" style=\"height:0.71444em;vertical-align:0em;\"></span><span class=\"base textstyle uncramped\"><span class=\"mord accent\"><span class=\"vlist\"><span style=\"top:0em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"mord textstyle cramped\"><span class=\"mord mathit\" style=\"margin-right:0.03588em;\">v</span></span></span><span style=\"top:0em;margin-left:0.05556em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"accent-body accent-vec\"><span>⃗</span></span></span><span class=\"baseline-fix\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span>​</span></span></span></span></span></span>在<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mover accent=\"true\"><mrow><mi>j</mi></mrow><mo>⃗</mo></mover></mrow><annotation encoding=\"application/x-tex\">\\vec{j}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"strut\" style=\"height:0.94296em;\"></span><span class=\"strut bottom\" style=\"height:1.1374em;vertical-align:-0.19444em;\"></span><span class=\"base textstyle uncramped\"><span class=\"mord accent\"><span class=\"vlist\"><span style=\"top:0em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"mord textstyle cramped\"><span class=\"mord mathit\" style=\"margin-right:0.05724em;\">j</span></span></span><span style=\"top:-0.2285200000000001em;margin-left:0em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"accent-body accent-vec\"><span>⃗</span></span></span><span class=\"baseline-fix\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span>​</span></span></span></span></span></span>的投影长度，乘以<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mover accent=\"true\"><mrow><mi>j</mi></mrow><mo>⃗</mo></mover></mrow><annotation encoding=\"application/x-tex\">\\vec{j}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"strut\" style=\"height:0.94296em;\"></span><span class=\"strut bottom\" style=\"height:1.1374em;vertical-align:-0.19444em;\"></span><span class=\"base textstyle uncramped\"><span class=\"mord accent\"><span class=\"vlist\"><span style=\"top:0em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"mord textstyle cramped\"><span class=\"mord mathit\" style=\"margin-right:0.05724em;\">j</span></span></span><span style=\"top:-0.2285200000000001em;margin-left:0em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"accent-body accent-vec\"><span>⃗</span></span></span><span class=\"baseline-fix\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span>​</span></span></span></span></span></span>的长度。反之也成立，这是一个对称的。</p>\n<h2 id=\"叉积\"><a class=\"markdownIt-Anchor\" href=\"#叉积\"></a> 叉积</h2>\n<ul>\n<li>两个向量围成的平行四边形的面积，有正有负。</li>\n<li>计算方式相对简单，将两个向量看成是由单位矩阵变换而来的两个基，行列式的值就是该面积。</li>\n<li>在求出该面积后，也就得出来叉积向量。它和上述的平行四边形平面垂直，长度就是面积值。如下图红色向量（需要用到右手定则）。</li>\n</ul>\n<p><img src=\"http://otkwwi4x8.bkt.clouddn.com/15108854308734.jpg\" alt=\"-w240\"></p>\n<p><img src=\"http://otkwwi4x8.bkt.clouddn.com/15108855479844.jpg\" alt=\"-w240\"></p>\n<h2 id=\"基变换\"><a class=\"markdownIt-Anchor\" href=\"#基变换\"></a> 基变换</h2>\n<p><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msup><mrow><mi>A</mi></mrow><mrow><mo>−</mo><mn>1</mn></mrow></msup><mo>⋅</mo><mi>M</mi><mo>⋅</mo><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">{A}^{-1} \\cdot M \\cdot A\n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"strut\" style=\"height:0.864108em;\"></span><span class=\"strut bottom\" style=\"height:0.864108em;vertical-align:0em;\"></span><span class=\"base displaystyle textstyle uncramped\"><span class=\"mord\"><span class=\"mord displaystyle textstyle uncramped\"><span class=\"mord mathit\">A</span></span><span class=\"vlist\"><span style=\"top:-0.41300000000000003em;margin-right:0.05em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"reset-textstyle scriptstyle uncramped\"><span class=\"mord scriptstyle uncramped\"><span class=\"mord\">−</span><span class=\"mord mathrm\">1</span></span></span></span><span class=\"baseline-fix\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span>​</span></span></span><span class=\"mbin\">⋅</span><span class=\"mord mathit\" style=\"margin-right:0.10903em;\">M</span><span class=\"mbin\">⋅</span><span class=\"mord mathit\">A</span></span></span></span></span></p>\n<h2 id=\"特征\"><a class=\"markdownIt-Anchor\" href=\"#特征\"></a> 特征</h2>\n<p>在经历矩阵线性变换后，该向量还保持方向不变，该向量就是特征向量，且长度是放大比例就是特征值。零空间和特征有紧密联系。</p>\n<p><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>A</mi><mover accent=\"true\"><mrow><mi>v</mi></mrow><mo>⃗</mo></mover><mo>=</mo><mi>λ</mi><mover accent=\"true\"><mrow><mi>v</mi></mrow><mo>⃗</mo></mover></mrow><annotation encoding=\"application/x-tex\">A \\vec{v} =  \\lambda \\vec{v}\n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"strut\" style=\"height:0.71444em;\"></span><span class=\"strut bottom\" style=\"height:0.71444em;vertical-align:0em;\"></span><span class=\"base displaystyle textstyle uncramped\"><span class=\"mord mathit\">A</span><span class=\"mord accent\"><span class=\"vlist\"><span style=\"top:0em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"mord displaystyle textstyle cramped\"><span class=\"mord mathit\" style=\"margin-right:0.03588em;\">v</span></span></span><span style=\"top:0em;margin-left:0.05556em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"accent-body accent-vec\"><span>⃗</span></span></span><span class=\"baseline-fix\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span>​</span></span></span><span class=\"mrel\">=</span><span class=\"mord mathit\">λ</span><span class=\"mord accent\"><span class=\"vlist\"><span style=\"top:0em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"mord displaystyle textstyle cramped\"><span class=\"mord mathit\" style=\"margin-right:0.03588em;\">v</span></span></span><span style=\"top:0em;margin-left:0.05556em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"accent-body accent-vec\"><span>⃗</span></span></span><span class=\"baseline-fix\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span>​</span></span></span></span></span></span></span></p>\n<p>粉色轴是长度为1的特征向量，那么整个正方体可以在该方向旋转而不变形。<br>\n<img src=\"http://otkwwi4x8.bkt.clouddn.com/15114215605944.jpg\" alt=\"-w300\"></p>\n<p>如果<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>λ</mi></mrow><annotation encoding=\"application/x-tex\">\\lambda</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"strut\" style=\"height:0.69444em;\"></span><span class=\"strut bottom\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"base textstyle uncramped\"><span class=\"mord mathit\">λ</span></span></span></span>大于1了，也就意味着在所有维度都放大<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>λ</mi></mrow><annotation encoding=\"application/x-tex\">\\lambda</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"strut\" style=\"height:0.69444em;\"></span><span class=\"strut bottom\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"base textstyle uncramped\"><span class=\"mord mathit\">λ</span></span></span></span>倍，否则就被拉歪了。各维度都牵扯相同的比例也不会“倾倒”。就像下面的矩阵一样，它们正是一组由单位矩阵缩放<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>λ</mi></mrow><annotation encoding=\"application/x-tex\">\\lambda</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"strut\" style=\"height:0.69444em;\"></span><span class=\"strut bottom\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"base textstyle uncramped\"><span class=\"mord mathit\">λ</span></span></span></span>倍得到的基。</p>\n<p><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mrow><mo fence=\"true\">[</mo><mtable><mtr><mtd><mrow><mn>1</mn></mrow></mtd><mtd><mrow><mn>0</mn></mrow></mtd></mtr><mtr><mtd><mrow><mn>0</mn></mrow></mtd><mtd><mrow><mn>1</mn></mrow></mtd></mtr></mtable><mo fence=\"true\">]</mo></mrow></mrow><annotation encoding=\"application/x-tex\">\\left[\n    \\begin{array}{}\n      1&amp;0\\\\\n      0&amp; 1\n    \\end{array}\n\\right]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"strut\" style=\"height:1.45em;\"></span><span class=\"strut bottom\" style=\"height:2.40003em;vertical-align:-0.95003em;\"></span><span class=\"base displaystyle textstyle uncramped\"><span class=\"minner displaystyle textstyle uncramped\"><span class=\"style-wrap reset-textstyle textstyle uncramped\" style=\"top:0em;\"><span class=\"delimsizing size3\">[</span></span><span class=\"mord\"><span class=\"mtable\"><span class=\"arraycolsep\" style=\"width:0.5em;\"></span><span class=\"col-align-c\"><span class=\"vlist\"><span style=\"top:-0.6099999999999999em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"mord displaystyle textstyle uncramped\"><span class=\"mord mathrm\">1</span></span></span><span style=\"top:0.5900000000000003em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"mord displaystyle textstyle uncramped\"><span class=\"mord mathrm\">0</span></span></span><span class=\"baseline-fix\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span>​</span></span></span><span class=\"arraycolsep\" style=\"width:0.5em;\"></span><span class=\"arraycolsep\" style=\"width:0.5em;\"></span><span class=\"col-align-c\"><span class=\"vlist\"><span style=\"top:-0.6099999999999999em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"mord displaystyle textstyle uncramped\"><span class=\"mord mathrm\">0</span></span></span><span style=\"top:0.5900000000000003em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"mord displaystyle textstyle uncramped\"><span class=\"mord mathrm\">1</span></span></span><span class=\"baseline-fix\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span>​</span></span></span><span class=\"arraycolsep\" style=\"width:0.5em;\"></span></span></span><span class=\"style-wrap reset-textstyle textstyle uncramped\" style=\"top:0em;\"><span class=\"delimsizing size3\">]</span></span></span></span></span></span></span></p>\n<p><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mrow><mo fence=\"true\">[</mo><mtable><mtr><mtd><mrow><mi>λ</mi></mrow></mtd><mtd><mrow><mn>0</mn></mrow></mtd></mtr><mtr><mtd><mrow><mn>0</mn></mrow></mtd><mtd><mrow><mi>λ</mi></mrow></mtd></mtr></mtable><mo fence=\"true\">]</mo></mrow></mrow><annotation encoding=\"application/x-tex\">\\left[\n    \\begin{array}{}\n      \\lambda&amp;0\\\\\n      0&amp;\\lambda\n    \\end{array}\n\\right]\n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"strut\" style=\"height:1.45em;\"></span><span class=\"strut bottom\" style=\"height:2.40003em;vertical-align:-0.95003em;\"></span><span class=\"base displaystyle textstyle uncramped\"><span class=\"minner displaystyle textstyle uncramped\"><span class=\"style-wrap reset-textstyle textstyle uncramped\" style=\"top:0em;\"><span class=\"delimsizing size3\">[</span></span><span class=\"mord\"><span class=\"mtable\"><span class=\"arraycolsep\" style=\"width:0.5em;\"></span><span class=\"col-align-c\"><span class=\"vlist\"><span style=\"top:-0.6099999999999999em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"mord displaystyle textstyle uncramped\"><span class=\"mord mathit\">λ</span></span></span><span style=\"top:0.5900000000000003em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"mord displaystyle textstyle uncramped\"><span class=\"mord mathrm\">0</span></span></span><span class=\"baseline-fix\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span>​</span></span></span><span class=\"arraycolsep\" style=\"width:0.5em;\"></span><span class=\"arraycolsep\" style=\"width:0.5em;\"></span><span class=\"col-align-c\"><span class=\"vlist\"><span style=\"top:-0.6099999999999999em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"mord displaystyle textstyle uncramped\"><span class=\"mord mathrm\">0</span></span></span><span style=\"top:0.5900000000000003em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"mord displaystyle textstyle uncramped\"><span class=\"mord mathit\">λ</span></span></span><span class=\"baseline-fix\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span>​</span></span></span><span class=\"arraycolsep\" style=\"width:0.5em;\"></span></span></span><span class=\"style-wrap reset-textstyle textstyle uncramped\" style=\"top:0em;\"><span class=\"delimsizing size3\">]</span></span></span></span></span></span></span></p>\n<h2 id=\"抽象向量空间\"><a class=\"markdownIt-Anchor\" href=\"#抽象向量空间\"></a> 抽象向量空间</h2>\n<p>世间万物，符合线性特征者，皆可矩阵化运算。</p>\n<p><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>L</mi><mo>(</mo><mover accent=\"true\"><mrow><mi>v</mi></mrow><mo>⃗</mo></mover><mo>+</mo><mover accent=\"true\"><mrow><mi>w</mi></mrow><mo>⃗</mo></mover><mo>)</mo><mo>=</mo><mi>L</mi><mo>(</mo><mover accent=\"true\"><mrow><mi>v</mi></mrow><mo>⃗</mo></mover><mo>)</mo><mo>+</mo><mi>L</mi><mo>(</mo><mover accent=\"true\"><mrow><mi>w</mi></mrow><mo>⃗</mo></mover><mo>)</mo></mrow><annotation encoding=\"application/x-tex\">L(\\vec{v} + \\vec{w}) = L(\\vec{v}) + L(\\vec{w}) \n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"strut\" style=\"height:0.75em;\"></span><span class=\"strut bottom\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"base displaystyle textstyle uncramped\"><span class=\"mord mathit\">L</span><span class=\"mopen\">(</span><span class=\"mord accent\"><span class=\"vlist\"><span style=\"top:0em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"mord displaystyle textstyle cramped\"><span class=\"mord mathit\" style=\"margin-right:0.03588em;\">v</span></span></span><span style=\"top:0em;margin-left:0.05556em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"accent-body accent-vec\"><span>⃗</span></span></span><span class=\"baseline-fix\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span>​</span></span></span><span class=\"mbin\">+</span><span class=\"mord accent\"><span class=\"vlist\"><span style=\"top:0em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"mord displaystyle textstyle cramped\"><span class=\"mord mathit\" style=\"margin-right:0.02691em;\">w</span></span></span><span style=\"top:0em;margin-left:0.16668em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"accent-body accent-vec\"><span>⃗</span></span></span><span class=\"baseline-fix\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span>​</span></span></span><span class=\"mclose\">)</span><span class=\"mrel\">=</span><span class=\"mord mathit\">L</span><span class=\"mopen\">(</span><span class=\"mord accent\"><span class=\"vlist\"><span style=\"top:0em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"mord displaystyle textstyle cramped\"><span class=\"mord mathit\" style=\"margin-right:0.03588em;\">v</span></span></span><span style=\"top:0em;margin-left:0.05556em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"accent-body accent-vec\"><span>⃗</span></span></span><span class=\"baseline-fix\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span>​</span></span></span><span class=\"mclose\">)</span><span class=\"mbin\">+</span><span class=\"mord mathit\">L</span><span class=\"mopen\">(</span><span class=\"mord accent\"><span class=\"vlist\"><span style=\"top:0em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"mord displaystyle textstyle cramped\"><span class=\"mord mathit\" style=\"margin-right:0.02691em;\">w</span></span></span><span style=\"top:0em;margin-left:0.16668em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"accent-body accent-vec\"><span>⃗</span></span></span><span class=\"baseline-fix\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span>​</span></span></span><span class=\"mclose\">)</span></span></span></span></span></p>\n<p><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>L</mi><mo>(</mo><mi>c</mi><mover accent=\"true\"><mrow><mi>v</mi></mrow><mo>⃗</mo></mover><mo>)</mo><mo>=</mo><mi>c</mi><mi>L</mi><mo>(</mo><mover accent=\"true\"><mrow><mi>v</mi></mrow><mo>⃗</mo></mover><mo>)</mo></mrow><annotation encoding=\"application/x-tex\">L(c\\vec{v}) = cL(\\vec{v})\n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"strut\" style=\"height:0.75em;\"></span><span class=\"strut bottom\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"base displaystyle textstyle uncramped\"><span class=\"mord mathit\">L</span><span class=\"mopen\">(</span><span class=\"mord mathit\">c</span><span class=\"mord accent\"><span class=\"vlist\"><span style=\"top:0em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"mord displaystyle textstyle cramped\"><span class=\"mord mathit\" style=\"margin-right:0.03588em;\">v</span></span></span><span style=\"top:0em;margin-left:0.05556em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"accent-body accent-vec\"><span>⃗</span></span></span><span class=\"baseline-fix\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span>​</span></span></span><span class=\"mclose\">)</span><span class=\"mrel\">=</span><span class=\"mord mathit\">c</span><span class=\"mord mathit\">L</span><span class=\"mopen\">(</span><span class=\"mord accent\"><span class=\"vlist\"><span style=\"top:0em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"mord displaystyle textstyle cramped\"><span class=\"mord mathit\" style=\"margin-right:0.03588em;\">v</span></span></span><span style=\"top:0em;margin-left:0.05556em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"accent-body accent-vec\"><span>⃗</span></span></span><span class=\"baseline-fix\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span>​</span></span></span><span class=\"mclose\">)</span></span></span></span></span></p>\n<ul>\n<li>上一式表示一起整和分开整，一个效果</li>\n<li>上二式表示变一个大向量和变一个小向量再倍乘一个效果</li>\n</ul>\n<p>符合以上两点就是线性的。导数就是这样的</p>\n<p><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mfrac><mrow><mi>d</mi></mrow><mrow><mi>d</mi><mi>x</mi></mrow></mfrac><mo>(</mo><msup><mi>x</mi><mn>3</mn></msup><mo>+</mo><msup><mi>x</mi><mn>2</mn></msup><mo>)</mo><mo>=</mo><mfrac><mrow><mi>d</mi></mrow><mrow><mi>d</mi><mi>x</mi></mrow></mfrac><mo>(</mo><msup><mi>x</mi><mn>3</mn></msup><mo>)</mo><mo>+</mo><mfrac><mrow><mi>d</mi></mrow><mrow><mi>d</mi><mi>x</mi></mrow></mfrac><mo>(</mo><msup><mi>x</mi><mn>2</mn></msup><mo>)</mo></mrow><annotation encoding=\"application/x-tex\">\\frac{d}{dx}(x^3+x^2) = \\frac{d}{dx}(x^3)+\\frac{d}{dx}(x^2)\n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"strut\" style=\"height:1.37144em;\"></span><span class=\"strut bottom\" style=\"height:2.05744em;vertical-align:-0.686em;\"></span><span class=\"base displaystyle textstyle uncramped\"><span class=\"mord reset-textstyle displaystyle textstyle uncramped\"><span class=\"sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist\"><span style=\"top:0.686em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"reset-textstyle textstyle cramped\"><span class=\"mord textstyle cramped\"><span class=\"mord mathit\">d</span><span class=\"mord mathit\">x</span></span></span></span><span style=\"top:-0.22999999999999998em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"reset-textstyle textstyle uncramped frac-line\"></span></span><span style=\"top:-0.677em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"reset-textstyle textstyle uncramped\"><span class=\"mord textstyle uncramped\"><span class=\"mord mathit\">d</span></span></span></span><span class=\"baseline-fix\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span>​</span></span></span><span class=\"sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter\"></span></span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathit\">x</span><span class=\"vlist\"><span style=\"top:-0.413em;margin-right:0.05em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"reset-textstyle scriptstyle uncramped\"><span class=\"mord mathrm\">3</span></span></span><span class=\"baseline-fix\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span>​</span></span></span><span class=\"mbin\">+</span><span class=\"mord\"><span class=\"mord mathit\">x</span><span class=\"vlist\"><span style=\"top:-0.413em;margin-right:0.05em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"reset-textstyle scriptstyle uncramped\"><span class=\"mord mathrm\">2</span></span></span><span class=\"baseline-fix\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span>​</span></span></span><span class=\"mclose\">)</span><span class=\"mrel\">=</span><span class=\"mord reset-textstyle displaystyle textstyle uncramped\"><span class=\"sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist\"><span style=\"top:0.686em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"reset-textstyle textstyle cramped\"><span class=\"mord textstyle cramped\"><span class=\"mord mathit\">d</span><span class=\"mord mathit\">x</span></span></span></span><span style=\"top:-0.22999999999999998em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"reset-textstyle textstyle uncramped frac-line\"></span></span><span style=\"top:-0.677em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"reset-textstyle textstyle uncramped\"><span class=\"mord textstyle uncramped\"><span class=\"mord mathit\">d</span></span></span></span><span class=\"baseline-fix\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span>​</span></span></span><span class=\"sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter\"></span></span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathit\">x</span><span class=\"vlist\"><span style=\"top:-0.413em;margin-right:0.05em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"reset-textstyle scriptstyle uncramped\"><span class=\"mord mathrm\">3</span></span></span><span class=\"baseline-fix\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span>​</span></span></span><span class=\"mclose\">)</span><span class=\"mbin\">+</span><span class=\"mord reset-textstyle displaystyle textstyle uncramped\"><span class=\"sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist\"><span style=\"top:0.686em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"reset-textstyle textstyle cramped\"><span class=\"mord textstyle cramped\"><span class=\"mord mathit\">d</span><span class=\"mord mathit\">x</span></span></span></span><span style=\"top:-0.22999999999999998em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"reset-textstyle textstyle uncramped frac-line\"></span></span><span style=\"top:-0.677em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"reset-textstyle textstyle uncramped\"><span class=\"mord textstyle uncramped\"><span class=\"mord mathit\">d</span></span></span></span><span class=\"baseline-fix\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span>​</span></span></span><span class=\"sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter\"></span></span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathit\">x</span><span class=\"vlist\"><span style=\"top:-0.413em;margin-right:0.05em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"reset-textstyle scriptstyle uncramped\"><span class=\"mord mathrm\">2</span></span></span><span class=\"baseline-fix\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span>​</span></span></span><span class=\"mclose\">)</span></span></span></span></span></p>\n<p><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mfrac><mrow><mi>d</mi></mrow><mrow><mi>d</mi><mi>x</mi></mrow></mfrac><mo>(</mo><mn>4</mn><msup><mi>x</mi><mn>3</mn></msup><mo>)</mo><mo>=</mo><mn>4</mn><mfrac><mrow><mi>d</mi></mrow><mrow><mi>d</mi><mi>x</mi></mrow></mfrac><mo>(</mo><msup><mi>x</mi><mn>3</mn></msup><mo>)</mo></mrow><annotation encoding=\"application/x-tex\">\\frac{d}{dx}(4x^3) = 4\\frac{d}{dx}(x^3)\n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"strut\" style=\"height:1.37144em;\"></span><span class=\"strut bottom\" style=\"height:2.05744em;vertical-align:-0.686em;\"></span><span class=\"base displaystyle textstyle uncramped\"><span class=\"mord reset-textstyle displaystyle textstyle uncramped\"><span class=\"sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist\"><span style=\"top:0.686em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"reset-textstyle textstyle cramped\"><span class=\"mord textstyle cramped\"><span class=\"mord mathit\">d</span><span class=\"mord mathit\">x</span></span></span></span><span style=\"top:-0.22999999999999998em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"reset-textstyle textstyle uncramped frac-line\"></span></span><span style=\"top:-0.677em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"reset-textstyle textstyle uncramped\"><span class=\"mord textstyle uncramped\"><span class=\"mord mathit\">d</span></span></span></span><span class=\"baseline-fix\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span>​</span></span></span><span class=\"sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter\"></span></span><span class=\"mopen\">(</span><span class=\"mord mathrm\">4</span><span class=\"mord\"><span class=\"mord mathit\">x</span><span class=\"vlist\"><span style=\"top:-0.413em;margin-right:0.05em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"reset-textstyle scriptstyle uncramped\"><span class=\"mord mathrm\">3</span></span></span><span class=\"baseline-fix\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span>​</span></span></span><span class=\"mclose\">)</span><span class=\"mrel\">=</span><span class=\"mord mathrm\">4</span><span class=\"mord reset-textstyle displaystyle textstyle uncramped\"><span class=\"sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist\"><span style=\"top:0.686em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"reset-textstyle textstyle cramped\"><span class=\"mord textstyle cramped\"><span class=\"mord mathit\">d</span><span class=\"mord mathit\">x</span></span></span></span><span style=\"top:-0.22999999999999998em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"reset-textstyle textstyle uncramped frac-line\"></span></span><span style=\"top:-0.677em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"reset-textstyle textstyle uncramped\"><span class=\"mord textstyle uncramped\"><span class=\"mord mathit\">d</span></span></span></span><span class=\"baseline-fix\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span>​</span></span></span><span class=\"sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter\"></span></span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathit\">x</span><span class=\"vlist\"><span style=\"top:-0.413em;margin-right:0.05em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"reset-textstyle scriptstyle uncramped\"><span class=\"mord mathrm\">3</span></span></span><span class=\"baseline-fix\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span>​</span></span></span><span class=\"mclose\">)</span></span></span></span></span></p>\n<p>下面这张图表示了用矩阵来求导数的过程，箭头为标准基，它由<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msup><mi>x</mi><mn>0</mn></msup></mrow><annotation encoding=\"application/x-tex\">x^0</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"strut\" style=\"height:0.8141079999999999em;\"></span><span class=\"strut bottom\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"base textstyle uncramped\"><span class=\"mord\"><span class=\"mord mathit\">x</span><span class=\"vlist\"><span style=\"top:-0.363em;margin-right:0.05em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"reset-textstyle scriptstyle uncramped\"><span class=\"mord mathrm\">0</span></span></span><span class=\"baseline-fix\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span>​</span></span></span></span></span></span>,<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msup><mi>x</mi><mn>1</mn></msup></mrow><annotation encoding=\"application/x-tex\">x^1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"strut\" style=\"height:0.8141079999999999em;\"></span><span class=\"strut bottom\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"base textstyle uncramped\"><span class=\"mord\"><span class=\"mord mathit\">x</span><span class=\"vlist\"><span style=\"top:-0.363em;margin-right:0.05em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"reset-textstyle scriptstyle uncramped\"><span class=\"mord mathrm\">1</span></span></span><span class=\"baseline-fix\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span>​</span></span></span></span></span></span>,<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msup><mi>x</mi><mn>2</mn></msup></mrow><annotation encoding=\"application/x-tex\">x^2</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"strut\" style=\"height:0.8141079999999999em;\"></span><span class=\"strut bottom\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"base textstyle uncramped\"><span class=\"mord\"><span class=\"mord mathit\">x</span><span class=\"vlist\"><span style=\"top:-0.363em;margin-right:0.05em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"reset-textstyle scriptstyle uncramped\"><span class=\"mord mathrm\">2</span></span></span><span class=\"baseline-fix\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span>​</span></span></span></span></span></span>…<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msup><mi>x</mi><mi>n</mi></msup></mrow><annotation encoding=\"application/x-tex\">x^n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"strut\" style=\"height:0.664392em;\"></span><span class=\"strut bottom\" style=\"height:0.664392em;vertical-align:0em;\"></span><span class=\"base textstyle uncramped\"><span class=\"mord\"><span class=\"mord mathit\">x</span><span class=\"vlist\"><span style=\"top:-0.363em;margin-right:0.05em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"reset-textstyle scriptstyle uncramped\"><span class=\"mord mathit\">n</span></span></span><span class=\"baseline-fix\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span>​</span></span></span></span></span></span>一组基函数分别求导得出的一组导数基。<br>\n<img src=\"http://otkwwi4x8.bkt.clouddn.com/15114339843705.jpg\" alt=\"-w500\"></p>\n"}],"PostAsset":[],"PostCategory":[],"PostTag":[{"post_id":"cjahvvnx40007pv4njiwqtv30","tag_id":"cjahvvnx10004pv4na7nsnjtz","_id":"cjahvvnx8000apv4na166rfy9"},{"post_id":"cjahvvnwv0001pv4nzwazr5hd","tag_id":"cjahvvnx10004pv4na7nsnjtz","_id":"cjahvvnxa000cpv4nm4kh75rh"},{"post_id":"cjahvvnx50008pv4npa2t8cvx","tag_id":"cjahvvnx10004pv4na7nsnjtz","_id":"cjahvvnxe000fpv4nd68khnum"},{"post_id":"cjahvvnx8000bpv4n8grop8gy","tag_id":"cjahvvnx10004pv4na7nsnjtz","_id":"cjahvvnxi000hpv4n8fw2sp01"},{"post_id":"cjahvvnwz0003pv4nfkrvjatd","tag_id":"cjahvvnx10004pv4na7nsnjtz","_id":"cjahvvnxn000jpv4ncmw8bbgs"},{"post_id":"cjahvvnxa000dpv4nohkiyqvx","tag_id":"cjahvvnx10004pv4na7nsnjtz","_id":"cjahvvnxq000lpv4nx0m5hs9n"},{"post_id":"cjahvvnxe000gpv4nlarlj7ed","tag_id":"cjahvvnx10004pv4na7nsnjtz","_id":"cjahvvnxu000npv4n71iq7n4d"},{"post_id":"cjahvvnx30006pv4n8fwn9ono","tag_id":"cjahvvnx10004pv4na7nsnjtz","_id":"cjahvvnxv000ppv4nzi806foq"},{"post_id":"cjahvvnxi000ipv4necm1naqp","tag_id":"cjahvvnx10004pv4na7nsnjtz","_id":"cjahvvnxw000spv4nleuikxq4"},{"post_id":"cjahvvnxn000kpv4nhvii7feb","tag_id":"cjahvvnx10004pv4na7nsnjtz","_id":"cjahvvnxx000upv4nfxojzn15"},{"post_id":"cjahvvnxq000mpv4n0a2bm8jg","tag_id":"cjahvvnx10004pv4na7nsnjtz","_id":"cjahvvnxz000wpv4n0f006s0j"},{"post_id":"cjahvvnxy000vpv4ny6xd5ubd","tag_id":"cjahvvnxw000rpv4nvae0hio6","_id":"cjahvvny0000zpv4nyon27agv"},{"post_id":"cjahvvnxu000opv4nro3x1p54","tag_id":"cjahvvnxw000rpv4nvae0hio6","_id":"cjahvvny10011pv4n2ckdirqf"},{"post_id":"cjahvvnxv000qpv4ndsb3etut","tag_id":"cjahvvnxw000rpv4nvae0hio6","_id":"cjahvvny30014pv4nc5wag2oj"},{"post_id":"cjahvvnxw000tpv4nzbnuri2f","tag_id":"cjahvvnxw000rpv4nvae0hio6","_id":"cjahvvny50018pv4na562qez6"},{"post_id":"cjahvvnxz000xpv4nf6tcx9bj","tag_id":"cjahvvny50017pv4ntdyfluy1","_id":"cjahvvny8001dpv4nu5357xy4"},{"post_id":"cjahvvny10010pv4nd22b2tuo","tag_id":"cjahvvny50017pv4ntdyfluy1","_id":"cjahvvny8001fpv4nqli68ne8"},{"post_id":"cjahvvny20012pv4nb2kvzzrd","tag_id":"cjahvvny8001epv4nl5pj6ycv","_id":"cjahvvny9001hpv4n30nak21c"},{"post_id":"cjahvvny30015pv4nz1he1yd3","tag_id":"cjahvvny8001gpv4n7ht060yu","_id":"cjahvvny9001jpv4n0s0at1sg"},{"post_id":"cjahvvny40016pv4nuvpc92ia","tag_id":"cjahvvny8001gpv4n7ht060yu","_id":"cjahvvnya001lpv4n4874e8df"},{"post_id":"cjahvvny50019pv4nh6vetn0m","tag_id":"cjahvvny8001gpv4n7ht060yu","_id":"cjahvvnya001npv4nzjnox7x8"},{"post_id":"cjahvvny6001apv4nfgp3wid8","tag_id":"cjahvvnya001mpv4nwhq2h231","_id":"cjahvvnya001ppv4n9jjpg0fq"},{"post_id":"cjahvvny7001cpv4nm9p3b5go","tag_id":"cjahvvny8001epv4nl5pj6ycv","_id":"cjahvvnyb001qpv4nos3sihwn"}],"Tag":[{"name":"scala","_id":"cjahvvnx10004pv4na7nsnjtz"},{"name":"android","_id":"cjahvvnxw000rpv4nvae0hio6"},{"name":"书法","_id":"cjahvvny50017pv4ntdyfluy1"},{"name":"数学","_id":"cjahvvny8001epv4nl5pj6ycv"},{"name":"深入理解计算机系统","_id":"cjahvvny8001gpv4n7ht060yu"},{"name":"資治通鑑","_id":"cjahvvnya001mpv4nwhq2h231"}]}}